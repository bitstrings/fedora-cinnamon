diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
index 59d139804..b2eff112c 100644
--- a/.gitlab-ci.yml
+++ b/.gitlab-ci.yml
@@ -1,6 +1,6 @@
 include:
-  - remote: 'https://gitlab.freedesktop.org/freedesktop/ci-templates/-/raw/bbe5232986c9b98eb1efe62484e07216f7d1a4df/templates/fedora.yml'
-  - remote: 'https://gitlab.freedesktop.org/freedesktop/ci-templates/-/raw/bbe5232986c9b98eb1efe62484e07216f7d1a4df/templates/ci-fairy.yml'
+  - remote: 'https://gitlab.freedesktop.org/freedesktop/ci-templates/-/raw/34f4ade99434043f88e164933f570301fd18b125/templates/fedora.yml'
+  - remote: 'https://gitlab.freedesktop.org/freedesktop/ci-templates/-/raw/34f4ade99434043f88e164933f570301fd18b125/templates/ci-fairy.yml'
 
 stages:
  - review
@@ -14,10 +14,10 @@ stages:
 variables:
   FDO_UPSTREAM_REPO: GNOME/mutter
 
-.mutter.fedora:34@common:
+.mutter.fedora:35@common:
   variables:
-    FDO_DISTRIBUTION_VERSION: 34
-    BASE_TAG: '2021-09-04.1'
+    FDO_DISTRIBUTION_VERSION: 35
+    BASE_TAG: '2022-01-05.1'
     FDO_DISTRIBUTION_PACKAGES:
       asciidoc
       clang
@@ -28,24 +28,29 @@ variables:
       sassc
       uncrustify
       xorg-x11-server-Xvfb
+      mesa-dri-drivers
 
     FDO_DISTRIBUTION_EXEC: |
       dnf install -y 'dnf-command(builddep)' &&
 
+      dnf builddep -y gsettings-desktop-schemas --setopt=install_weak_deps=False &&
       dnf builddep -y mutter --setopt=install_weak_deps=False &&
       dnf builddep -y gnome-shell --setopt=install_weak_deps=False &&
+      dnf builddep -y libinput --setopt=install_weak_deps=False &&
+      dnf builddep -y wayland-protocols --setopt=install_weak_deps=False &&
 
       ./.gitlab-ci/install-meson-project.sh \
-        https://gitlab.gnome.org/GNOME/glib.git \
-        main . 02742ef957b532789c003eef80ec7f51c370e3d5 &&
+        https://gitlab.gnome.org/GNOME/gsettings-desktop-schemas.git \
+        master . 79dd34316ffa44221bcd1b6227aebe1b4b2643d8 &&
 
       ./.gitlab-ci/install-meson-project.sh \
-        https://gitlab.gnome.org/GNOME/gsettings-desktop-schemas.git \
-        41.alpha . &&
+        https://gitlab.freedesktop.org/wayland/wayland-protocols.git \
+        1.24 . &&
 
       ./.gitlab-ci/install-meson-project.sh \
-        https://gitlab.gnome.org/GNOME/gjs.git \
-        1.69.2 . &&
+        -Dgtk_doc=false \
+        https://gitlab.gnome.org/GNOME/libgweather.git \
+        main . 1f687f6375a3f3f006600119f7eee7df7348ade5 &&
 
       rpm -e --nodeps gnome-bluetooth-libs-devel \
                       mutter mutter-devel \
@@ -65,13 +70,13 @@ default:
       - 'scheduler_failure'
       - 'api_failure'
 
-.mutter.fedora:34@x86_64:
-  extends: .mutter.fedora:34@common
+.mutter.fedora:35@x86_64:
+  extends: .mutter.fedora:35@common
   variables:
     FDO_DISTRIBUTION_TAG: "x86_64-${BASE_TAG}"
 
-.mutter.fedora:34@aarch64:
-  extends: .mutter.fedora:34@common
+.mutter.fedora:35@aarch64:
+  extends: .mutter.fedora:35@common
   variables:
     FDO_DISTRIBUTION_TAG: "aarch64-${BASE_TAG}"
   tags:
@@ -136,7 +141,7 @@ check-merge-request:
 build-fedora-container@x86_64:
   extends:
     - .fdo.container-build@fedora@x86_64
-    - .mutter.fedora:34@x86_64
+    - .mutter.fedora:35@x86_64
   stage: prepare
   needs:
     - check-commit-log
@@ -147,7 +152,7 @@ build-fedora-container@x86_64:
 build-fedora-container@aarch64:
   extends:
     - .fdo.container-build@fedora@aarch64
-    - .mutter.fedora:34@aarch64
+    - .mutter.fedora:35@aarch64
   stage: prepare
   needs:
     - check-commit-log
@@ -158,7 +163,7 @@ build-fedora-container@aarch64:
 check-code-style:
   extends:
     - .fdo.distribution-image@fedora
-    - .mutter.fedora:34@x86_64
+    - .mutter.fedora:35@x86_64
   stage: code-review
   needs:
     - build-fedora-container@x86_64
@@ -190,21 +195,21 @@ check-code-style:
 build-mutter@x86_64:
   extends:
     - .build-mutter
-    - .mutter.fedora:34@x86_64
+    - .mutter.fedora:35@x86_64
   needs:
     - build-fedora-container@x86_64
 
 build-mutter@aarch64:
   extends:
     - .build-mutter
-    - .mutter.fedora:34@aarch64
+    - .mutter.fedora:35@aarch64
   needs:
     - build-fedora-container@aarch64
 
 build-without-opengl-and-glx@x86_64:
   extends:
     - .fdo.distribution-image@fedora
-    - .mutter.fedora:34@x86_64
+    - .mutter.fedora:35@x86_64
   stage: build
   needs:
     - build-fedora-container@x86_64
@@ -219,7 +224,7 @@ build-without-opengl-and-glx@x86_64:
 build-without-native-backend-and-wayland@x86_64:
   extends:
     - .fdo.distribution-image@fedora
-    - .mutter.fedora:34@x86_64
+    - .mutter.fedora:35@x86_64
   stage: build
   needs:
     - build-fedora-container@x86_64
@@ -245,7 +250,6 @@ build-without-native-backend-and-wayland@x86_64:
   before_script:
     - glib-compile-schemas $GSETTINGS_SCHEMA_DIR
     # Disable e.g. audio support to not dead lock screen cast tests
-    - rm -f /usr/share/pipewire/media-session.d/with-*
     - mkdir -m 700 $XDG_RUNTIME_DIR
     - pipewire & sleep 2
 
@@ -256,11 +260,11 @@ build-without-native-backend-and-wayland@x86_64:
   stage: test
   script:
     - dbus-run-session -- xvfb-run -a -s "$XVFB_SERVER_ARGS"
-        catchsegv meson test -C build --no-rebuild -t 10
+        ./.gitlab-ci/run-meson.sh test -C build --no-rebuild -t 10
   artifacts:
     expire_in: 1 day
     reports:
-      junit: "build/meson-logs/testlog-catchsegv.junit.xml"
+      junit: "build/meson-logs/testlog.junit.xml"
     name: "mutter-${CI_JOB_NAME}-${CI_COMMIT_REF_NAME}"
     when: always
     paths:
@@ -269,14 +273,14 @@ build-without-native-backend-and-wayland@x86_64:
 test-mutter@x86_64:
   extends:
     - .test-mutter
-    - .mutter.fedora:34@x86_64
+    - .mutter.fedora:35@x86_64
   needs:
     - build-mutter@x86_64
 
 test-mutter@aarch64:
   extends:
     - .test-mutter
-    - .mutter.fedora:34@aarch64
+    - .mutter.fedora:35@aarch64
   needs:
     - build-mutter@aarch64
 
@@ -295,21 +299,21 @@ test-mutter@aarch64:
 test-mutter-coverage@x86_64:
   extends:
     - .test-mutter-coverage
-    - .mutter.fedora:34@x86_64
+    - .mutter.fedora:35@x86_64
   needs:
     - test-mutter@x86_64
 
 test-mutter-coverage@aarch64:
   extends:
     - .test-mutter-coverage
-    - .mutter.fedora:34@aarch64
+    - .mutter.fedora:35@aarch64
   needs:
     - test-mutter@aarch64
 
 can-build-gnome-shell@x86_64:
   extends:
     - .fdo.distribution-image@fedora
-    - .mutter.fedora:34@x86_64
+    - .mutter.fedora:35@x86_64
   stage: test
   needs:
     - build-mutter@x86_64
@@ -327,7 +331,7 @@ test-mutter-coverity:
     - when: manual
   extends:
     - .fdo.distribution-image@fedora
-    - .mutter.fedora:34@x86_64
+    - .mutter.fedora:35@x86_64
   needs:
     - build-fedora-container@x86_64
   stage: analyze
@@ -349,13 +353,14 @@ test-mutter-coverity:
 dist-mutter:
   extends:
     - .fdo.distribution-image@fedora
-    - .mutter.fedora:34@x86_64
+    - .mutter.fedora:35@x86_64
   <<: *test-setup
   stage: deploy
   needs:
     - build-mutter@x86_64
   script:
-    - dbus-run-session -- xvfb-run -a -s "$XVFB_SERVER_ARGS" meson dist -C build
+    - dbus-run-session -- xvfb-run -a -s "$XVFB_SERVER_ARGS"
+        ./.gitlab-ci/run-meson.sh dist -C build
   rules:
     - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
       changes:
diff --git a/.gitlab-ci/run-meson.sh b/.gitlab-ci/run-meson.sh
new file mode 100755
index 000000000..16a20f621
--- /dev/null
+++ b/.gitlab-ci/run-meson.sh
@@ -0,0 +1,8 @@
+#!/usr/bin/bash
+
+set -e
+
+wireplumber &
+sleep 1
+
+catchsegv meson "$@"
diff --git a/HACKING.md b/HACKING.md
index 5c3a9945f..ec65002f6 100644
--- a/HACKING.md
+++ b/HACKING.md
@@ -283,4 +283,4 @@ click_action_clicked_cb (ClutterClickAction *click_action,
 }
 ```
 
-[gnome-coding-style]: https://developer.gnome.org/programming-guidelines/stable/c-coding-style.html.en
+[gnome-coding-style]: https://developer.gnome.org/documentation/guidelines/programming/coding-style.html
diff --git a/NEWS b/NEWS
index 0efcd59cc..4e9e0554c 100644
--- a/NEWS
+++ b/NEWS
@@ -1,101 +1,3 @@
-41.4
-====
-* Fix DND between X11 and wayland clients [Carlos; !2124]
-* Fix resetting idle time on lid open [Carlos; !2272]
-* wayland/gtk: Only perform allowed titlebar gestures [Florian; !2281]
-* Place popups on the same monitor as the anchor rect [Jonas; !2252]
-* Fix wrong resizes of some clients on focus changes [Sebastian; #2091]
-* Misc. bug fixes [Robert; !2232, !2263]
-* Fixed crashes [Carlos, Daniel; !2237, !2282, !2251]
-
-Contributors:
-  Carlos Garnacho, Sebastian Keller, Robert Mader, Florian Müllner,
-  Daniel van Vugt, Jonas Ådahl
-
-Translators:
-  sicklylife [ja]
-
-41.3
-====
-* Check keyboard serials for activation [Carlos; !2148]
-* Fix mixed up refresh rates in multi-monitor setups [Robert; !2169]
-* Allow disabling HW cursors [Olivier; !2150]
-* Improve damage handling [Robert; !2168]
-* Consider xrandr flags for advertised modes [Robert; !2190]
-* Ensure constraints after client resize [Sebastian; !2103]
-* window-group: Disable culling when rendinging clone to offscreen buffer
-  [Sebastian; !2080]
-* Fix workspace switch animation in default plugin [Mark, Erik; !2076, !2120]
-* Fix unfullscreening of window that were mapped fullscreen [Jonas; !2210]
-* Fix DMA-BUF screencasts with unredirected fullscreen windows [Georges; !2186]
-* Fix orientation changes on devices with 90° [Hans, Marco; !2090]
-* Fixed crashes [Jonas; !2147, !2216]
-* Plugged leaks [Sebastian, Jonas; !2193, !2225]
-* Misc. bug fixes and cleanups [Jonas, Ievgen; !2002, !2162, !2187]
-
-Contributors:
-  Olivier Fourdan, Carlos Garnacho, Hans de Goede, Sebastian Keller,
-  Robert Mader, Mark, Erik Massop, Florian Müllner,
-  Georges Basile Stavracas Neto, Ievgen Popovych, Jonas Ådahl
-
-41.2
-====
-* Fix blank screen when unplugging docking station [Jonas; !2097]
-* Prefer GBM over EGLStream where possible [Jonas; !2051, !2052]
-* Fix unredirected Xwayland windows not getting updated [Michel; !2112]
-* Improve anti-aliasing of background corners [Daniel; !2102]
-* Copy damage rectangles to secondary GPU [Piotr; !2033]
-* Improve Wacom tablet mapping [Carlos; !2107]
-* Fixed crashes [Jonas, Daniel; #1950, !2081, !2104, !1991, !2127]
-* Misc. bug fixes and cleanups [Simon, Corentin, Pascal; !2049, !2119, !2138]
-
-Contributors:
-  Michel Dänzer, Carlos Garnacho, Simon McVittie, Pascal Nowack, Corentin Noël,
-  Daniel van Vugt, Jonas Ådahl, Piotr Łopatka
-
-Translators:
-  Milo Casagrande [it], Quentin PAGÈS [oc]
-
-41.1
-====
-* Fix monitor screencast scanouts [Michel; !1914]
-* dma-buf: Use alpha-less pixel formats where appropriate [Robert; !1810]
-* wayland: Allow clients to maximize windows regardless of constraints
-  [Christian; !1997]
-* Handle hotplug events without relevant changes more effectively
-  [Marco; !1964]
-* Improve error reporting when startup fails [Jonas; !1994]
-* dma-buf: Add support for ABGR and XBGR formats [Erfan; !1999]
-* Fix X11 middle button emulation setting [José; !2000]
-* Include server-side shadows in window screenshots [Robert; !1996]
-* Don't change workspaces of unmanaged windows [Sebastian; !2003]
-* Reset idletime when unplugging the power cable [Bastien; !2029]
-* xwayland: Avoid unnecessary _NET_WM_STATE events [Dor; !2032]
-* Fix videos in Firefox stuttering in overview [Robert; !2034]
-* Don't use atomic mode setting for virtio_gpu driver [Jonas; !2040]
-* Improve on-screen keyboard on X11 [Sebastian, Ray; !1955, !2039]
-* misc [Daniel, Jonas, Corentin, Robert; !1992, !2007, !2008, !2026, !2044]
-* Fix text glitches after size changes [Sebastian; !2006]
-* Fix reporting output rotation to xwayland [Olivier; !2050]
-* wayland: Accept final preference of drop destination [Robert; !2043]
-* Fix erratic scrolling in GTK apps [Carlos; gnome-shell#4647]
-* Fix tilt direction of pen/tablet inputs [Quytelda; !2065]
-* Use b/w unicode for tablet mode OSD [Carlos; !2064]
-* Fix negative paint volume offscreen effect [Sebastian; !2031]
-* Only add paint volumes of mapped actors to stage clip [Robert; !2035]
-* Fix mapping tablet input to correct monitor [Jason; !1934]
-* Misc. bug fixes and cleanups
-
-Contributors:
-  Marco Trevisan (Treviño), Erfan Abdi, Dor Askayo, Michel Dänzer,
-  José Expósito, Olivier Fourdan, Carlos Garnacho, Jason Gerecke,
-  Quytelda Kahja, Sebastian Keller, Robert Mader, Bastien Nocera, Corentin Noël,
-  Christian Rauch, Ray Strode, Daniel van Vugt, Jonas Ådahl
-
-Translators:
-  eshagh shahidani [fa], Danial Behzadi [fa], Марко Костић [sr],
-  Zander Brown [en_GB], Ngọc Quân Trần [vi], Rūdolfs Mazurs [lv]
-
 41.0
 ====
 * Avoid race in wl_seat capabilities [Olivier; !77]
diff --git a/clutter/clutter/cally/cally-actor.h b/clutter/clutter/cally/cally-actor.h
index f67bcafb2..ebf096262 100644
--- a/clutter/clutter/cally/cally-actor.h
+++ b/clutter/clutter/cally/cally-actor.h
@@ -89,8 +89,6 @@ struct _CallyActor
 /**
  * CallyActorClass:
  * @notify_clutter: Signal handler for notify signal on Clutter actor
- * @focus_clutter: Signal handler for key-focus-in and key-focus-out
- *   signal on Clutter actor. This virtual functions is deprecated.
  * @add_actor: Signal handler for actor-added signal on
  *   ClutterContainer interface
  * @remove_actor: Signal handler for actor-added signal on
@@ -110,9 +108,6 @@ struct _CallyActorClass
   void     (*notify_clutter) (GObject    *object,
                               GParamSpec *pspec);
 
-  gboolean (*focus_clutter)  (ClutterActor *actor,
-                              gpointer      data);
-
   gint     (*add_actor)      (ClutterActor *container,
                               ClutterActor *actor,
                               gpointer      data);
diff --git a/clutter/clutter/cally/cally-util.c b/clutter/clutter/cally/cally-util.c
index ebb69f8ee..e25a6eeae 100644
--- a/clutter/clutter/cally/cally-util.c
+++ b/clutter/clutter/cally/cally-util.c
@@ -60,17 +60,6 @@ static const gchar *         cally_util_get_toolkit_name		    (void);
 static const gchar *         cally_util_get_toolkit_version          (void);
 
 /* private */
-static void                  cally_util_simulate_snooper_install     (void);
-static void                  cally_util_simulate_snooper_remove      (void);
-static gboolean              cally_key_snooper                       (ClutterActor *actor,
-                                                                      ClutterEvent *event,
-                                                                      gpointer      user_data);
-static void                  cally_util_stage_added_cb               (ClutterStageManager *stage_manager,
-                                                                      ClutterStage *stage,
-                                                                      gpointer data);
-static void                  cally_util_stage_removed_cb             (ClutterStageManager *stage_manager,
-                                                                      ClutterStage *stage,
-                                                                      gpointer data);
 static gboolean              notify_hf                               (gpointer key,
                                                                       gpointer value,
                                                                       gpointer data);
@@ -153,12 +142,8 @@ cally_util_add_key_event_listener (AtkKeySnoopFunc  listener,
   CallyKeyEventInfo *event_info = NULL;
 
   if (!key_listener_list)
-  {
     key_listener_list = g_hash_table_new_full (NULL, NULL, NULL, g_free);
 
-    cally_util_simulate_snooper_install ();
-  }
-
   event_info = g_new (CallyKeyEventInfo, 1);
   event_info->listener = listener;
   event_info->func_data = data;
@@ -179,75 +164,11 @@ cally_util_remove_key_event_listener (guint remove_listener)
     {
       g_hash_table_destroy (key_listener_list);
       key_listener_list = NULL;
-      cally_util_simulate_snooper_remove ();
     }
 }
 
 /* ------------------------------ PRIVATE FUNCTIONS ------------------------- */
 
-/* Trying to emulate gtk_key_snooper install (a kind of wrapper). This
-   could be implemented without it, but I will maintain it in this
-   way, so if in the future clutter implements it natively it would be
-   easier the transition */
-static void
-cally_util_simulate_snooper_install (void)
-{
-  ClutterStageManager *stage_manager = NULL;
-  ClutterStage *stage = NULL;
-  GSList *stage_list = NULL;
-  GSList *iter = NULL;
-
-  stage_manager = clutter_stage_manager_get_default ();
-  stage_list = clutter_stage_manager_list_stages (stage_manager);
-
-  for (iter = stage_list; iter != NULL; iter = g_slist_next (iter))
-    {
-      stage = CLUTTER_STAGE (iter->data);
-
-      g_signal_connect (G_OBJECT (stage), "captured-event",
-                        G_CALLBACK (cally_key_snooper), NULL);
-    }
-
-  g_signal_connect (G_OBJECT (stage_manager), "stage-added",
-                    G_CALLBACK (cally_util_stage_added_cb), cally_key_snooper);
-  g_signal_connect (G_OBJECT (stage_manager), "stage-removed",
-                    G_CALLBACK (cally_util_stage_removed_cb), cally_key_snooper);
-
-  g_slist_free (stage_list);
-}
-
-static void
-cally_util_simulate_snooper_remove (void)
-{
-  ClutterStageManager *stage_manager = NULL;
-  ClutterStage *stage = NULL;
-  GSList *stage_list = NULL;
-  GSList *iter = NULL;
-  gint num = 0;
-
-  stage_manager = clutter_stage_manager_get_default ();
-  stage_list = clutter_stage_manager_list_stages (stage_manager);
-
-  for (iter = stage_list; iter != NULL; iter = g_slist_next (iter))
-    {
-      stage = CLUTTER_STAGE (iter->data);
-
-      num += g_signal_handlers_disconnect_by_func (stage, cally_key_snooper, NULL);
-    }
-
-  g_signal_handlers_disconnect_by_func (G_OBJECT (stage_manager),
-                                        G_CALLBACK (cally_util_stage_added_cb),
-                                        cally_key_snooper);
-
-  g_signal_handlers_disconnect_by_func (G_OBJECT (stage_manager),
-                                        G_CALLBACK (cally_util_stage_removed_cb),
-                                        cally_key_snooper);
-
-#ifdef CALLY_DEBUG
-  g_print ("Number of snooper callbacks disconnected: %i\n", num);
-#endif
-}
-
 static AtkKeyEventStruct *
 atk_key_event_from_clutter_event_key (ClutterKeyEvent *clutter_event,
                                       gunichar         password_char)
@@ -384,59 +305,34 @@ check_key_visibility (ClutterEvent *event)
     return DEFAULT_PASSWORD_CHAR;
 }
 
-static gboolean
-cally_key_snooper (ClutterActor *actor,
-                   ClutterEvent *event,
-                   gpointer      user_data)
+gboolean
+cally_snoop_key_event (ClutterKeyEvent *key)
 {
+  ClutterEvent *event = (ClutterEvent *) key;
   AtkKeyEventStruct *key_event = NULL;
-  gint consumed = 0;
+  gboolean consumed = FALSE;
   gunichar password_char = 0;
 
   /* filter key events */
   if ((event->type != CLUTTER_KEY_PRESS) && (event->type != CLUTTER_KEY_RELEASE))
-    {
-      return FALSE;
-    }
-
-  password_char = check_key_visibility (event);
+    return FALSE;
 
   if (key_listener_list)
     {
       GHashTable *new_hash = g_hash_table_new (NULL, NULL);
 
       g_hash_table_foreach (key_listener_list, insert_hf, new_hash);
-      key_event = atk_key_event_from_clutter_event_key ((ClutterKeyEvent *)event,
-                                                        password_char);
+      password_char = check_key_visibility (event);
+      key_event = atk_key_event_from_clutter_event_key (key, password_char);
       /* func data is inside the hash table */
-      consumed = g_hash_table_foreach_steal (new_hash, notify_hf, key_event);
+      consumed = g_hash_table_foreach_steal (new_hash, notify_hf, key_event) > 0;
       g_hash_table_destroy (new_hash);
 
       g_free (key_event->string);
       g_free (key_event);
     }
 
-  return (consumed ? 1 : 0);
-}
-
-static void
-cally_util_stage_added_cb (ClutterStageManager *stage_manager,
-                           ClutterStage *stage,
-                           gpointer data)
-{
-  GCallback cally_key_snooper_cb = G_CALLBACK (data);
-
-  g_signal_connect (G_OBJECT (stage), "captured-event", cally_key_snooper_cb, NULL);
-}
-
-static void
-cally_util_stage_removed_cb (ClutterStageManager *stage_manager,
-                             ClutterStage *stage,
-                             gpointer data)
-{
-  GCallback cally_key_snooper_cb = G_CALLBACK (data);
-
-  g_signal_handlers_disconnect_by_func (stage, cally_key_snooper_cb, NULL);
+  return consumed;
 }
 
 void
diff --git a/clutter/clutter/cally/cally-util.h b/clutter/clutter/cally/cally-util.h
index dcc5deb1d..5556d40cf 100644
--- a/clutter/clutter/cally/cally-util.h
+++ b/clutter/clutter/cally/cally-util.h
@@ -79,6 +79,8 @@ GType cally_util_get_type (void) G_GNUC_CONST;
 
 void _cally_util_override_atk_util (void);
 
+gboolean cally_snoop_key_event (ClutterKeyEvent *key);
+
 G_END_DECLS
 
 #endif /* __CALLY_UTIL_H__ */
diff --git a/clutter/clutter/clutter-action-private.h b/clutter/clutter/clutter-action-private.h
new file mode 100644
index 000000000..510c21cd8
--- /dev/null
+++ b/clutter/clutter/clutter-action-private.h
@@ -0,0 +1,44 @@
+/*
+ * Clutter.
+ *
+ * An OpenGL based 'interactive canvas' library.
+ *
+ * Copyright (C) 2021 Red Hat Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author:
+ *   Carlos Garnacho <carlosg@gnome.org>
+ */
+
+#ifndef CLUTTER_ACTION_PRIVATE_H
+#define CLUTTER_ACTION_PRIVATE_H
+
+#if !defined(__CLUTTER_H_INSIDE__) && !defined(CLUTTER_COMPILATION)
+#error "Only <clutter/clutter.h> can be included directly."
+#endif
+
+#include <clutter/clutter-action.h>
+
+G_BEGIN_DECLS
+
+void clutter_action_set_phase (ClutterAction     *action,
+                               ClutterEventPhase  phase);
+
+gboolean clutter_action_handle_event (ClutterAction      *action,
+                                      const ClutterEvent *event);
+
+G_END_DECLS
+
+#endif /* CLUTTER_ACTION_PRIVATE_H */
diff --git a/clutter/clutter/clutter-action.c b/clutter/clutter/clutter-action.c
index a3410f184..50eda35f2 100644
--- a/clutter/clutter/clutter-action.c
+++ b/clutter/clutter/clutter-action.c
@@ -44,18 +44,63 @@
 #include "clutter-build-config.h"
 
 #include "clutter-action.h"
-
+#include "clutter-action-private.h"
 #include "clutter-debug.h"
 #include "clutter-private.h"
 
-G_DEFINE_ABSTRACT_TYPE (ClutterAction, clutter_action, CLUTTER_TYPE_ACTOR_META);
+typedef struct _ClutterActionPrivate ClutterActionPrivate;
+
+struct _ClutterActionPrivate
+{
+  ClutterEventPhase phase;
+};
+
+G_DEFINE_ABSTRACT_TYPE_WITH_PRIVATE (ClutterAction, clutter_action,
+                                     CLUTTER_TYPE_ACTOR_META)
+
+static gboolean
+clutter_action_handle_event_default (ClutterAction      *action,
+                                     const ClutterEvent *event)
+{
+  return FALSE;
+}
 
 static void
 clutter_action_class_init (ClutterActionClass *klass)
 {
+  klass->handle_event = clutter_action_handle_event_default;
 }
 
 static void
 clutter_action_init (ClutterAction *self)
 {
 }
+
+void
+clutter_action_set_phase (ClutterAction     *action,
+                          ClutterEventPhase  phase)
+{
+  ClutterActionPrivate *priv;
+
+  priv = clutter_action_get_instance_private (action);
+  priv->phase = phase;
+}
+
+ClutterEventPhase
+clutter_action_get_phase (ClutterAction *action)
+{
+  ClutterActionPrivate *priv;
+
+  g_return_val_if_fail (CLUTTER_IS_ACTION (action), CLUTTER_PHASE_CAPTURE);
+
+  priv = clutter_action_get_instance_private (action);
+
+  return priv->phase;
+}
+
+gboolean
+clutter_action_handle_event (ClutterAction      *action,
+                             const ClutterEvent *event)
+{
+  return CLUTTER_ACTION_GET_CLASS (action)->handle_event (action, event);
+}
diff --git a/clutter/clutter/clutter-action.h b/clutter/clutter/clutter-action.h
index 8e5ea6c30..d38d2c63c 100644
--- a/clutter/clutter/clutter-action.h
+++ b/clutter/clutter/clutter-action.h
@@ -51,6 +51,9 @@ struct _ClutterActionClass
   /*< private >*/
   ClutterActorMetaClass parent_class;
 
+  gboolean (* handle_event) (ClutterAction      *action,
+                             const ClutterEvent *event);
+
   void (* _clutter_action1) (void);
   void (* _clutter_action2) (void);
   void (* _clutter_action3) (void);
@@ -70,6 +73,11 @@ void           clutter_actor_add_action_with_name  (ClutterActor  *self,
                                                     const gchar   *name,
                                                     ClutterAction *action);
 CLUTTER_EXPORT
+void           clutter_actor_add_action_full       (ClutterActor      *self,
+                                                    const char        *name,
+                                                    ClutterEventPhase  phase,
+                                                    ClutterAction     *action);
+CLUTTER_EXPORT
 void           clutter_actor_remove_action         (ClutterActor  *self,
                                                     ClutterAction *action);
 CLUTTER_EXPORT
@@ -86,6 +94,8 @@ void           clutter_actor_clear_actions         (ClutterActor  *self);
 CLUTTER_EXPORT
 gboolean       clutter_actor_has_actions           (ClutterActor  *self);
 
+ClutterEventPhase clutter_action_get_phase (ClutterAction *action);
+
 G_END_DECLS
 
 #endif /* __CLUTTER_ACTION_H__ */
diff --git a/clutter/clutter/clutter-actor.c b/clutter/clutter/clutter-actor.c
index 5a22846d2..4b1c0813b 100644
--- a/clutter/clutter/clutter-actor.c
+++ b/clutter/clutter/clutter-actor.c
@@ -613,6 +613,7 @@
 #include "clutter-actor-private.h"
 
 #include "clutter-action.h"
+#include "clutter-action-private.h"
 #include "clutter-actor-meta-private.h"
 #include "clutter-animatable.h"
 #include "clutter-color-static.h"
@@ -1456,10 +1457,7 @@ clutter_actor_update_map_state (ClutterActor  *self,
       /* Map */
       if (should_be_mapped)
         {
-          if (!must_be_realized)
-            g_warning ("Somehow we think actor '%s' should be mapped but "
-                       "not realized, which isn't allowed",
-                       _clutter_actor_get_debug_name (self));
+          g_assert (should_be_mapped == must_be_realized);
 
           /* realization is allowed to fail (though I don't know what
            * an app is supposed to do about that - shouldn't it just
@@ -3962,7 +3960,10 @@ clutter_actor_pick (ClutterActor       *actor,
 
       clutter_paint_volume_to_box (&priv->last_paint_volume, &box);
       if (!clutter_pick_context_intersects_box (pick_context, &box))
-        goto out;
+        {
+          clutter_pick_context_log_overlap (pick_context, actor);
+          goto out;
+        }
     }
 
   if (priv->enable_model_view_transform)
@@ -9455,14 +9456,11 @@ clutter_actor_set_min_width (ClutterActor *self,
   ClutterActorBox old = { 0, };
   ClutterLayoutInfo *info;
 
-  /* if we are setting the size on a top-level actor and the
-   * backend only supports static top-levels (e.g. framebuffers)
-   * then we ignore the passed value and we override it with
-   * the stage implementation's preferred size.
-   */
-  if (CLUTTER_ACTOR_IS_TOPLEVEL (self) &&
-      clutter_feature_available (CLUTTER_FEATURE_STAGE_STATIC))
-    return;
+  if (CLUTTER_ACTOR_IS_TOPLEVEL (self))
+    {
+      g_warning ("Can't set the minimal width of a stage");
+      return;
+    }
 
   info = _clutter_actor_get_layout_info (self);
 
@@ -9493,14 +9491,11 @@ clutter_actor_set_min_height (ClutterActor *self,
   ClutterActorBox old = { 0, };
   ClutterLayoutInfo *info;
 
-  /* if we are setting the size on a top-level actor and the
-   * backend only supports static top-levels (e.g. framebuffers)
-   * then we ignore the passed value and we override it with
-   * the stage implementation's preferred size.
-   */
-  if (CLUTTER_ACTOR_IS_TOPLEVEL (self) &&
-      clutter_feature_available (CLUTTER_FEATURE_STAGE_STATIC))
-    return;
+  if (CLUTTER_ACTOR_IS_TOPLEVEL (self))
+    {
+      g_warning ("Can't set the minimal height of a stage");
+      return;
+    }
 
   info = _clutter_actor_get_layout_info (self);
 
@@ -9530,15 +9525,6 @@ clutter_actor_set_natural_width (ClutterActor *self,
   ClutterActorBox old = { 0, };
   ClutterLayoutInfo *info;
 
-  /* if we are setting the size on a top-level actor and the
-   * backend only supports static top-levels (e.g. framebuffers)
-   * then we ignore the passed value and we override it with
-   * the stage implementation's preferred size.
-   */
-  if (CLUTTER_ACTOR_IS_TOPLEVEL (self) &&
-      clutter_feature_available (CLUTTER_FEATURE_STAGE_STATIC))
-    return;
-
   info = _clutter_actor_get_layout_info (self);
 
   if (priv->natural_width_set && natural_width == info->natural.width)
@@ -9567,15 +9553,6 @@ clutter_actor_set_natural_height (ClutterActor *self,
   ClutterActorBox old = { 0, };
   ClutterLayoutInfo *info;
 
-  /* if we are setting the size on a top-level actor and the
-   * backend only supports static top-levels (e.g. framebuffers)
-   * then we ignore the passed value and we override it with
-   * the stage implementation's preferred size.
-   */
-  if (CLUTTER_ACTOR_IS_TOPLEVEL (self) &&
-      clutter_feature_available (CLUTTER_FEATURE_STAGE_STATIC))
-    return;
-
   info = _clutter_actor_get_layout_info (self);
 
   if (priv->natural_height_set && natural_height == info->natural.height)
@@ -12257,6 +12234,38 @@ clutter_actor_set_child_at_index (ClutterActor *self,
  * Event handling
  */
 
+static gboolean
+clutter_actor_run_actions (ClutterActor       *self,
+                           const ClutterEvent *event,
+                           ClutterEventPhase   phase)
+{
+  ClutterActorPrivate *priv;
+  const GList *actions, *l;
+  gboolean retval = CLUTTER_EVENT_PROPAGATE;
+
+  priv = self->priv;
+  if (!priv->actions)
+    return CLUTTER_EVENT_PROPAGATE;
+
+  actions = _clutter_meta_group_peek_metas (priv->actions);
+
+  for (l = actions; l; l = l->next)
+    {
+      ClutterAction *action = l->data;
+      ClutterEventPhase action_phase;
+
+      action_phase = clutter_action_get_phase (action);
+
+      if (action_phase == phase)
+        {
+          if (clutter_action_handle_event (action, event))
+            retval = CLUTTER_EVENT_STOP;
+        }
+    }
+
+  return retval;
+}
+
 /**
  * clutter_actor_event:
  * @actor: a #ClutterActor
@@ -12278,6 +12287,7 @@ clutter_actor_event (ClutterActor       *actor,
                      const ClutterEvent *event,
                      gboolean            capture)
 {
+  ClutterEventPhase phase;
   gboolean retval = FALSE;
   gint signal_num = -1;
   GQuark detail = 0;
@@ -12287,6 +12297,11 @@ clutter_actor_event (ClutterActor       *actor,
 
   g_object_ref (actor);
 
+  phase = capture ? CLUTTER_PHASE_CAPTURE : CLUTTER_PHASE_BUBBLE;
+  retval = clutter_actor_run_actions (actor, event, phase);
+  if (retval)
+    goto handled;
+
   switch (event->type)
     {
     case CLUTTER_NOTHING:
@@ -12332,6 +12347,7 @@ clutter_actor_event (ClutterActor       *actor,
       break;
     case CLUTTER_TOUCHPAD_PINCH:
     case CLUTTER_TOUCHPAD_SWIPE:
+    case CLUTTER_TOUCHPAD_HOLD:
       signal_num = -1;
       detail = quark_touchpad;
       break;
@@ -12369,6 +12385,7 @@ clutter_actor_event (ClutterActor       *actor,
         g_signal_emit (actor, actor_signals[signal_num], 0, event, &retval);
     }
 
+ handled:
   g_object_unref (actor);
 
   return retval;
@@ -13249,6 +13266,22 @@ clutter_actor_set_animatable_property (ClutterActor *actor,
   g_object_thaw_notify (obj);
 }
 
+static void
+clutter_actor_update_pointer (ClutterActor *self)
+{
+  ClutterInputDevice *pointer;
+  ClutterStage *stage;
+  ClutterSeat *seat;
+
+  stage = CLUTTER_STAGE (_clutter_actor_get_stage_internal (self));
+  if (!stage)
+    return;
+
+  seat = clutter_backend_get_default_seat (clutter_get_default_backend ());
+  pointer = clutter_seat_get_pointer (seat);
+  clutter_stage_repick_device (stage, pointer);
+}
+
 static void
 clutter_actor_set_final_state (ClutterAnimatable *animatable,
                                const gchar       *property_name,
@@ -13299,6 +13332,8 @@ clutter_actor_set_final_state (ClutterAnimatable *animatable,
         }
     }
 
+  clutter_actor_update_pointer (actor);
+
   g_free (p_name);
 }
 
@@ -14693,6 +14728,27 @@ clutter_actor_has_allocation (ClutterActor *self)
          !priv->needs_allocation;
 }
 
+static void
+clutter_actor_add_action_internal (ClutterActor      *self,
+                                   ClutterAction     *action,
+                                   ClutterEventPhase  phase)
+{
+  ClutterActorPrivate *priv;
+
+  priv = self->priv;
+
+  if (priv->actions == NULL)
+    {
+      priv->actions = g_object_new (CLUTTER_TYPE_META_GROUP, NULL);
+      priv->actions->actor = self;
+    }
+
+  clutter_action_set_phase (action, phase);
+  _clutter_meta_group_add_meta (priv->actions, CLUTTER_ACTOR_META (action));
+
+  g_object_notify_by_pspec (G_OBJECT (self), obj_props[PROP_ACTIONS]);
+}
+
 /**
  * clutter_actor_add_action:
  * @self: a #ClutterActor
@@ -14712,22 +14768,10 @@ void
 clutter_actor_add_action (ClutterActor  *self,
                           ClutterAction *action)
 {
-  ClutterActorPrivate *priv;
-
   g_return_if_fail (CLUTTER_IS_ACTOR (self));
   g_return_if_fail (CLUTTER_IS_ACTION (action));
 
-  priv = self->priv;
-
-  if (priv->actions == NULL)
-    {
-      priv->actions = g_object_new (CLUTTER_TYPE_META_GROUP, NULL);
-      priv->actions->actor = self;
-    }
-
-  _clutter_meta_group_add_meta (priv->actions, CLUTTER_ACTOR_META (action));
-
-  g_object_notify_by_pspec (G_OBJECT (self), obj_props[PROP_ACTIONS]);
+  clutter_actor_add_action_internal (self, action, CLUTTER_PHASE_BUBBLE);
 }
 
 /**
@@ -14761,6 +14805,22 @@ clutter_actor_add_action_with_name (ClutterActor  *self,
   clutter_actor_add_action (self, action);
 }
 
+void
+clutter_actor_add_action_full (ClutterActor      *self,
+                               const char        *name,
+                               ClutterEventPhase  phase,
+                               ClutterAction     *action)
+{
+  g_return_if_fail (CLUTTER_IS_ACTOR (self));
+  g_return_if_fail (name != NULL);
+  g_return_if_fail (CLUTTER_IS_ACTION (action));
+  g_return_if_fail (phase == CLUTTER_PHASE_BUBBLE ||
+                    phase == CLUTTER_PHASE_CAPTURE);
+
+  clutter_actor_meta_set_name (CLUTTER_ACTOR_META (action), name);
+  clutter_actor_add_action_internal (self, action, phase);
+}
+
 /**
  * clutter_actor_remove_action:
  * @self: a #ClutterActor
@@ -15748,7 +15808,7 @@ clutter_actor_get_real_resource_scale (ClutterActor *self)
       guessed_scale = clutter_backend_get_fallback_resource_scale (backend);
     }
 
-  g_assert (guessed_scale >= 0.5);
+  g_assert (guessed_scale >= 1.f);
 
   /* Always return this value until we compute the correct one later.
    * If our guess turns out to be wrong, we'll emit "resource-scale-changed"
diff --git a/clutter/clutter/clutter-backend-private.h b/clutter/clutter/clutter-backend-private.h
index 9309bdd01..88bb3ea5f 100644
--- a/clutter/clutter/clutter-backend-private.h
+++ b/clutter/clutter/clutter-backend-private.h
@@ -66,17 +66,12 @@ struct _ClutterBackendClass
   GObjectClass parent_class;
 
   /* vfuncs */
-  gboolean              (* pre_parse)          (ClutterBackend  *backend,
-                                                GError         **error);
-  gboolean              (* post_parse)         (ClutterBackend  *backend,
+  gboolean              (* finish_init)        (ClutterBackend  *backend,
                                                 GError         **error);
   ClutterStageWindow *  (* create_stage)       (ClutterBackend  *backend,
                                                 ClutterStage    *wrapper,
                                                 GError         **error);
   void                  (* init_features)      (ClutterBackend  *backend);
-  void                  (* add_options)        (ClutterBackend  *backend,
-                                                GOptionGroup    *group);
-  ClutterFeatureFlags   (* get_features)       (ClutterBackend  *backend);
   CoglRenderer *        (* get_renderer)       (ClutterBackend  *backend,
                                                 GError         **error);
   CoglDisplay *         (* get_display)        (ClutterBackend  *backend,
@@ -100,19 +95,13 @@ struct _ClutterBackendClass
   void (* settings_changed)   (ClutterBackend *backend);
 };
 
-ClutterBackend *        _clutter_create_backend                         (void);
-
 ClutterStageWindow *    _clutter_backend_create_stage                   (ClutterBackend         *backend,
                                                                          ClutterStage           *wrapper,
                                                                          GError                **error);
 gboolean                _clutter_backend_create_context                 (ClutterBackend         *backend,
                                                                          GError                **error);
 
-void                    _clutter_backend_add_options                    (ClutterBackend         *backend,
-                                                                         GOptionGroup           *group);
-gboolean                _clutter_backend_pre_parse                      (ClutterBackend         *backend,
-                                                                         GError                **error);
-gboolean                _clutter_backend_post_parse                     (ClutterBackend         *backend,
+gboolean                _clutter_backend_finish_init                    (ClutterBackend         *backend,
                                                                          GError                **error);
 
 CLUTTER_EXPORT
@@ -120,8 +109,6 @@ gboolean                _clutter_backend_translate_event                (Clutter
                                                                          gpointer                native,
                                                                          ClutterEvent           *event);
 
-ClutterFeatureFlags     _clutter_backend_get_features                   (ClutterBackend         *backend);
-
 gfloat                  _clutter_backend_get_units_per_em               (ClutterBackend         *backend,
                                                                          PangoFontDescription   *font_desc);
 gint32                  _clutter_backend_get_units_serial               (ClutterBackend         *backend);
diff --git a/clutter/clutter/clutter-backend.c b/clutter/clutter/clutter-backend.c
index 5799d5e23..a5f3b0264 100644
--- a/clutter/clutter/clutter-backend.c
+++ b/clutter/clutter/clutter-backend.c
@@ -353,8 +353,7 @@ clutter_backend_real_create_context (ClutterBackend  *backend,
       if (internal_error != NULL)
         g_propagate_error (error, internal_error);
       else
-        g_set_error_literal (error, CLUTTER_INIT_ERROR,
-                             CLUTTER_INIT_ERROR_BACKEND,
+        g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_FAILED,
                              "Unable to initialize the Clutter backend: no available drivers found.");
 
       return FALSE;
@@ -366,53 +365,6 @@ clutter_backend_real_create_context (ClutterBackend  *backend,
   return TRUE;
 }
 
-static ClutterFeatureFlags
-clutter_backend_real_get_features (ClutterBackend *backend)
-{
-  ClutterFeatureFlags flags = 0;
-
-  if (cogl_clutter_winsys_has_feature (COGL_WINSYS_FEATURE_MULTIPLE_ONSCREEN))
-    {
-      CLUTTER_NOTE (BACKEND, "Cogl supports multiple onscreen framebuffers");
-      flags |= CLUTTER_FEATURE_STAGE_MULTIPLE;
-    }
-  else
-    {
-      CLUTTER_NOTE (BACKEND, "Cogl only supports one onscreen framebuffer");
-      flags |= CLUTTER_FEATURE_STAGE_STATIC;
-    }
-
-  if (cogl_clutter_winsys_has_feature (COGL_WINSYS_FEATURE_SWAP_BUFFERS_EVENT))
-    {
-      CLUTTER_NOTE (BACKEND, "Cogl supports swap buffers complete events");
-      flags |= CLUTTER_FEATURE_SWAP_EVENTS;
-    }
-
-  return flags;
-}
-
-static ClutterBackend * (* custom_backend_func) (void);
-
-void
-clutter_set_custom_backend_func (ClutterBackend *(* func) (void))
-{
-  custom_backend_func = func;
-}
-
-ClutterBackend *
-_clutter_create_backend (void)
-{
-  ClutterBackend *retval;
-
-  g_return_val_if_fail (custom_backend_func, NULL);
-
-  retval = custom_backend_func ();
-  if (!retval)
-    g_error ("Failed to create custom backend.");
-
-  return retval;
-}
-
 static void
 clutter_backend_class_init (ClutterBackendClass *klass)
 {
@@ -475,7 +427,6 @@ clutter_backend_class_init (ClutterBackendClass *klass)
   klass->font_changed = clutter_backend_real_font_changed;
 
   klass->create_context = clutter_backend_real_create_context;
-  klass->get_features = clutter_backend_real_get_features;
 }
 
 static void
@@ -489,45 +440,17 @@ clutter_backend_init (ClutterBackend *self)
   self->fallback_resource_scale = 1.f;
 }
 
-void
-_clutter_backend_add_options (ClutterBackend *backend,
-                              GOptionGroup   *group)
-{
-  ClutterBackendClass *klass;
-
-  g_assert (CLUTTER_IS_BACKEND (backend));
-
-  klass = CLUTTER_BACKEND_GET_CLASS (backend);
-  if (klass->add_options)
-    klass->add_options (backend, group);
-}
-
 gboolean
-_clutter_backend_pre_parse (ClutterBackend  *backend,
-                            GError         **error)
+_clutter_backend_finish_init (ClutterBackend  *backend,
+                              GError         **error)
 {
   ClutterBackendClass *klass;
 
   g_assert (CLUTTER_IS_BACKEND (backend));
 
   klass = CLUTTER_BACKEND_GET_CLASS (backend);
-  if (klass->pre_parse)
-    return klass->pre_parse (backend, error);
-
-  return TRUE;
-}
-
-gboolean
-_clutter_backend_post_parse (ClutterBackend  *backend,
-                             GError         **error)
-{
-  ClutterBackendClass *klass;
-
-  g_assert (CLUTTER_IS_BACKEND (backend));
-
-  klass = CLUTTER_BACKEND_GET_CLASS (backend);
-  if (klass->post_parse)
-    return klass->post_parse (backend, error);
+  if (klass->finish_init)
+    return klass->finish_init (backend, error);
 
   return TRUE;
 }
@@ -572,46 +495,6 @@ _clutter_backend_create_context (ClutterBackend  *backend,
   return klass->create_context (backend, error);
 }
 
-ClutterFeatureFlags
-_clutter_backend_get_features (ClutterBackend *backend)
-{
-  ClutterBackendClass *klass;
-  GError *error;
-
-  g_assert (CLUTTER_IS_BACKEND (backend));
-
-  klass = CLUTTER_BACKEND_GET_CLASS (backend);
-
-  /* we need to have a context here; so we create the
-   * GL context first and the ask for features. if the
-   * context already exists this should be a no-op
-   */
-  error = NULL;
-  if (klass->create_context != NULL)
-    {
-      gboolean res;
-
-      res = klass->create_context (backend, &error);
-      if (!res)
-        {
-          if (error)
-            {
-              g_critical ("Unable to create a context: %s", error->message);
-              g_error_free (error);
-            }
-          else
-            g_critical ("Unable to create a context: unknown error");
-
-          return 0;
-        }
-    }
-
-  if (klass->get_features)
-    return klass->get_features (backend);
-  
-  return 0;
-}
-
 gfloat
 _clutter_backend_get_units_per_em (ClutterBackend       *backend,
                                    PangoFontDescription *font_desc)
diff --git a/clutter/clutter/clutter-click-action.c b/clutter/clutter/clutter-click-action.c
index 45d87e809..4e3fec9d1 100644
--- a/clutter/clutter/clutter-click-action.c
+++ b/clutter/clutter/clutter-click-action.c
@@ -105,8 +105,6 @@ struct _ClutterClickActionPrivate
 {
   ClutterActor *stage;
 
-  gulong event_id;
-  gulong capture_id;
   guint long_press_id;
 
   gint long_press_threshold;
@@ -150,11 +148,6 @@ static guint click_signals[LAST_SIGNAL] = { 0, };
 
 G_DEFINE_TYPE_WITH_PRIVATE (ClutterClickAction, clutter_click_action, CLUTTER_TYPE_ACTION)
 
-/* forward declaration */
-static gboolean on_captured_event (ClutterActor       *stage,
-                                   ClutterEvent       *event,
-                                   ClutterClickAction *action);
-
 static inline void
 click_action_set_pressed (ClutterClickAction *action,
                           gboolean            is_pressed)
@@ -205,8 +198,6 @@ click_action_emit_long_press (gpointer data)
                  CLUTTER_LONG_PRESS_ACTIVATE,
                  &result);
 
-  g_clear_signal_handler (&priv->capture_id, priv->stage);
-
   click_action_set_pressed (action, FALSE);
   click_action_set_held (action, FALSE);
 
@@ -274,7 +265,7 @@ click_action_cancel_long_press (ClutterClickAction *action)
 
 static inline gboolean
 event_within_drag_threshold (ClutterClickAction *click_action,
-                             ClutterEvent       *event)
+                             const ClutterEvent *event)
 {
   ClutterClickActionPrivate *priv =
     clutter_click_action_get_instance_private (click_action);
@@ -290,25 +281,33 @@ event_within_drag_threshold (ClutterClickAction *click_action,
 }
 
 static gboolean
-on_event (ClutterActor       *actor,
-          ClutterEvent       *event,
-          ClutterClickAction *action)
+clutter_click_action_handle_event (ClutterAction      *action,
+                                   const ClutterEvent *event)
 {
+  ClutterClickAction *click_action = CLUTTER_CLICK_ACTION (action);
   ClutterClickActionPrivate *priv =
-    clutter_click_action_get_instance_private (action);
+    clutter_click_action_get_instance_private (click_action);
+  ClutterActor *actor =
+    clutter_actor_meta_get_actor (CLUTTER_ACTOR_META (action));
   gboolean has_button = TRUE;
+  ClutterModifierType modifier_state;
 
   if (!clutter_actor_meta_get_enabled (CLUTTER_ACTOR_META (action)))
     return CLUTTER_EVENT_PROPAGATE;
 
+  if (priv->press_sequence != NULL &&
+      clutter_event_get_event_sequence (event) != priv->press_sequence)
+    {
+      click_action_set_held (click_action, FALSE);
+      click_action_cancel_long_press (click_action);
+      return CLUTTER_EVENT_PROPAGATE;
+    }
+
   switch (clutter_event_type (event))
     {
     case CLUTTER_TOUCH_BEGIN:
       has_button = FALSE;
     case CLUTTER_BUTTON_PRESS:
-      if (has_button && clutter_event_get_click_count (event) != 1)
-        return CLUTTER_EVENT_PROPAGATE;
-
       if (priv->is_held)
         return CLUTTER_EVENT_STOP;
 
@@ -335,48 +334,22 @@ on_event (ClutterActor       *actor,
       if (priv->stage == NULL)
         priv->stage = clutter_actor_get_stage (actor);
 
-      priv->capture_id = g_signal_connect_after (priv->stage, "captured-event",
-                                                 G_CALLBACK (on_captured_event),
-                                                 action);
-
-      click_action_set_pressed (action, TRUE);
-      click_action_set_held (action, TRUE);
-      click_action_query_long_press (action);
+      click_action_set_pressed (click_action, TRUE);
+      click_action_set_held (click_action, TRUE);
+      click_action_query_long_press (click_action);
       break;
 
     case CLUTTER_ENTER:
-      click_action_set_pressed (action, priv->is_held);
+      click_action_set_pressed (click_action, priv->is_held);
       break;
 
     case CLUTTER_LEAVE:
-      click_action_set_pressed (action, priv->is_held);
-      click_action_cancel_long_press (action);
+      click_action_set_pressed (click_action, priv->is_held);
+      click_action_cancel_long_press (click_action);
       break;
 
-    default:
-      break;
-    }
-
-  return CLUTTER_EVENT_PROPAGATE;
-}
-
-static gboolean
-on_captured_event (ClutterActor       *stage,
-                   ClutterEvent       *event,
-                   ClutterClickAction *action)
-{
-  ClutterClickActionPrivate *priv =
-    clutter_click_action_get_instance_private (action);
-  ClutterActor *actor;
-  ClutterModifierType modifier_state;
-  gboolean has_button = TRUE;
-
-  actor = clutter_actor_meta_get_actor (CLUTTER_ACTOR_META (action));
-
-  switch (clutter_event_type (event))
-    {
     case CLUTTER_TOUCH_CANCEL:
-      clutter_click_action_release (action);
+      clutter_click_action_release (click_action);
       break;
 
     case CLUTTER_TOUCH_END:
@@ -386,16 +359,12 @@ on_captured_event (ClutterActor       *stage,
         return CLUTTER_EVENT_STOP;
 
       if ((has_button && clutter_event_get_button (event) != priv->press_button) ||
-          (has_button && clutter_event_get_click_count (event) != 1) ||
           clutter_event_get_device (event) != priv->press_device ||
           clutter_event_get_event_sequence (event) != priv->press_sequence)
         return CLUTTER_EVENT_PROPAGATE;
 
-      click_action_set_held (action, FALSE);
-      click_action_cancel_long_press (action);
-
-      /* disconnect the capture */
-      g_clear_signal_handler (&priv->capture_id, priv->stage);
+      click_action_set_held (click_action, FALSE);
+      click_action_cancel_long_press (click_action);
 
       g_clear_handle_id (&priv->long_press_id, g_source_remove);
 
@@ -418,10 +387,10 @@ on_captured_event (ClutterActor       *stage,
       if (modifier_state != priv->modifier_state)
         priv->modifier_state = 0;
 
-      click_action_set_pressed (action, FALSE);
+      click_action_set_pressed (click_action, FALSE);
 
-      if (event_within_drag_threshold (action, event))
-        g_signal_emit (action, click_signals[CLICKED], 0, actor);
+      if (event_within_drag_threshold (click_action, event))
+        g_signal_emit (click_action, click_signals[CLICKED], 0, actor);
       break;
 
     case CLUTTER_MOTION:
@@ -434,8 +403,8 @@ on_captured_event (ClutterActor       *stage,
         if (!priv->is_held)
           return CLUTTER_EVENT_PROPAGATE;
 
-        if (!event_within_drag_threshold (action, event))
-          clutter_click_action_release (action);
+        if (!event_within_drag_threshold (click_action, event))
+          clutter_click_action_release (click_action);
       }
       break;
 
@@ -443,7 +412,7 @@ on_captured_event (ClutterActor       *stage,
       break;
     }
 
-  return CLUTTER_EVENT_STOP;
+  return priv->is_held ? CLUTTER_EVENT_STOP : CLUTTER_EVENT_PROPAGATE;
 }
 
 static void
@@ -454,35 +423,11 @@ clutter_click_action_set_actor (ClutterActorMeta *meta,
   ClutterClickActionPrivate *priv =
     clutter_click_action_get_instance_private (action);
 
-  if (priv->event_id != 0)
-    {
-      ClutterActor *old_actor = clutter_actor_meta_get_actor (meta);
-
-      if (old_actor != NULL)
-        g_clear_signal_handler (&priv->event_id, old_actor);
-
-      priv->event_id = 0;
-    }
-
-  if (priv->capture_id != 0)
-    {
-      if (priv->stage != NULL)
-        g_clear_signal_handler (&priv->capture_id, priv->stage);
-
-      priv->capture_id = 0;
-      priv->stage = NULL;
-    }
-
   g_clear_handle_id (&priv->long_press_id, g_source_remove);
 
   click_action_set_pressed (action, FALSE);
   click_action_set_held (action, FALSE);
 
-  if (actor != NULL)
-    priv->event_id = g_signal_connect (actor, "event",
-                                       G_CALLBACK (on_event),
-                                       action);
-
   CLUTTER_ACTOR_META_CLASS (clutter_click_action_parent_class)->set_actor (meta, actor);
 }
 
@@ -564,22 +509,19 @@ clutter_click_action_dispose (GObject *gobject)
   ClutterClickActionPrivate *priv =
     clutter_click_action_get_instance_private (CLUTTER_CLICK_ACTION (gobject));
 
-  g_clear_signal_handler (&priv->event_id,
-                          clutter_actor_meta_get_actor (CLUTTER_ACTOR_META (gobject)));
-
-  g_clear_signal_handler (&priv->capture_id, priv->stage);
-
   g_clear_handle_id (&priv->long_press_id, g_source_remove);
 
   G_OBJECT_CLASS (clutter_click_action_parent_class)->dispose (gobject);
 }
 
-
 static void
 clutter_click_action_class_init (ClutterClickActionClass *klass)
 {
   GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
   ClutterActorMetaClass *meta_class = CLUTTER_ACTOR_META_CLASS (klass);
+  ClutterActionClass *action_class = CLUTTER_ACTION_CLASS (klass);
+
+  action_class->handle_event = clutter_click_action_handle_event;
 
   meta_class->set_actor = clutter_click_action_set_actor;
   meta_class->set_enabled = clutter_click_action_set_enabled;
@@ -769,9 +711,6 @@ clutter_click_action_release (ClutterClickAction *action)
   if (!priv->is_held)
     return;
 
-  /* disconnect the capture */
-  g_clear_signal_handler (&priv->capture_id, priv->stage);
-
   click_action_cancel_long_press (action);
   click_action_set_held (action, FALSE);
   click_action_set_pressed (action, FALSE);
diff --git a/clutter/clutter/clutter-container.c b/clutter/clutter/clutter-container.c
index 23169332f..7d129fcfb 100644
--- a/clutter/clutter/clutter-container.c
+++ b/clutter/clutter/clutter-container.c
@@ -119,31 +119,6 @@ container_real_remove (ClutterContainer *container,
   clutter_actor_remove_child (CLUTTER_ACTOR (container), actor);
 }
 
-static void
-container_real_raise (ClutterContainer *container,
-                      ClutterActor     *child,
-                      ClutterActor     *sibling)
-{
-  ClutterActor *self = CLUTTER_ACTOR (container);
-
-  clutter_actor_set_child_above_sibling (self, child, sibling);
-}
-
-static void
-container_real_lower (ClutterContainer *container,
-                      ClutterActor     *child,
-                      ClutterActor     *sibling)
-{
-  ClutterActor *self = CLUTTER_ACTOR (container);
-
-  clutter_actor_set_child_below_sibling (self, child, sibling);
-}
-
-static void
-container_real_sort_depth_order (ClutterContainer *container)
-{
-}
-
 static void
 clutter_container_default_init (ClutterContainerInterface *iface)
 {
@@ -213,9 +188,6 @@ clutter_container_default_init (ClutterContainerInterface *iface)
 
   iface->add = container_real_add;
   iface->remove = container_real_remove;
-  iface->raise = container_real_raise;
-  iface->lower = container_real_lower;
-  iface->sort_depth_order = container_real_sort_depth_order;
 
   iface->child_meta_type = G_TYPE_INVALID;
   iface->create_child_meta = create_child_meta;
@@ -448,202 +420,6 @@ clutter_container_remove_actor (ClutterContainer *container,
   container_remove_actor (container, actor);
 }
 
-/**
- * clutter_container_get_children:
- * @container: a #ClutterContainer
- *
- * Retrieves all the children of @container.
- *
- * Return value: (element-type Clutter.Actor) (transfer container): a list
- *   of #ClutterActor<!-- -->s. Use g_list_free() on the returned
- *   list when done.
- *
- * Since: 0.4
- *
- * Deprecated: 1.10: Use clutter_actor_get_children() instead.
- */
-GList *
-clutter_container_get_children (ClutterContainer *container)
-{
-  g_return_val_if_fail (CLUTTER_IS_CONTAINER (container), NULL);
-
-  return clutter_actor_get_children (CLUTTER_ACTOR (container));
-}
-
-/**
- * clutter_container_raise_child: (virtual raise)
- * @container: a #ClutterContainer
- * @actor: the actor to raise
- * @sibling: (allow-none): the sibling to raise to, or %NULL to raise
- *   to the top
- *
- * Raises @actor to @sibling level, in the depth ordering.
- *
- * This function calls the #ClutterContainerIface.raise() virtual function,
- * which has been deprecated. The default implementation will call
- * clutter_actor_set_child_above_sibling().
- *
- * Since: 0.6
- *
- * Deprecated: 1.10: Use clutter_actor_set_child_above_sibling() instead.
- */
-void
-clutter_container_raise_child (ClutterContainer *container,
-                               ClutterActor     *actor,
-                               ClutterActor     *sibling)
-{
-  ClutterContainerIface *iface;
-  ClutterActor *self;
-
-  g_return_if_fail (CLUTTER_IS_CONTAINER (container));
-  g_return_if_fail (CLUTTER_IS_ACTOR (actor));
-  g_return_if_fail (sibling == NULL || CLUTTER_IS_ACTOR (sibling));
-
-  if (actor == sibling)
-    return;
-
-  self = CLUTTER_ACTOR (container);
-
-  if (clutter_actor_get_parent (actor) != self)
-    {
-      g_warning ("Actor of type '%s' is not a child of the container "
-                 "of type '%s'",
-                 g_type_name (G_OBJECT_TYPE (actor)),
-                 g_type_name (G_OBJECT_TYPE (container)));
-      return;
-    }
-
-  if (sibling != NULL &&
-      clutter_actor_get_parent (sibling) != self)
-    {
-      g_warning ("Actor of type '%s' is not a child of the container "
-                 "of type '%s'",
-                 g_type_name (G_OBJECT_TYPE (sibling)),
-                 g_type_name (G_OBJECT_TYPE (container)));
-      return;
-    }
-
-  iface = CLUTTER_CONTAINER_GET_IFACE (container);
-
-#ifdef CLUTTER_ENABLE_DEBUG
-  if (G_UNLIKELY (_clutter_diagnostic_enabled ()))
-    {
-      if (iface->raise != container_real_raise)
-        _clutter_diagnostic_message ("The ClutterContainer::raise() "
-                                     "virtual function has been deprecated "
-                                     "and it should not be overridden by "
-                                     "newly written code");
-    }
-#endif /* CLUTTER_ENABLE_DEBUG */
-
-  iface->raise (container, actor, sibling);
-}
-
-/**
- * clutter_container_lower_child: (virtual lower)
- * @container: a #ClutterContainer
- * @actor: the actor to raise
- * @sibling: (allow-none): the sibling to lower to, or %NULL to lower
- *   to the bottom
- *
- * Lowers @actor to @sibling level, in the depth ordering.
- *
- * This function calls the #ClutterContainerIface.lower() virtual function,
- * which has been deprecated. The default implementation will call
- * clutter_actor_set_child_below_sibling().
- *
- * Since: 0.6
- *
- * Deprecated: 1.10: Use clutter_actor_set_child_below_sibling() instead.
- */
-void
-clutter_container_lower_child (ClutterContainer *container,
-                               ClutterActor     *actor,
-                               ClutterActor     *sibling)
-{
-  ClutterContainerIface *iface;
-  ClutterActor *self;
-
-  g_return_if_fail (CLUTTER_IS_CONTAINER (container));
-  g_return_if_fail (CLUTTER_IS_ACTOR (actor));
-  g_return_if_fail (sibling == NULL || CLUTTER_IS_ACTOR (sibling));
-
-  if (actor == sibling)
-    return;
-
-  self = CLUTTER_ACTOR (container);
-
-  if (clutter_actor_get_parent (actor) != self)
-    {
-      g_warning ("Actor of type '%s' is not a child of the container "
-                 "of type '%s'",
-                 g_type_name (G_OBJECT_TYPE (actor)),
-                 g_type_name (G_OBJECT_TYPE (container)));
-      return;
-    }
-
-  if (sibling != NULL&&
-      clutter_actor_get_parent (sibling) != self)
-    {
-      g_warning ("Actor of type '%s' is not a child of the container "
-                 "of type '%s'",
-                 g_type_name (G_OBJECT_TYPE (sibling)),
-                 g_type_name (G_OBJECT_TYPE (container)));
-      return;
-    }
-
-  iface = CLUTTER_CONTAINER_GET_IFACE (container);
-
-#ifdef CLUTTER_ENABLE_DEBUG
-  if (G_UNLIKELY (_clutter_diagnostic_enabled ()))
-    {
-      if (iface->lower != container_real_lower)
-        _clutter_diagnostic_message ("The ClutterContainer::lower() "
-                                     "virtual function has been deprecated "
-                                     "and it should not be overridden by "
-                                     "newly written code");
-    }
-#endif /* CLUTTER_ENABLE_DEBUG */
-
-  iface->lower (container, actor, sibling);
-}
-
-/**
- * clutter_container_sort_depth_order:
- * @container: a #ClutterContainer
- *
- * Sorts a container's children using their depth. This function should not
- * be normally used by applications.
- *
- * Since: 0.6
- *
- * Deprecated: 1.10: The #ClutterContainerIface.sort_depth_order() virtual
- *   function should not be used any more; the default implementation in
- *   #ClutterContainer does not do anything.
- */
-void
-clutter_container_sort_depth_order (ClutterContainer *container)
-{
-  ClutterContainerIface *iface;
-
-  g_return_if_fail (CLUTTER_IS_CONTAINER (container));
-
-  iface = CLUTTER_CONTAINER_GET_IFACE (container);
-
-#ifdef CLUTTER_ENABLE_DEBUG
-  if (G_UNLIKELY (_clutter_diagnostic_enabled ()))
-    {
-      if (iface->sort_depth_order != container_real_sort_depth_order)
-        _clutter_diagnostic_message ("The ClutterContainer::sort_depth_order() "
-                                     "virtual function has been deprecated "
-                                     "and it should not be overridden by "
-                                     "newly written code");
-    }
-#endif /* CLUTTER_ENABLE_DEBUG */
-
-  iface->sort_depth_order (container);
-}
-
 /**
  * clutter_container_find_child_by_name:
  * @container: a #ClutterContainer
@@ -668,7 +444,7 @@ clutter_container_find_child_by_name (ClutterContainer *container,
   g_return_val_if_fail (CLUTTER_IS_CONTAINER (container), NULL);
   g_return_val_if_fail (child_name != NULL, NULL);
 
-  children = clutter_container_get_children (container);
+  children = clutter_actor_get_children (CLUTTER_ACTOR (container));
 
   for (iter = children; iter; iter = g_list_next (iter))
     {
diff --git a/clutter/clutter/clutter-container.h b/clutter/clutter/clutter-container.h
index 6575569db..cf263fe5e 100644
--- a/clutter/clutter/clutter-container.h
+++ b/clutter/clutter/clutter-container.h
@@ -59,13 +59,6 @@ typedef struct _ClutterContainerIface   ClutterContainerIface;
  *   function is deprecated, and it should not be overridden.
  * @remove: virtual function for removing an actor from the container. This
  *   virtual function is deprecated, and it should not be overridden.
- * @raise: virtual function for raising a child. This virtual function is
- *   deprecated and it should not be overridden.
- * @lower: virtual function for lowering a child. This virtual function is
- *   deprecated and it should not be overridden.
- * @sort_depth_order: virtual function for sorting the children of a
- *   container depending on their depth. This virtual function is deprecated
- *   and it should not be overridden.
  * @child_meta_type: The GType used for storing auxiliary information about
  *   each of the containers children.
  * @create_child_meta: virtual function that gets called for each added
@@ -97,15 +90,6 @@ struct _ClutterContainerIface
   void (* remove)           (ClutterContainer *container,
                              ClutterActor     *actor);
 
-  /* child stacking */
-  void (* raise)            (ClutterContainer *container,
-                             ClutterActor     *actor,
-                             ClutterActor     *sibling);
-  void (* lower)            (ClutterContainer *container,
-                             ClutterActor     *actor,
-                             ClutterActor     *sibling);
-  void (* sort_depth_order) (ClutterContainer *container);
-
   /* ClutterChildMeta management */
   GType                child_meta_type;
   void              (* create_child_meta)  (ClutterContainer *container,
diff --git a/clutter/clutter/clutter-content.c b/clutter/clutter/clutter-content.c
index 31abd1135..92f485d74 100644
--- a/clutter/clutter/clutter-content.c
+++ b/clutter/clutter/clutter-content.c
@@ -322,8 +322,8 @@ _clutter_content_paint_content (ClutterContent      *content,
 /**
  * clutter_content_get_preferred_size:
  * @content: a #ClutterContent
- * @width: (out): return location for the natural width of the content
- * @height: (out): return location for the natural height of the content
+ * @width: (out) (optional): return location for the natural width of the content
+ * @height: (out) (optional): return location for the natural height of the content
  *
  * Retrieves the natural size of the @content, if any.
  *
diff --git a/clutter/clutter/clutter-enums.h b/clutter/clutter/clutter-enums.h
index 54344248f..8165bcf5d 100644
--- a/clutter/clutter/clutter-enums.h
+++ b/clutter/clutter/clutter-enums.h
@@ -829,6 +829,11 @@ typedef enum /*< flags prefix=CLUTTER_EVENT >*/
  *   determined by its phase field; event added in 1.24
  * @CLUTTER_TOUCHPAD_SWIPE: A swipe gesture event, the current state is
  *   determined by its phase field; event added in 1.24
+ * @CLUTTER_TOUCHPAD_HOLD: A hold gesture event, the current state is
+ *   determined by its phase field. A hold gesture starts when the user places a
+ *   finger on the touchpad and ends when all fingers are lifted. It is
+ *   cancelled when the finger(s) move past a certain threshold.
+ *   Event added in 40.4
  * @CLUTTER_PROXIMITY_IN: A tool entered in proximity to a tablet;
  *   event added in 1.28
  * @CLUTTER_PROXIMITY_OUT: A tool left from the proximity area of a tablet;
@@ -857,6 +862,7 @@ typedef enum /*< prefix=CLUTTER >*/
   CLUTTER_TOUCH_CANCEL,
   CLUTTER_TOUCHPAD_PINCH,
   CLUTTER_TOUCHPAD_SWIPE,
+  CLUTTER_TOUCHPAD_HOLD,
   CLUTTER_PROXIMITY_IN,
   CLUTTER_PROXIMITY_OUT,
   CLUTTER_PAD_BUTTON_PRESS,
@@ -898,12 +904,7 @@ typedef enum /*< prefix=CLUTTER_SCROLL >*/
 
 /**
  * ClutterFeatureFlags:
- * @CLUTTER_FEATURE_STAGE_STATIC: Set if stage size if fixed (i.e framebuffer)
- * @CLUTTER_FEATURE_STAGE_CURSOR: Set if stage has a graphical cursor.
  * @CLUTTER_FEATURE_SHADERS_GLSL: Set if the backend supports GLSL shaders.
- * @CLUTTER_FEATURE_OFFSCREEN: Set if the backend supports offscreen rendering.
- * @CLUTTER_FEATURE_STAGE_MULTIPLE: Set if multiple stages are supported.
- * @CLUTTER_FEATURE_SWAP_EVENTS: Set if the GLX_INTEL_swap_event is supported.
  *
  * Runtime flags indicating specific features available via Clutter window
  * system and graphics backend.
@@ -912,12 +913,7 @@ typedef enum /*< prefix=CLUTTER_SCROLL >*/
  */
 typedef enum
 {
-  CLUTTER_FEATURE_STAGE_STATIC           = (1 << 6),
-  CLUTTER_FEATURE_STAGE_CURSOR           = (1 << 8),
   CLUTTER_FEATURE_SHADERS_GLSL           = (1 << 9),
-  CLUTTER_FEATURE_OFFSCREEN              = (1 << 10),
-  CLUTTER_FEATURE_STAGE_MULTIPLE         = (1 << 11),
-  CLUTTER_FEATURE_SWAP_EVENTS            = (1 << 12)
 } ClutterFeatureFlags;
 
 /**
@@ -1439,24 +1435,6 @@ typedef enum
   CLUTTER_STEP_MODE_END
 } ClutterStepMode;
 
-/**
- * ClutterZoomAxis:
- * @CLUTTER_ZOOM_X_AXIS: Scale only on the X axis
- * @CLUTTER_ZOOM_Y_AXIS: Scale only on the Y axis
- * @CLUTTER_ZOOM_BOTH: Scale on both axis
- *
- * The axis of the constraint that should be applied by the
- * zooming action.
- *
- * Since: 1.12
- */
-typedef enum /*< prefix=CLUTTER_ZOOM >*/
-{
-  CLUTTER_ZOOM_X_AXIS,
-  CLUTTER_ZOOM_Y_AXIS,
-  CLUTTER_ZOOM_BOTH
-} ClutterZoomAxis;
-
 /**
  * ClutterGestureTriggerEdge:
  * @CLUTTER_GESTURE_TRIGGER_EDGE_NONE: Tell #ClutterGestureAction that
@@ -1644,6 +1622,12 @@ typedef enum
   CLUTTER_PREEDIT_RESET_COMMIT,
 } ClutterPreeditResetMode;
 
+typedef enum
+{
+  CLUTTER_PHASE_CAPTURE,
+  CLUTTER_PHASE_BUBBLE,
+} ClutterEventPhase;
+
 G_END_DECLS
 
 #endif /* __CLUTTER_ENUMS_H__ */
diff --git a/clutter/clutter/clutter-event.c b/clutter/clutter/clutter-event.c
index 8cfa983a4..05cd7ba49 100644
--- a/clutter/clutter/clutter-event.c
+++ b/clutter/clutter/clutter-event.c
@@ -433,6 +433,11 @@ clutter_event_get_position (const ClutterEvent *event,
       graphene_point_init (position, event->touchpad_swipe.x,
                            event->touchpad_swipe.y);
       break;
+
+    case CLUTTER_TOUCHPAD_HOLD:
+      graphene_point_init (position, event->touchpad_hold.x,
+                           event->touchpad_hold.y);
+      break;
     }
 
 }
@@ -512,6 +517,11 @@ clutter_event_set_coords (ClutterEvent *event,
       event->touchpad_swipe.x = x;
       event->touchpad_swipe.y = y;
       break;
+
+    case CLUTTER_TOUCHPAD_HOLD:
+      event->touchpad_hold.x = x;
+      event->touchpad_hold.y = y;
+      break;
     }
 }
 
@@ -823,27 +833,6 @@ clutter_event_set_button (ClutterEvent *event,
   event->button.button = button;
 }
 
-/**
- * clutter_event_get_click_count:
- * @event: a #ClutterEvent of type %CLUTTER_BUTTON_PRESS or
- *   of type %CLUTTER_BUTTON_RELEASE
- *
- * Retrieves the number of clicks of @event
- *
- * Return value: the click count
- *
- * Since: 1.0
- */
-guint32
-clutter_event_get_click_count (const ClutterEvent *event)
-{
-  g_return_val_if_fail (event != NULL, 0);
-  g_return_val_if_fail (event->type == CLUTTER_BUTTON_PRESS ||
-                        event->type == CLUTTER_BUTTON_RELEASE, 0);
-
-  return event->button.click_count;
-}
-
 /* keys */
 
 /**
@@ -1088,6 +1077,7 @@ clutter_event_set_device (ClutterEvent       *event,
 
     case CLUTTER_TOUCHPAD_PINCH:
     case CLUTTER_TOUCHPAD_SWIPE:
+    case CLUTTER_TOUCHPAD_HOLD:
       /* Rely on priv data for these */
       break;
 
@@ -1185,6 +1175,7 @@ clutter_event_get_device (const ClutterEvent *event)
 
     case CLUTTER_TOUCHPAD_PINCH:
     case CLUTTER_TOUCHPAD_SWIPE:
+    case CLUTTER_TOUCHPAD_HOLD:
       /* Rely on priv data for these */
       break;
 
@@ -1649,6 +1640,7 @@ clutter_event_get_axes (const ClutterEvent *event,
 
     case CLUTTER_TOUCHPAD_PINCH:
     case CLUTTER_TOUCHPAD_SWIPE:
+    case CLUTTER_TOUCHPAD_HOLD:
     case CLUTTER_PAD_BUTTON_PRESS:
     case CLUTTER_PAD_BUTTON_RELEASE:
     case CLUTTER_PAD_STRIP:
@@ -1894,12 +1886,15 @@ clutter_event_get_touchpad_gesture_finger_count (const ClutterEvent *event)
 {
   g_return_val_if_fail (event != NULL, 0);
   g_return_val_if_fail (event->type == CLUTTER_TOUCHPAD_SWIPE ||
-                        event->type == CLUTTER_TOUCHPAD_PINCH, 0);
+                        event->type == CLUTTER_TOUCHPAD_PINCH ||
+                        event->type == CLUTTER_TOUCHPAD_HOLD, 0);
 
   if (event->type == CLUTTER_TOUCHPAD_SWIPE)
     return event->touchpad_swipe.n_fingers;
   else if (event->type == CLUTTER_TOUCHPAD_PINCH)
     return event->touchpad_pinch.n_fingers;
+  else if (event->type == CLUTTER_TOUCHPAD_HOLD)
+    return event->touchpad_hold.n_fingers;
 
   return 0;
 }
@@ -1958,12 +1953,15 @@ clutter_event_get_gesture_phase (const ClutterEvent *event)
 {
   g_return_val_if_fail (event != NULL, 0);
   g_return_val_if_fail (event->type == CLUTTER_TOUCHPAD_PINCH ||
-                        event->type == CLUTTER_TOUCHPAD_SWIPE, 0);
+                        event->type == CLUTTER_TOUCHPAD_SWIPE ||
+                        event->type == CLUTTER_TOUCHPAD_HOLD, 0);
 
   if (event->type == CLUTTER_TOUCHPAD_PINCH)
     return event->touchpad_pinch.phase;
   else if (event->type == CLUTTER_TOUCHPAD_SWIPE)
     return event->touchpad_swipe.phase;
+  else if (event->type == CLUTTER_TOUCHPAD_HOLD)
+    return event->touchpad_hold.phase;
 
   /* Shouldn't ever happen */
   return CLUTTER_TOUCHPAD_GESTURE_PHASE_BEGIN;
@@ -1989,7 +1987,8 @@ clutter_event_get_gesture_motion_delta (const ClutterEvent *event,
 {
   g_return_if_fail (event != NULL);
   g_return_if_fail (event->type == CLUTTER_TOUCHPAD_PINCH ||
-                    event->type == CLUTTER_TOUCHPAD_SWIPE);
+                    event->type == CLUTTER_TOUCHPAD_SWIPE ||
+                    event->type == CLUTTER_TOUCHPAD_HOLD);
 
   if (event->type == CLUTTER_TOUCHPAD_PINCH)
     {
@@ -2005,6 +2004,13 @@ clutter_event_get_gesture_motion_delta (const ClutterEvent *event,
       if (dy)
         *dy = event->touchpad_swipe.dy;
     }
+  else if (event->type == CLUTTER_TOUCHPAD_HOLD)
+    {
+      if (dx)
+        *dx = 0;
+      if (dy)
+        *dy = 0;
+    }
 }
 
 /**
@@ -2026,7 +2032,8 @@ clutter_event_get_gesture_motion_delta_unaccelerated (const ClutterEvent *event,
 {
   g_return_if_fail (event != NULL);
   g_return_if_fail (event->type == CLUTTER_TOUCHPAD_PINCH ||
-                    event->type == CLUTTER_TOUCHPAD_SWIPE);
+                    event->type == CLUTTER_TOUCHPAD_SWIPE ||
+                    event->type == CLUTTER_TOUCHPAD_HOLD);
 
   if (event->type == CLUTTER_TOUCHPAD_PINCH)
     {
@@ -2042,6 +2049,13 @@ clutter_event_get_gesture_motion_delta_unaccelerated (const ClutterEvent *event,
       if (dy)
         *dy = event->touchpad_swipe.dy_unaccel;
     }
+  else if (event->type == CLUTTER_TOUCHPAD_HOLD)
+    {
+      if (dx)
+        *dx = 0;
+      if (dy)
+        *dy = 0;
+    }
 }
 /**
  * clutter_event_get_scroll_source:
diff --git a/clutter/clutter/clutter-event.h b/clutter/clutter/clutter-event.h
index a14b2eca3..1378d91e0 100644
--- a/clutter/clutter/clutter-event.h
+++ b/clutter/clutter/clutter-event.h
@@ -116,6 +116,7 @@ typedef struct _ClutterCrossingEvent    ClutterCrossingEvent;
 typedef struct _ClutterTouchEvent       ClutterTouchEvent;
 typedef struct _ClutterTouchpadPinchEvent ClutterTouchpadPinchEvent;
 typedef struct _ClutterTouchpadSwipeEvent ClutterTouchpadSwipeEvent;
+typedef struct _ClutterTouchpadHoldEvent ClutterTouchpadHoldEvent;
 typedef struct _ClutterProximityEvent   ClutterProximityEvent;
 typedef struct _ClutterPadButtonEvent   ClutterPadButtonEvent;
 typedef struct _ClutterPadStripEvent    ClutterPadStripEvent;
@@ -188,8 +189,6 @@ struct _ClutterKeyEvent
  * @y: event Y coordinate, relative to the stage
  * @modifier_state: button modifiers
  * @button: event button
- * @click_count: number of button presses within the default time
- *   and radius
  * @axes: reserved for future use
  * @device: the device that originated the event. If you want the physical
  * device the event originated from, use clutter_event_get_source_device()
@@ -214,7 +213,6 @@ struct _ClutterButtonEvent
   gfloat y;
   ClutterModifierType modifier_state;
   guint32 button;
-  guint click_count;
   gdouble *axes; /* Future use */
   ClutterInputDevice *device;
   uint32_t evdev_code;
@@ -493,6 +491,42 @@ struct _ClutterTouchpadSwipeEvent
   gfloat dy_unaccel;
 };
 
+/**
+ * ClutterTouchpadHoldEvent
+ * @type: event type
+ * @time: event time
+ * @flags: event flags
+ * @stage: event source stage
+ * @source: event source actor (unused)
+ * @phase: the current phase of the gesture
+ * @n_fingers: the number of fingers triggering the swipe
+ * @x: the X coordinate of the pointer, relative to the stage
+ * @y: the Y coordinate of the pointer, relative to the stage
+ *
+ * Used for touchpad hold gesture events. The current state of the
+ * gesture will be determined by the @phase field.
+ *
+ * A hold gesture starts when the user places one or many fingers on the
+ * touchpad and ends when all fingers are lifted. It is cancelled when the
+ * finger(s) move past a certain threshold.
+ * Unlike swipe and pinch, @phase can only be
+ * CLUTTER_TOUCHPAD_GESTURE_PHASE_BEGIN, CLUTTER_TOUCHPAD_GESTURE_PHASE_END and
+ * CLUTTER_TOUCHPAD_GESTURE_PHASE_CANCEL.
+ */
+struct _ClutterTouchpadHoldEvent
+{
+  ClutterEventType type;
+  guint32 time;
+  ClutterEventFlags flags;
+  ClutterStage *stage;
+  ClutterActor *source;
+
+  ClutterTouchpadGesturePhase phase;
+  uint32_t n_fingers;
+  float x;
+  float y;
+};
+
 struct _ClutterPadButtonEvent
 {
   ClutterEventType type;
@@ -585,6 +619,7 @@ union _ClutterEvent
   ClutterTouchEvent touch;
   ClutterTouchpadPinchEvent touchpad_pinch;
   ClutterTouchpadSwipeEvent touchpad_swipe;
+  ClutterTouchpadHoldEvent touchpad_hold;
   ClutterProximityEvent proximity;
   ClutterPadButtonEvent pad_button;
   ClutterPadStripEvent pad_strip;
@@ -740,8 +775,6 @@ void                    clutter_event_set_button                (ClutterEvent
 CLUTTER_EXPORT
 guint32                 clutter_event_get_button                (const ClutterEvent     *event);
 CLUTTER_EXPORT
-guint                   clutter_event_get_click_count           (const ClutterEvent     *event);
-CLUTTER_EXPORT
 void                    clutter_event_set_related               (ClutterEvent           *event,
                                                                  ClutterActor           *actor);
 CLUTTER_EXPORT
diff --git a/clutter/clutter/clutter-feature.c b/clutter/clutter/clutter-feature.c
index 663d1c089..8d216529d 100644
--- a/clutter/clutter/clutter-feature.c
+++ b/clutter/clutter/clutter-feature.c
@@ -64,16 +64,13 @@ clutter_features_from_cogl (void)
   
   clutter_flags |= CLUTTER_FEATURE_SHADERS_GLSL;
   
-  clutter_flags |= CLUTTER_FEATURE_OFFSCREEN;
-  
   return clutter_flags;
 }
 
 gboolean
-_clutter_feature_init (GError **error)
+clutter_feature_init (ClutterMainContext  *context,
+                      GError             **error)
 {
-  ClutterMainContext *context;
-
   CLUTTER_NOTE (MISC, "checking features");
 
   if (!__features)
@@ -86,14 +83,11 @@ _clutter_feature_init (GError **error)
   if (__features->features_set)
     return TRUE;
 
-  context = _clutter_context_get_default ();
-
   /* makes sure we have a GL context; if we have, this is a no-op */
   if (!_clutter_backend_create_context (context->backend, error))
     return FALSE;
 
-  __features->flags = (clutter_features_from_cogl ()
-                    | _clutter_backend_get_features (context->backend));
+  __features->flags = clutter_features_from_cogl ();
 
   __features->features_set = TRUE;
 
diff --git a/clutter/clutter/clutter-frame-clock.c b/clutter/clutter/clutter-frame-clock.c
index 16098b70f..a1687415a 100644
--- a/clutter/clutter/clutter-frame-clock.c
+++ b/clutter/clutter/clutter-frame-clock.c
@@ -45,10 +45,7 @@ typedef struct _EstimateQueue
   int next_index;
 } EstimateQueue;
 
-/* When heuristic render time is off,
- * wait 2ms after vblank before starting to draw next frame.
- */
-#define SYNC_DELAY_FALLBACK_US ms2us (2)
+#define SYNC_DELAY_FALLBACK_FRACTION 0.875
 
 typedef struct _ClutterFrameListener
 {
@@ -314,13 +311,12 @@ clutter_frame_clock_compute_max_render_time_us (ClutterFrameClock *frame_clock)
   int64_t max_render_time_us;
   int i;
 
-  refresh_interval_us =
-    (int64_t) (0.5 + G_USEC_PER_SEC / frame_clock->refresh_rate);
+  refresh_interval_us = frame_clock->refresh_interval_us;
 
   if (!frame_clock->got_measurements_last_frame ||
       G_UNLIKELY (clutter_paint_debug_flags &
                   CLUTTER_DEBUG_DISABLE_DYNAMIC_MAX_RENDER_TIME))
-    return refresh_interval_us - SYNC_DELAY_FALLBACK_US;
+    return refresh_interval_us * SYNC_DELAY_FALLBACK_FRACTION;
 
   for (i = 0; i < ESTIMATE_QUEUE_LENGTH; ++i)
     {
@@ -646,13 +642,14 @@ clutter_frame_clock_dispatch (ClutterFrameClock *frame_clock,
   COGL_TRACE_END (ClutterFrameClockEvents);
 
   COGL_TRACE_BEGIN (ClutterFrameClockTimelines, "Frame Clock (timelines)");
+  if (frame_clock->is_next_presentation_time_valid)
+    time_us = frame_clock->next_presentation_time_us;
   advance_timelines (frame_clock, time_us);
   COGL_TRACE_END (ClutterFrameClockTimelines);
 
   COGL_TRACE_BEGIN (ClutterFrameClockFrame, "Frame Clock (frame)");
   result = frame_clock->listener.iface->frame (frame_clock,
                                                frame_count,
-                                               time_us,
                                                frame_clock->listener.user_data);
   COGL_TRACE_END (ClutterFrameClockFrame);
 
diff --git a/clutter/clutter/clutter-frame-clock.h b/clutter/clutter/clutter-frame-clock.h
index e71b54987..91e6b3a13 100644
--- a/clutter/clutter/clutter-frame-clock.h
+++ b/clutter/clutter/clutter-frame-clock.h
@@ -50,7 +50,6 @@ typedef struct _ClutterFrameListenerIface
                          gpointer           user_data);
   ClutterFrameResult (* frame) (ClutterFrameClock *frame_clock,
                                 int64_t            frame_count,
-                                int64_t            time_us,
                                 gpointer           user_data);
 } ClutterFrameListenerIface;
 
diff --git a/clutter/clutter/clutter-gesture-action.c b/clutter/clutter/clutter-gesture-action.c
index f938a549a..a4f2de792 100644
--- a/clutter/clutter/clutter-gesture-action.c
+++ b/clutter/clutter/clutter-gesture-action.c
@@ -118,9 +118,6 @@ struct _ClutterGestureActionPrivate
   gint requested_nb_points;
   GArray *points;
 
-  gulong actor_capture_id;
-  gulong stage_capture_id;
-
   ClutterGestureTriggerEdge edge;
   float distance_x, distance_y;
 
@@ -155,7 +152,8 @@ static guint gesture_signals[LAST_SIGNAL] = { 0, };
 G_DEFINE_TYPE_WITH_PRIVATE (ClutterGestureAction, clutter_gesture_action, CLUTTER_TYPE_ACTION)
 
 static GesturePoint *
-gesture_register_point (ClutterGestureAction *action, ClutterEvent *event)
+gesture_register_point (ClutterGestureAction *action,
+                        const ClutterEvent   *event)
 {
   ClutterGestureActionPrivate *priv =
     clutter_gesture_action_get_instance_private (action);
@@ -188,8 +186,8 @@ gesture_register_point (ClutterGestureAction *action, ClutterEvent *event)
 
 static GesturePoint *
 gesture_find_point (ClutterGestureAction *action,
-                    ClutterEvent *event,
-                    gint *position)
+                    const ClutterEvent   *event,
+                    int                  *position)
 {
   ClutterGestureActionPrivate *priv =
     clutter_gesture_action_get_instance_private (action);
@@ -232,8 +230,8 @@ gesture_unregister_point (ClutterGestureAction *action, gint position)
 }
 
 static void
-gesture_update_motion_point (GesturePoint *point,
-                             ClutterEvent *event)
+gesture_update_motion_point (GesturePoint       *point,
+                             const ClutterEvent *event)
 {
   gfloat motion_x, motion_y;
   gint64 _time;
@@ -254,8 +252,8 @@ gesture_update_motion_point (GesturePoint *point,
 }
 
 static void
-gesture_update_release_point (GesturePoint *point,
-                              ClutterEvent *event)
+gesture_update_release_point (GesturePoint       *point,
+                              const ClutterEvent *event)
 {
   gint64 _time;
 
@@ -283,7 +281,7 @@ gesture_get_default_threshold (void)
 static gboolean
 gesture_point_pass_threshold (ClutterGestureAction *action,
                               GesturePoint         *point,
-                              ClutterEvent         *event)
+                              const ClutterEvent   *event)
 {
   float threshold_x, threshold_y;
   gfloat motion_x, motion_y;
@@ -312,8 +310,6 @@ cancel_gesture (ClutterGestureAction *action)
 
   priv->in_gesture = FALSE;
 
-  g_clear_signal_handler (&priv->stage_capture_id, priv->stage);
-
   actor = clutter_actor_meta_get_actor (CLUTTER_ACTOR_META (action));
   g_signal_emit (action, gesture_signals[GESTURE_CANCEL], 0, actor);
 
@@ -354,34 +350,50 @@ begin_gesture (ClutterGestureAction *action,
 }
 
 static gboolean
-stage_captured_event_cb (ClutterActor         *stage,
-                         ClutterEvent         *event,
-                         ClutterGestureAction *action)
+clutter_gesture_action_handle_event (ClutterAction      *action,
+                                     const ClutterEvent *event)
 {
+  ClutterGestureAction *gesture_action = CLUTTER_GESTURE_ACTION (action);
   ClutterGestureActionPrivate *priv =
-    clutter_gesture_action_get_instance_private (action);
-  ClutterActor *actor;
+    clutter_gesture_action_get_instance_private (gesture_action);
+  ClutterActor *actor =
+    clutter_actor_meta_get_actor (CLUTTER_ACTOR_META (action));
   gint position;
   float threshold_x, threshold_y;
   gboolean return_value;
   GesturePoint *point;
   ClutterEventType event_type;
 
-  event_type = clutter_event_type (event);
-  if (event_type != CLUTTER_TOUCH_CANCEL &&
-      event_type != CLUTTER_TOUCH_UPDATE &&
-      event_type != CLUTTER_TOUCH_END &&
-      event_type != CLUTTER_MOTION &&
-      event_type != CLUTTER_BUTTON_RELEASE)
+  if (!clutter_actor_meta_get_enabled (CLUTTER_ACTOR_META (action)))
     return CLUTTER_EVENT_PROPAGATE;
 
-  if ((point = gesture_find_point (action, event, &position)) == NULL)
-    return CLUTTER_EVENT_PROPAGATE;
+  event_type = clutter_event_type (event);
 
-  actor = clutter_actor_meta_get_actor (CLUTTER_ACTOR_META (action));
+  if (event_type == CLUTTER_BUTTON_PRESS ||
+      event_type == CLUTTER_TOUCH_BEGIN)
+    {
+      point = gesture_register_point (gesture_action, event);
+    }
+  else
+    {
+      if ((point = gesture_find_point (gesture_action, event, &position)) == NULL)
+        return CLUTTER_EVENT_PROPAGATE;
+    }
 
   switch (clutter_event_type (event))
     {
+    case CLUTTER_BUTTON_PRESS:
+    case CLUTTER_TOUCH_BEGIN:
+      if (priv->stage == NULL)
+        priv->stage = clutter_actor_get_stage (actor);
+
+      /* Start the gesture immediately if the gesture has no
+       * _TRIGGER_EDGE_AFTER drag threshold. */
+      if ((priv->points->len >= priv->requested_nb_points) &&
+          (priv->edge != CLUTTER_GESTURE_TRIGGER_EDGE_AFTER))
+        begin_gesture (gesture_action, actor);
+
+      break;
     case CLUTTER_MOTION:
       {
         ClutterModifierType mods = clutter_event_get_state (event);
@@ -392,7 +404,7 @@ stage_captured_event_cb (ClutterActor         *stage,
          */
         if (!(mods & CLUTTER_BUTTON1_MASK))
           {
-            cancel_gesture (action);
+            cancel_gesture (gesture_action);
             return CLUTTER_EVENT_PROPAGATE;
           }
       }
@@ -410,7 +422,7 @@ stage_captured_event_cb (ClutterActor         *stage,
           /* Wait until the drag threshold has been exceeded
            * before starting _TRIGGER_EDGE_AFTER gestures. */
           if (priv->edge == CLUTTER_GESTURE_TRIGGER_EDGE_AFTER &&
-              gesture_point_pass_threshold (action, point, event))
+              gesture_point_pass_threshold (gesture_action, point, event))
             {
               gesture_update_motion_point (point, event);
               return CLUTTER_EVENT_PROPAGATE;
@@ -418,31 +430,33 @@ stage_captured_event_cb (ClutterActor         *stage,
 
           gesture_update_motion_point (point, event);
 
-          if (!begin_gesture (action, actor))
+          if (!begin_gesture (gesture_action, actor))
             return CLUTTER_EVENT_PROPAGATE;
 
-          if ((point = gesture_find_point (action, event, &position)) == NULL)
+          if ((point = gesture_find_point (gesture_action, event, &position)) == NULL)
             return CLUTTER_EVENT_PROPAGATE;
         }
 
       gesture_update_motion_point (point, event);
 
-      g_signal_emit (action, gesture_signals[GESTURE_PROGRESS], 0, actor,
+      g_signal_emit (gesture_action, gesture_signals[GESTURE_PROGRESS], 0, actor,
                      &return_value);
       if (!return_value)
         {
-          cancel_gesture (action);
+          cancel_gesture (gesture_action);
           return CLUTTER_EVENT_PROPAGATE;
         }
 
       /* Check if a _TRIGGER_EDGE_BEFORE gesture needs to be cancelled because
        * the drag threshold has been exceeded. */
-      clutter_gesture_action_get_threshold_trigger_distance (action, &threshold_x, &threshold_y);
+      clutter_gesture_action_get_threshold_trigger_distance (gesture_action,
+                                                             &threshold_x,
+                                                             &threshold_y);
       if (priv->edge == CLUTTER_GESTURE_TRIGGER_EDGE_BEFORE &&
           ((fabsf (point->press_y - point->last_motion_y) > threshold_y) ||
            (fabsf (point->press_x - point->last_motion_x) > threshold_x)))
         {
-          cancel_gesture (action);
+          cancel_gesture (gesture_action);
           return CLUTTER_EVENT_PROPAGATE;
         }
       break;
@@ -456,10 +470,10 @@ stage_captured_event_cb (ClutterActor         *stage,
             ((priv->points->len - 1) < priv->requested_nb_points))
           {
             priv->in_gesture = FALSE;
-            g_signal_emit (action, gesture_signals[GESTURE_END], 0, actor);
+            g_signal_emit (gesture_action, gesture_signals[GESTURE_END], 0, actor);
           }
 
-        gesture_unregister_point (action, position);
+        gesture_unregister_point (gesture_action, position);
       }
       break;
 
@@ -470,10 +484,10 @@ stage_captured_event_cb (ClutterActor         *stage,
         if (priv->in_gesture)
           {
             priv->in_gesture = FALSE;
-            cancel_gesture (action);
+            cancel_gesture (gesture_action);
           }
 
-        gesture_unregister_point (action, position);
+        gesture_unregister_point (gesture_action, position);
       }
       break;
 
@@ -481,85 +495,9 @@ stage_captured_event_cb (ClutterActor         *stage,
       break;
     }
 
-  if (priv->points->len == 0)
-    g_clear_signal_handler (&priv->stage_capture_id, priv->stage);
-
-  return CLUTTER_EVENT_PROPAGATE;
-}
-
-static gboolean
-actor_captured_event_cb (ClutterActor *actor,
-                         ClutterEvent *event,
-                         ClutterGestureAction *action)
-{
-  ClutterGestureActionPrivate *priv =
-    clutter_gesture_action_get_instance_private (action);
-  GesturePoint *point G_GNUC_UNUSED;
-
-  if ((clutter_event_type (event) != CLUTTER_BUTTON_PRESS) &&
-      (clutter_event_type (event) != CLUTTER_TOUCH_BEGIN))
-    return CLUTTER_EVENT_PROPAGATE;
-
-  if (!clutter_actor_meta_get_enabled (CLUTTER_ACTOR_META (action)))
-    return CLUTTER_EVENT_PROPAGATE;
-
-  point = gesture_register_point (action, event);
-
-  if (priv->stage == NULL)
-    priv->stage = clutter_actor_get_stage (actor);
-
-  if (priv->stage_capture_id == 0)
-    priv->stage_capture_id =
-      g_signal_connect_after (priv->stage, "captured-event",
-                              G_CALLBACK (stage_captured_event_cb),
-                              action);
-
-  /* Start the gesture immediately if the gesture has no
-   * _TRIGGER_EDGE_AFTER drag threshold. */
-  if ((priv->points->len >= priv->requested_nb_points) &&
-      (priv->edge != CLUTTER_GESTURE_TRIGGER_EDGE_AFTER))
-    begin_gesture (action, actor);
-
-  return CLUTTER_EVENT_PROPAGATE;
-}
-
-static void
-clutter_gesture_action_set_actor (ClutterActorMeta *meta,
-                                  ClutterActor     *actor)
-{
-  ClutterGestureActionPrivate *priv =
-    clutter_gesture_action_get_instance_private (CLUTTER_GESTURE_ACTION (meta));
-  ClutterActorMetaClass *meta_class =
-    CLUTTER_ACTOR_META_CLASS (clutter_gesture_action_parent_class);
-
-  if (priv->actor_capture_id != 0)
-    {
-      ClutterActor *old_actor = clutter_actor_meta_get_actor (meta);
-
-      if (old_actor != NULL)
-        g_clear_signal_handler (&priv->actor_capture_id, old_actor);
-
-      priv->actor_capture_id = 0;
-    }
-
-  if (priv->stage_capture_id != 0)
-    {
-      if (priv->stage != NULL)
-        g_clear_signal_handler (&priv->stage_capture_id, priv->stage);
-
-      priv->stage_capture_id = 0;
-      priv->stage = NULL;
-    }
-
-  if (actor != NULL)
-    {
-      priv->actor_capture_id =
-        g_signal_connect (actor, "captured-event",
-                          G_CALLBACK (actor_captured_event_cb),
-                          meta);
-    }
-
-  meta_class->set_actor (meta, actor);
+  return priv->in_gesture ?
+    CLUTTER_EVENT_STOP :
+    CLUTTER_EVENT_PROPAGATE;
 }
 
 static void
@@ -683,14 +621,16 @@ clutter_gesture_action_class_init (ClutterGestureActionClass *klass)
 {
   GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
   ClutterActorMetaClass *meta_class = CLUTTER_ACTOR_META_CLASS (klass);
+  ClutterActionClass *action_class = CLUTTER_ACTION_CLASS (klass);
 
   gobject_class->finalize = clutter_gesture_action_finalize;
   gobject_class->set_property = clutter_gesture_action_set_property;
   gobject_class->get_property = clutter_gesture_action_get_property;
 
-  meta_class->set_actor = clutter_gesture_action_set_actor;
   meta_class->set_enabled = clutter_gesture_action_set_enabled;
 
+  action_class->handle_event = clutter_gesture_action_handle_event;
+
   klass->gesture_begin = default_event_handler;
   klass->gesture_progress = default_event_handler;
   klass->gesture_prepare = default_event_handler;
diff --git a/clutter/clutter/clutter-input-device-private.h b/clutter/clutter/clutter-input-device-private.h
index a2168cc07..91f6e8e1c 100644
--- a/clutter/clutter/clutter-input-device-private.h
+++ b/clutter/clutter/clutter-input-device-private.h
@@ -59,16 +59,6 @@ struct _ClutterInputDevice
   GHashTable   *sequence_grab_actors;
   GHashTable   *inv_sequence_grab_actors;
 
-  /* the current click count */
-  int click_count;
-  int current_button_number;
-
-  /* the previous state, used for click count generation */
-  int previous_x;
-  int previous_y;
-  uint32_t previous_time;
-  int previous_button_number;
-
   /* Accessiblity */
   ClutterVirtualInputDevice *accessibility_virtual_device;
   ClutterPtrA11yData *ptr_a11y_data;
diff --git a/clutter/clutter/clutter-input-device.c b/clutter/clutter/clutter-input-device.c
index 3a31cdc80..5a496f09c 100644
--- a/clutter/clutter/clutter-input-device.c
+++ b/clutter/clutter/clutter-input-device.c
@@ -427,13 +427,6 @@ clutter_input_device_init (ClutterInputDevice *self)
     clutter_input_device_get_instance_private (self);
 
   priv->device_type = CLUTTER_POINTER_DEVICE;
-
-  self->click_count = 0;
-
-  self->previous_time = CLUTTER_CURRENT_TIME;
-  self->previous_x = -1;
-  self->previous_y = -1;
-  self->current_button_number = self->previous_button_number = -1;
 }
 
 /**
diff --git a/clutter/clutter/clutter-main.c b/clutter/clutter/clutter-main.c
index 195c2e5cf..100061923 100644
--- a/clutter/clutter/clutter-main.c
+++ b/clutter/clutter/clutter-main.c
@@ -80,13 +80,10 @@ static ClutterMainContext *ClutterCntx       = NULL;
 /* command line options */
 static gboolean clutter_is_initialized       = FALSE;
 static gboolean clutter_show_fps             = FALSE;
-static gboolean clutter_fatal_warnings       = FALSE;
 static gboolean clutter_disable_mipmap_text  = FALSE;
 static gboolean clutter_enable_accessibility = TRUE;
 static gboolean clutter_sync_to_vblank       = TRUE;
 
-static guint clutter_default_fps             = 60;
-
 static ClutterTextDirection clutter_text_direction = CLUTTER_TEXT_DIRECTION_LTR;
 
 /* debug flags */
@@ -490,106 +487,23 @@ _clutter_context_is_initialized (void)
 ClutterMainContext *
 _clutter_context_get_default (void)
 {
-  if (G_UNLIKELY (ClutterCntx == NULL))
-    {
-      ClutterMainContext *ctx;
-
-      ClutterCntx = ctx = g_new0 (ClutterMainContext, 1);
-
-      ctx->is_initialized = FALSE;
-
-      /* create the windowing system backend */
-      ctx->backend = _clutter_create_backend ();
-
-      /* create the default settings object, and store a back pointer to
-       * the backend singleton
-       */
-      ctx->settings = clutter_settings_get_default ();
-      _clutter_settings_set_backend (ctx->settings, ctx->backend);
-
-      ctx->events_queue = g_async_queue_new ();
-
-      ctx->last_repaint_id = 1;
-    }
-
+  g_assert (ClutterCntx);
   return ClutterCntx;
 }
 
 static gboolean
-clutter_arg_direction_cb (const char *key,
-                          const char *value,
-                          gpointer    user_data)
-{
-  clutter_text_direction =
-    (strcmp (value, "rtl") == 0) ? CLUTTER_TEXT_DIRECTION_RTL
-                                 : CLUTTER_TEXT_DIRECTION_LTR;
-
-  return TRUE;
-}
-
-#ifdef CLUTTER_ENABLE_DEBUG
-static gboolean
-clutter_arg_debug_cb (const char *key,
-                      const char *value,
-                      gpointer    user_data)
-{
-  clutter_debug_flags |=
-    g_parse_debug_string (value,
-                          clutter_debug_keys,
-                          G_N_ELEMENTS (clutter_debug_keys));
-  return TRUE;
-}
-
-static gboolean
-clutter_arg_no_debug_cb (const char *key,
-                         const char *value,
-                         gpointer    user_data)
-{
-  clutter_debug_flags &=
-    ~g_parse_debug_string (value,
-                           clutter_debug_keys,
-                           G_N_ELEMENTS (clutter_debug_keys));
-  return TRUE;
-}
-#endif /* CLUTTER_ENABLE_DEBUG */
-
-GQuark
-clutter_init_error_quark (void)
-{
-  return g_quark_from_static_string ("clutter-init-error-quark");
-}
-
-static ClutterInitError
-clutter_init_real (GError **error)
+clutter_init_real (ClutterMainContext  *clutter_context,
+                   GError             **error)
 {
-  ClutterMainContext *ctx;
   ClutterBackend *backend;
 
   /* Note, creates backend if not already existing, though parse args will
    * have likely created it
    */
-  ctx = _clutter_context_get_default ();
-  backend = ctx->backend;
-
-  if (!ctx->options_parsed)
-    {
-      if (error)
-        g_set_error (error, CLUTTER_INIT_ERROR,
-                     CLUTTER_INIT_ERROR_INTERNAL,
-                     "When using clutter_get_option_group_without_init() "
-		     "you must parse options before calling clutter_init()");
-      else
-        g_critical ("When using clutter_get_option_group_without_init() "
-		    "you must parse options before calling clutter_init()");
-
-      return CLUTTER_INIT_ERROR_INTERNAL;
-    }
+  backend = clutter_context->backend;
 
-  /*
-   * Call backend post parse hooks.
-   */
-  if (!_clutter_backend_post_parse (backend, error))
-    return CLUTTER_INIT_ERROR_BACKEND;
+  if (!_clutter_backend_finish_init (backend, error))
+    return FALSE;
 
   /* If we are displaying the regions that would get redrawn with clipped
    * redraws enabled we actually have to disable the clipped redrawing
@@ -611,70 +525,29 @@ clutter_init_real (GError **error)
   /* this will take care of initializing Cogl's state and
    * query the GL machinery for features
    */
-  if (!_clutter_feature_init (error))
-    return CLUTTER_INIT_ERROR_BACKEND;
+  if (!clutter_feature_init (clutter_context, error))
+    return FALSE;
 
   clutter_text_direction = clutter_get_text_direction ();
 
   clutter_is_initialized = TRUE;
-  ctx->is_initialized = TRUE;
+  clutter_context->is_initialized = TRUE;
 
   /* Initialize a11y */
   if (clutter_enable_accessibility)
     cally_accessibility_init ();
 
   /* Initialize types required for paint nodes */
-  _clutter_paint_node_init_types ();
+  clutter_paint_node_init_types (clutter_context->backend);
 
-  return CLUTTER_INIT_SUCCESS;
+  return TRUE;
 }
 
-static GOptionEntry clutter_args[] = {
-  { "clutter-show-fps", 0, 0, G_OPTION_ARG_NONE, &clutter_show_fps,
-    N_("Show frames per second"), NULL },
-  { "clutter-default-fps", 0, 0, G_OPTION_ARG_INT, &clutter_default_fps,
-    N_("Default frame rate"), "FPS" },
-  { "g-fatal-warnings", 0, 0, G_OPTION_ARG_NONE, &clutter_fatal_warnings,
-    N_("Make all warnings fatal"), NULL },
-  { "clutter-text-direction", 0, 0, G_OPTION_ARG_CALLBACK,
-    clutter_arg_direction_cb,
-    N_("Direction for the text"), "DIRECTION" },
-  { "clutter-disable-mipmapped-text", 0, 0, G_OPTION_ARG_NONE,
-    &clutter_disable_mipmap_text,
-    N_("Disable mipmapping on text"), NULL },
-#ifdef CLUTTER_ENABLE_DEBUG
-  { "clutter-debug", 0, 0, G_OPTION_ARG_CALLBACK, clutter_arg_debug_cb,
-    N_("Clutter debugging flags to set"), "FLAGS" },
-  { "clutter-no-debug", 0, 0, G_OPTION_ARG_CALLBACK, clutter_arg_no_debug_cb,
-    N_("Clutter debugging flags to unset"), "FLAGS" },
-#endif /* CLUTTER_ENABLE_DEBUG */
-  { "clutter-enable-accessibility", 0, 0, G_OPTION_ARG_NONE, &clutter_enable_accessibility,
-    N_("Enable accessibility"), NULL },
-  { NULL, },
-};
-
-/* pre_parse_hook: initialise variables depending on environment
- * variables; these variables might be overridden by the command
- * line arguments that are going to be parsed after.
- */
-static gboolean
-pre_parse_hook (GOptionContext  *context,
-                GOptionGroup    *group,
-                gpointer         data,
-                GError         **error)
+static void
+init_clutter_debug (ClutterMainContext *clutter_context)
 {
-  ClutterMainContext *clutter_context;
-  ClutterBackend *backend;
   const char *env_string;
 
-  if (clutter_is_initialized)
-    return TRUE;
-
-  clutter_context = _clutter_context_get_default ();
-
-  backend = clutter_context->backend;
-  g_assert (CLUTTER_IS_BACKEND (backend));
-
 #ifdef CLUTTER_ENABLE_DEBUG
   env_string = g_getenv ("CLUTTER_DEBUG");
   if (env_string != NULL)
@@ -711,264 +584,64 @@ pre_parse_hook (GOptionContext  *context,
   if (env_string)
     clutter_show_fps = TRUE;
 
-  env_string = g_getenv ("CLUTTER_DEFAULT_FPS");
-  if (env_string)
-    {
-      gint default_fps = g_ascii_strtoll (env_string, NULL, 10);
-
-      clutter_default_fps = CLAMP (default_fps, 1, 1000);
-    }
-
   env_string = g_getenv ("CLUTTER_DISABLE_MIPMAPPED_TEXT");
   if (env_string)
     clutter_disable_mipmap_text = TRUE;
-
-  return _clutter_backend_pre_parse (backend, error);
 }
 
-/* post_parse_hook: initialise the context and data structures
- * and opens the X display
- */
-static gboolean
-post_parse_hook (GOptionContext  *context,
-                 GOptionGroup    *group,
-                 gpointer         data,
-                 GError         **error)
+ClutterContext *
+clutter_context_new (ClutterBackendConstructor   backend_constructor,
+                     gpointer                    user_data,
+                     GError                    **error)
 {
   ClutterMainContext *clutter_context;
-  ClutterBackend *backend;
-
-  if (clutter_is_initialized)
-    return TRUE;
-
-  clutter_context = _clutter_context_get_default ();
-  backend = clutter_context->backend;
-  g_assert (CLUTTER_IS_BACKEND (backend));
 
-  if (clutter_fatal_warnings)
+  if (ClutterCntx)
     {
-      GLogLevelFlags fatal_mask;
-
-      fatal_mask = g_log_set_always_fatal (G_LOG_FATAL_MASK);
-      fatal_mask |= G_LOG_LEVEL_WARNING | G_LOG_LEVEL_CRITICAL;
-      g_log_set_always_fatal (fatal_mask);
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "Currently only creating one clutter context is supported");
+      return NULL;
     }
 
-  clutter_context->frame_rate = clutter_default_fps;
-  clutter_context->show_fps = clutter_show_fps;
-  clutter_context->options_parsed = TRUE;
-
-  /* If not asked to defer display setup, call clutter_init_real(),
-   * which in turn calls the backend post parse hooks.
-   */
-  if (!clutter_context->defer_display_setup)
-    return clutter_init_real (error) == CLUTTER_INIT_SUCCESS;
+  clutter_graphene_init ();
 
-  return TRUE;
-}
-
-/**
- * clutter_get_option_group: (skip)
- *
- * Returns a #GOptionGroup for the command line arguments recognized
- * by Clutter. You should add this group to your #GOptionContext with
- * g_option_context_add_group(), if you are using g_option_context_parse()
- * to parse your commandline arguments.
- *
- * Calling g_option_context_parse() with Clutter's #GOptionGroup will result
- * in Clutter's initialization. That is, the following code:
- *
- * |[
- *   g_option_context_set_main_group (context, clutter_get_option_group ());
- *   res = g_option_context_parse (context, &argc, &argc, NULL);
- * ]|
- *
- * is functionally equivalent to:
- *
- * |[
- *   clutter_init (&argc, &argv);
- * ]|
- *
- * After g_option_context_parse() on a #GOptionContext containing the
- * Clutter #GOptionGroup has returned %TRUE, Clutter is guaranteed to be
- * initialized.
- *
- * Return value: (transfer full): a #GOptionGroup for the commandline arguments
- *   recognized by Clutter
- *
- * Since: 0.2
- */
-GOptionGroup *
-clutter_get_option_group (void)
-{
-  ClutterMainContext *context;
-  GOptionGroup *group;
-
-  clutter_base_init ();
-
-  context = _clutter_context_get_default ();
-
-  group = g_option_group_new ("clutter",
-                              "Clutter Options",
-                              "Show Clutter Options",
-                              NULL,
-                              NULL);
-
-  g_option_group_set_parse_hooks (group, pre_parse_hook, post_parse_hook);
-  g_option_group_add_entries (group, clutter_args);
-
-  /* add backend-specific options */
-  _clutter_backend_add_options (context->backend, group);
-
-  return group;
-}
-
-/**
- * clutter_get_option_group_without_init: (skip)
- *
- * Returns a #GOptionGroup for the command line arguments recognized
- * by Clutter. You should add this group to your #GOptionContext with
- * g_option_context_add_group(), if you are using g_option_context_parse()
- * to parse your commandline arguments.
- *
- * Unlike clutter_get_option_group(), calling g_option_context_parse() with
- * the #GOptionGroup returned by this function requires a subsequent explicit
- * call to clutter_init(); use this function when needing to set foreign
- * display connection with clutter_x11_set_display(), or with
- * `gtk_clutter_init()`.
- *
- * Return value: (transfer full): a #GOptionGroup for the commandline arguments
- *   recognized by Clutter
- *
- * Since: 0.8
- */
-GOptionGroup *
-clutter_get_option_group_without_init (void)
-{
-  ClutterMainContext *context;
-  GOptionGroup *group;
-
-  clutter_base_init ();
-
-  context = _clutter_context_get_default ();
-  context->defer_display_setup = TRUE;
-
-  group = clutter_get_option_group ();
-
-  return group;
-}
-
-/* Note that the gobject-introspection annotations for the argc/argv
- * parameters do not produce the right result; however, they do
- * allow the common case of argc=NULL, argv=NULL to work.
- */
-
-
-static gboolean
-clutter_parse_args (int      *argc,
-                    char   ***argv,
-                    GError  **error)
-{
-  GOptionContext *option_context;
-  GOptionGroup *clutter_group, *cogl_group;
-  GError *internal_error = NULL;
-  gboolean ret = TRUE;
-
-  if (clutter_is_initialized)
-    return TRUE;
-
-  option_context = g_option_context_new (NULL);
-  g_option_context_set_ignore_unknown_options (option_context, TRUE);
-  g_option_context_set_help_enabled (option_context, FALSE);
+  clutter_context = g_new0 (ClutterMainContext, 1);
+  init_clutter_debug (clutter_context);
+  clutter_context->show_fps = clutter_show_fps;
+  clutter_context->is_initialized = FALSE;
 
-  /* Initiate any command line options from the backend */
-  clutter_group = clutter_get_option_group ();
-  g_option_context_set_main_group (option_context, clutter_group);
+  clutter_context->backend = backend_constructor (user_data);
+  clutter_context->settings = clutter_settings_get_default ();
+  _clutter_settings_set_backend (clutter_context->settings,
+                                 clutter_context->backend);
 
-  cogl_group = cogl_get_option_group ();
-  g_option_context_add_group (option_context, cogl_group);
+  clutter_context->events_queue = g_async_queue_new ();
+  clutter_context->last_repaint_id = 1;
 
-  if (!g_option_context_parse (option_context, argc, argv, &internal_error))
+  if (!clutter_init_real (clutter_context, error))
     {
-      g_propagate_error (error, internal_error);
-      ret = FALSE;
+      g_free (clutter_context);
+      return NULL;
     }
 
-  g_option_context_free (option_context);
+  ClutterCntx = clutter_context;
 
-  return ret;
+  return clutter_context;
 }
 
-/**
- * clutter_init:
- * @argc: (inout): The number of arguments in @argv
- * @argv: (array length=argc) (inout) (allow-none): A pointer to an array
- *   of arguments.
- *
- * Initialises everything needed to operate with Clutter and parses some
- * standard command line options; @argc and @argv are adjusted accordingly
- * so your own code will never see those standard arguments.
- *
- * It is safe to call this function multiple times.
- *
- * This function will not abort in case of errors during
- * initialization; clutter_init() will print out the error message on
- * stderr, and will return an error code. It is up to the application
- * code to handle this case.
- *
- * If this function fails, and returns an error code, any subsequent
- * Clutter API will have undefined behaviour - including segmentation
- * faults and assertion failures. Make sure to handle the returned
- * #ClutterInitError enumeration value.
- *
- * Return value: a #ClutterInitError value
- */
-ClutterInitError
-clutter_init (int    *argc,
-              char ***argv)
+void
+clutter_context_free (ClutterMainContext *clutter_context)
 {
-  ClutterMainContext *ctx;
-  GError *error = NULL;
-  ClutterInitError res;
-
-  if (clutter_is_initialized)
-    return CLUTTER_INIT_SUCCESS;
-
-  clutter_base_init ();
-
-  ctx = _clutter_context_get_default ();
-
-  if (!ctx->defer_display_setup)
-    {
-#if 0
-      if (argc && *argc > 0 && *argv)
-	g_set_prgname ((*argv)[0]);
-#endif
-
-      /* parse_args will trigger backend creation and things like
-       * DISPLAY connection etc.
-       */
-      if (!clutter_parse_args (argc, argv, &error))
-	{
-          g_critical ("Unable to initialize Clutter: %s", error->message);
-          g_error_free (error);
-
-          res = CLUTTER_INIT_ERROR_INTERNAL;
-	}
-      else
-        res = CLUTTER_INIT_SUCCESS;
-    }
-  else
-    {
-      res = clutter_init_real (&error);
-      if (error != NULL)
-        {
-          g_critical ("Unable to initialize Clutter: %s", error->message);
-          g_error_free (error);
-        }
-    }
+  g_clear_pointer (&clutter_context->events_queue, g_async_queue_unref);
+  g_clear_pointer (&clutter_context->backend, clutter_backend_destroy);
+  ClutterCntx = NULL;
+  g_free (clutter_context);
+}
 
-  return res;
+ClutterBackend *
+clutter_context_get_backend (ClutterContext *clutter_context)
+{
+  return clutter_context->backend;
 }
 
 gboolean
@@ -1001,107 +674,6 @@ _clutter_boolean_continue_accumulator (GSignalInvocationHint *ihint,
   return continue_emission;
 }
 
-static void
-event_click_count_generate (ClutterEvent *event)
-{
-  /* multiple button click detection */
-  static gint    click_count            = 0;
-  static gint    previous_x             = -1;
-  static gint    previous_y             = -1;
-  static guint32 previous_time          = 0;
-  static gint    previous_button_number = -1;
-
-  ClutterInputDevice *device = NULL;
-  ClutterSettings *settings;
-  guint double_click_time;
-  guint double_click_distance;
-
-  settings = clutter_settings_get_default ();
-
-  g_object_get (settings,
-                "double-click-distance", &double_click_distance,
-                "double-click-time", &double_click_time,
-                NULL);
-
-  device = clutter_event_get_device (event);
-  if (device != NULL)
-    {
-      click_count = device->click_count;
-      previous_x = device->previous_x;
-      previous_y = device->previous_y;
-      previous_time = device->previous_time;
-      previous_button_number = device->previous_button_number;
-
-      CLUTTER_NOTE (EVENT,
-                    "Restoring previous click count:%d (device:%s, time:%u)",
-                    click_count,
-                    clutter_input_device_get_device_name (device),
-                    previous_time);
-    }
-  else
-    {
-      CLUTTER_NOTE (EVENT,
-                    "Restoring previous click count:%d (time:%u)",
-                    click_count,
-                    previous_time);
-    }
-
-  switch (clutter_event_type (event))
-    {
-      case CLUTTER_BUTTON_PRESS:
-        /* check if we are in time and within distance to increment an
-         * existing click count
-         */
-        if (event->button.button == previous_button_number &&
-            event->button.time < (previous_time + double_click_time) &&
-            (ABS (event->button.x - previous_x) <= double_click_distance) &&
-            (ABS (event->button.y - previous_y) <= double_click_distance))
-          {
-            CLUTTER_NOTE (EVENT, "Increase click count (button: %d, time: %u)",
-                          event->button.button,
-                          event->button.time);
-
-            click_count += 1;
-          }
-        else /* start a new click count*/
-          {
-            CLUTTER_NOTE (EVENT, "Reset click count (button: %d, time: %u)",
-                          event->button.button,
-                          event->button.time);
-
-            click_count = 1;
-            previous_button_number = event->button.button;
-          }
-
-        previous_x = event->button.x;
-        previous_y = event->button.y;
-        previous_time = event->button.time;
-
-        G_GNUC_FALLTHROUGH;
-      case CLUTTER_BUTTON_RELEASE:
-        event->button.click_count = click_count;
-        break;
-
-      default:
-        g_assert_not_reached ();
-        break;
-    }
-
-  if (event->type == CLUTTER_BUTTON_PRESS && device != NULL)
-    {
-      CLUTTER_NOTE (EVENT, "Storing click count: %d (device:%s, time:%u)",
-                    click_count,
-                    clutter_input_device_get_device_name (device),
-                    previous_time);
-
-      device->click_count = click_count;
-      device->previous_x = previous_x;
-      device->previous_y = previous_y;
-      device->previous_time = previous_time;
-      device->previous_button_number = previous_button_number;
-    }
-}
-
 static inline void
 emit_event_chain (ClutterEvent *event)
 {
@@ -1116,16 +688,13 @@ emit_event_chain (ClutterEvent *event)
 
 /*
  * Emits a pointer event after having prepared the event for delivery (setting
- * source, computing click_count, generating enter/leave etc.).
+ * source, generating enter/leave etc.).
  */
 
 static inline void
 emit_pointer_event (ClutterEvent       *event,
                     ClutterInputDevice *device)
 {
-  if (_clutter_event_process_filters (event))
-    return;
-
   if (device != NULL && device->pointer_grab_actor != NULL)
     clutter_actor_event (device->pointer_grab_actor, event, FALSE);
   else
@@ -1139,9 +708,6 @@ emit_crossing_event (ClutterEvent       *event,
   ClutterEventSequence *sequence = clutter_event_get_event_sequence (event);
   ClutterActor *grab_actor = NULL;
 
-  if (_clutter_event_process_filters (event))
-    return;
-
   if (sequence)
     {
       if (device->sequence_grab_actors != NULL)
@@ -1165,9 +731,6 @@ emit_touch_event (ClutterEvent       *event,
 {
   ClutterActor *grab_actor = NULL;
 
-  if (_clutter_event_process_filters (event))
-    return;
-
   if (device->sequence_grab_actors != NULL)
     {
       grab_actor = g_hash_table_lookup (device->sequence_grab_actors,
@@ -1190,8 +753,7 @@ static inline void
 process_key_event (ClutterEvent       *event,
                    ClutterInputDevice *device)
 {
-  if (_clutter_event_process_filters (event))
-    return;
+  cally_snoop_key_event ((ClutterKeyEvent *) event);
 
   if (device != NULL && device->keyboard_grab_actor != NULL)
     clutter_actor_event (device->keyboard_grab_actor, event, FALSE);
@@ -1199,19 +761,29 @@ process_key_event (ClutterEvent       *event,
     emit_event_chain (event);
 }
 
-static gboolean
-is_off_stage (ClutterActor *stage,
-              gfloat        x,
-              gfloat        y)
+static ClutterActor *
+update_device_for_event (ClutterStage *stage,
+                         ClutterEvent *event,
+                         gboolean      emit_crossing)
 {
-  gfloat width, height;
+  ClutterInputDevice *device = clutter_event_get_device (event);
+  ClutterEventSequence *sequence = clutter_event_get_event_sequence (event);
+  ClutterDeviceUpdateFlags flags = CLUTTER_DEVICE_UPDATE_NONE;
+  graphene_point_t point;
+  uint32_t time_ms;
+
+  clutter_event_get_coords (event, &point.x, &point.y);
+  time_ms = clutter_event_get_time (event);
 
-  clutter_actor_get_size (stage, &width, &height);
+  if (emit_crossing)
+    flags |= CLUTTER_DEVICE_UPDATE_EMIT_CROSSING;
 
-  return (x < 0 ||
-          y < 0 ||
-          x >= width ||
-          y >= height);
+  return clutter_stage_pick_and_update_device (stage,
+                                               device,
+                                               sequence,
+                                               flags,
+                                               point,
+                                               time_ms);
 }
 
 /**
@@ -1231,6 +803,9 @@ is_off_stage (ClutterActor *stage,
 void
 clutter_do_event (ClutterEvent *event)
 {
+  ClutterInputDevice *device;
+  ClutterEventSequence *sequence;
+
   /* we need the stage for the event */
   if (event->any.stage == NULL)
     {
@@ -1242,152 +817,70 @@ clutter_do_event (ClutterEvent *event)
   if (CLUTTER_ACTOR_IN_DESTRUCTION (event->any.stage))
     return;
 
-  /* Instead of processing events when received, we queue them up to
-   * handle per-frame before animations, layout, and drawing.
-   *
-   * This gives us the chance to reliably compress motion events
-   * because we've "looked ahead" and know all motion events that
-   * will occur before drawing the frame.
-   */
-  _clutter_stage_queue_event (event->any.stage, event, TRUE);
-}
-
-static void
-create_crossing_event (ClutterStage         *stage,
-                       ClutterInputDevice   *device,
-                       ClutterEventSequence *sequence,
-                       ClutterEventType      event_type,
-                       ClutterActor         *source,
-                       ClutterActor         *related,
-                       graphene_point_t      coords,
-                       uint32_t              time)
-{
-  ClutterEvent *event;
-
-  event = clutter_event_new (event_type);
-  event->crossing.time = time;
-  event->crossing.flags = 0;
-  event->crossing.stage = stage;
-  event->crossing.source = source;
-  event->crossing.x = coords.x;
-  event->crossing.y = coords.y;
-  event->crossing.related = related;
-  event->crossing.sequence = sequence;
-  clutter_event_set_device (event, device);
-
-  /* we need to make sure that this event is processed
-   * before any other event we might have queued up until
-   * now, so we go on, and synthesize the event emission
-   * ourselves
-   */
-  _clutter_process_event (event);
-
-  clutter_event_free (event);
-}
-
-void
-clutter_stage_update_device (ClutterStage         *stage,
-                             ClutterInputDevice   *device,
-                             ClutterEventSequence *sequence,
-                             graphene_point_t      point,
-                             uint32_t              time,
-                             ClutterActor         *new_actor,
-                             gboolean              emit_crossing)
-{
-  ClutterInputDeviceType device_type;
-  ClutterActor *old_actor;
-  gboolean device_actor_changed;
-
-  device_type = clutter_input_device_get_device_type (device);
-
-  g_assert (device_type != CLUTTER_KEYBOARD_DEVICE &&
-            device_type != CLUTTER_PAD_DEVICE);
-
-  old_actor = clutter_stage_get_device_actor (stage, device, sequence);
-  device_actor_changed = new_actor != old_actor;
-
-  clutter_stage_update_device_entry (stage,
-                                     device, sequence,
-                                     point,
-                                     new_actor);
+  device = clutter_event_get_device (event);
+  sequence = clutter_event_get_event_sequence (event);
 
-  if (device_actor_changed)
+  if (device)
     {
-      CLUTTER_NOTE (EVENT,
-                    "Updating actor under cursor (device %s, at %.2f, %.2f): %s",
-                    clutter_input_device_get_device_name (device),
-                    point.x,
-                    point.y,
-                    _clutter_actor_get_debug_name (new_actor));
-
-      if (old_actor && emit_crossing)
-        {
-          create_crossing_event (stage,
-                                 device, sequence,
-                                 CLUTTER_LEAVE,
-                                 old_actor, new_actor,
-                                 point, time);
-        }
+      ClutterActor *actor = NULL;
 
-      if (new_actor && emit_crossing)
+      switch (event->any.type)
         {
-          create_crossing_event (stage,
-                                 device, sequence,
-                                 CLUTTER_ENTER,
-                                 new_actor, old_actor,
-                                 point, time);
+        case CLUTTER_ENTER:
+        case CLUTTER_MOTION:
+        case CLUTTER_BUTTON_PRESS:
+        case CLUTTER_TOUCH_BEGIN:
+        case CLUTTER_TOUCH_UPDATE:
+          actor = update_device_for_event (event->any.stage, event, TRUE);
+          break;
+        case CLUTTER_KEY_PRESS:
+        case CLUTTER_KEY_RELEASE:
+        case CLUTTER_PAD_BUTTON_PRESS:
+        case CLUTTER_PAD_BUTTON_RELEASE:
+        case CLUTTER_PAD_STRIP:
+        case CLUTTER_PAD_RING:
+        case CLUTTER_IM_COMMIT:
+        case CLUTTER_IM_DELETE:
+        case CLUTTER_IM_PREEDIT:
+          actor = clutter_stage_get_key_focus (event->any.stage);
+          break;
+        case CLUTTER_DEVICE_ADDED:
+        case CLUTTER_DEVICE_REMOVED:
+          actor = CLUTTER_ACTOR (event->any.stage);
+          break;
+        case CLUTTER_LEAVE:
+        case CLUTTER_BUTTON_RELEASE:
+        case CLUTTER_TOUCH_END:
+        case CLUTTER_TOUCH_CANCEL:
+        case CLUTTER_SCROLL:
+        case CLUTTER_TOUCHPAD_PINCH:
+        case CLUTTER_TOUCHPAD_SWIPE:
+        case CLUTTER_TOUCHPAD_HOLD:
+        case CLUTTER_PROXIMITY_IN:
+        case CLUTTER_PROXIMITY_OUT:
+          actor = clutter_stage_get_device_actor (event->any.stage,
+                                                  device, sequence);
+          break;
+        case CLUTTER_NOTHING:
+        case CLUTTER_EVENT_LAST:
+          g_assert_not_reached ();
+          break;
         }
-    }
-}
-
-void
-clutter_stage_repick_device (ClutterStage       *stage,
-                             ClutterInputDevice *device)
-{
-  graphene_point_t point;
-  ClutterActor *new_actor;
-
-  clutter_stage_get_device_coords (stage, device, NULL, &point);
-  new_actor =
-    clutter_stage_get_actor_at_pos (stage, CLUTTER_PICK_REACTIVE,
-                                    point.x, point.y);
-
-  clutter_stage_update_device (stage,
-                               device, NULL,
-                               point,
-                               CLUTTER_CURRENT_TIME,
-                               new_actor,
-                               TRUE);
-}
 
-static ClutterActor *
-update_device_for_event (ClutterStage *stage,
-                         ClutterEvent *event,
-                         gboolean      emit_crossing)
-{
-  ClutterInputDevice *device = clutter_event_get_device (event);
-  ClutterEventSequence *sequence = clutter_event_get_event_sequence (event);
-  ClutterActor *new_actor;
-  graphene_point_t point;
-  uint32_t time;
-
-  clutter_event_get_coords (event, &point.x, &point.y);
-  time = clutter_event_get_time (event);
-
-  new_actor =
-    _clutter_stage_do_pick (stage, point.x, point.y, CLUTTER_PICK_REACTIVE);
-
-  /* Picking should never fail, but if it does, we bail out here */
-  g_return_val_if_fail (new_actor != NULL, NULL);
+      clutter_event_set_source (event, actor);
+    }
 
-  clutter_stage_update_device (stage,
-                               device, sequence,
-                               point,
-                               time,
-                               new_actor,
-                               emit_crossing);
+  if (_clutter_event_process_filters (event))
+    return;
 
-  return new_actor;
+  /* Instead of processing events when received, we queue them up to
+   * handle per-frame before animations, layout, and drawing.
+   *
+   * This gives us the chance to reliably compress motion events
+   * because we've "looked ahead" and know all motion events that
+   * will occur before drawing the frame.
+   */
+  _clutter_stage_queue_event (event->any.stage, event, TRUE);
 }
 
 static void
@@ -1408,6 +901,7 @@ remove_device_for_event (ClutterStage *stage,
                                point,
                                time,
                                NULL,
+                               NULL,
                                TRUE);
 
   clutter_stage_remove_device_entry (stage, device, sequence);
@@ -1461,33 +955,7 @@ _clutter_process_event_details (ClutterActor        *stage,
         break;
 
       case CLUTTER_ENTER:
-        /* if we're entering from outside the stage we need
-         * to check whether the pointer is actually on another
-         * actor, and emit an additional pointer event
-         */
-        if (event->any.source == stage &&
-            event->crossing.related == NULL)
-          {
-            ClutterActor *actor = NULL;
-
-            emit_crossing_event (event, device);
-
-            actor = update_device_for_event (CLUTTER_STAGE (stage), event, FALSE);
-            if (actor != stage)
-              {
-                ClutterEvent *crossing;
-
-                /* we emit the exact same event on the actor */
-                crossing = clutter_event_copy (event);
-                crossing->crossing.related = stage;
-                crossing->crossing.source = actor;
-
-                emit_crossing_event (crossing, device);
-                clutter_event_free (crossing);
-              }
-          }
-        else
-          emit_crossing_event (event, device);
+        emit_crossing_event (event, device);
         break;
 
       case CLUTTER_LEAVE:
@@ -1532,9 +1000,6 @@ _clutter_process_event_details (ClutterActor        *stage,
             /* Only stage gets motion events */
             event->any.source = stage;
 
-            if (_clutter_event_process_filters (event))
-              break;
-
             if (device != NULL && device->pointer_grab_actor != NULL)
               {
                 clutter_actor_event (device->pointer_grab_actor,
@@ -1564,88 +1029,22 @@ _clutter_process_event_details (ClutterActor        *stage,
                                                              event->type == CLUTTER_BUTTON_PRESS);
               }
           }
+
+        G_GNUC_FALLTHROUGH;
       case CLUTTER_SCROLL:
       case CLUTTER_TOUCHPAD_PINCH:
       case CLUTTER_TOUCHPAD_SWIPE:
+      case CLUTTER_TOUCHPAD_HOLD:
         {
           gfloat x, y;
 
           clutter_event_get_coords (event, &x, &y);
 
-          /* Only do a pick to find the source if source is not already set
-           * (as it could be in a synthetic event)
-           */
-          if (event->any.source == NULL)
-            {
-              /* emulate X11 the implicit soft grab; the implicit soft grab
-               * keeps relaying motion events when the stage is left with a
-               * pointer button pressed. since this is what happens when we
-               * disable per-actor motion events we need to maintain the same
-               * behaviour when the per-actor motion events are enabled as
-               * well
-               */
-              if (is_off_stage (stage, x, y))
-                {
-                  if (event->type == CLUTTER_BUTTON_RELEASE)
-                    {
-                      CLUTTER_NOTE (EVENT,
-                                    "Release off stage received at %.2f, %.2f",
-                                    x, y);
-
-                      event->button.source = stage;
-                      event->button.click_count = 1;
-
-                      emit_pointer_event (event, device);
-                    }
-                  else if (event->type == CLUTTER_MOTION)
-                    {
-                      CLUTTER_NOTE (EVENT,
-                                    "Motion off stage received at %.2f, %2.f",
-                                    x, y);
-
-                      event->motion.source = stage;
-
-                      emit_pointer_event (event, device);
-                    }
-
-                  break;
-                }
-
-              /* We need to repick on both motion and button press events, the
-               * latter is only needed for X11 (there the device actor might be
-               * stale because we don't always receive motion events).
-               */
-              if (event->type == CLUTTER_BUTTON_PRESS ||
-                  event->type == CLUTTER_MOTION)
-                {
-                  event->any.source =
-                    update_device_for_event (CLUTTER_STAGE (stage), event, TRUE);
-                }
-              else
-                {
-                  event->any.source =
-                    clutter_stage_get_device_actor (CLUTTER_STAGE (stage),
-                                                    device,
-                                                    NULL);
-                }
-
-              if (event->any.source == NULL)
-                break;
-            }
-
           CLUTTER_NOTE (EVENT,
                         "Reactive event received at %.2f, %.2f - actor: %p",
                         x, y,
                         event->any.source);
 
-          /* button presses and releases need a click count */
-          if (event->type == CLUTTER_BUTTON_PRESS ||
-              event->type == CLUTTER_BUTTON_RELEASE)
-            {
-              /* Generate click count */
-              event_click_count_generate (event);
-            }
-
           emit_pointer_event (event, device);
           break;
         }
@@ -1660,9 +1059,6 @@ _clutter_process_event_details (ClutterActor        *stage,
             /* Only stage gets motion events */
             event->any.source = stage;
 
-            if (_clutter_event_process_filters (event))
-              break;
-
             /* global grabs */
             if (device->sequence_grab_actors != NULL)
               {
@@ -1694,51 +1090,6 @@ _clutter_process_event_details (ClutterActor        *stage,
 
           clutter_event_get_coords (event, &x, &y);
 
-          /* Only do a pick to find the source if source is not already set
-           * (as it could be in a synthetic event)
-           */
-          if (event->any.source == NULL)
-            {
-              /* same as the mouse events above, emulate the X11 implicit
-               * soft grab */
-              if (is_off_stage (stage, x, y))
-                {
-                  CLUTTER_NOTE (EVENT,
-                                "Touch %s off stage received at %.2f, %.2f",
-                                event->type == CLUTTER_TOUCH_UPDATE ? "update" :
-                                event->type == CLUTTER_TOUCH_END ? "end" :
-                                event->type == CLUTTER_TOUCH_CANCEL ? "cancel" :
-                                "?", x, y);
-
-                  event->touch.source = stage;
-
-                  emit_touch_event (event, device);
-
-                  if (event->type == CLUTTER_TOUCH_END ||
-                      event->type == CLUTTER_TOUCH_CANCEL)
-                    remove_device_for_event (CLUTTER_STAGE (stage), event, TRUE);
-
-                  break;
-                }
-
-              if (event->type == CLUTTER_TOUCH_BEGIN ||
-                  event->type == CLUTTER_TOUCH_UPDATE)
-                {
-                  event->any.source =
-                    update_device_for_event (CLUTTER_STAGE (stage), event, TRUE);
-                }
-              else
-                {
-                  event->any.source =
-                    clutter_stage_get_device_actor (CLUTTER_STAGE (stage),
-                                                    device,
-                                                    event->touch.sequence);
-                }
-
-              if (event->any.source == NULL)
-                break;
-            }
-
           CLUTTER_NOTE (EVENT,
                         "Reactive event received at %.2f, %.2f - actor: %p",
                         x, y,
@@ -1755,9 +1106,6 @@ _clutter_process_event_details (ClutterActor        *stage,
 
       case CLUTTER_PROXIMITY_IN:
       case CLUTTER_PROXIMITY_OUT:
-        if (_clutter_event_process_filters (event))
-          break;
-
         if (!clutter_actor_event (stage, event, TRUE))
           {
             /* and bubbling phase */
@@ -1766,16 +1114,10 @@ _clutter_process_event_details (ClutterActor        *stage,
 
         break;
 
-      case CLUTTER_DEVICE_ADDED:
-        _clutter_event_process_filters (event);
-        break;
-
       case CLUTTER_DEVICE_REMOVED:
         {
           ClutterInputDeviceType device_type;
 
-          _clutter_event_process_filters (event);
-
           device_type = clutter_input_device_get_device_type (device);
           if (device_type == CLUTTER_POINTER_DEVICE ||
               device_type == CLUTTER_TABLET_DEVICE ||
@@ -1787,6 +1129,7 @@ _clutter_process_event_details (ClutterActor        *stage,
           break;
         }
 
+      case CLUTTER_DEVICE_ADDED:
       case CLUTTER_EVENT_LAST:
         break;
     }
@@ -1828,43 +1171,6 @@ _clutter_process_event (ClutterEvent *event)
   context->current_event = g_slist_delete_link (context->current_event, context->current_event);
 }
 
-void
-clutter_base_init (void)
-{
-  static gboolean initialised = FALSE;
-
-  if (!initialised)
-    {
-      initialised = TRUE;
-
-#if !GLIB_CHECK_VERSION (2, 35, 1)
-      /* initialise GLib type system */
-      g_type_init ();
-#endif
-
-      clutter_graphene_init ();
-    }
-}
-
-/**
- * clutter_get_default_frame_rate:
- *
- * Retrieves the default frame rate. See clutter_set_default_frame_rate().
- *
- * Return value: the default frame rate
- *
- * Since: 0.6
- */
-guint
-clutter_get_default_frame_rate (void)
-{
-  ClutterMainContext *context;
-
-  context = _clutter_context_get_default ();
-
-  return context->frame_rate;
-}
-
 /**
  * clutter_get_font_map:
  *
diff --git a/clutter/clutter/clutter-main.h b/clutter/clutter/clutter-main.h
index 26651efc6..a2d8400f4 100644
--- a/clutter/clutter/clutter-main.h
+++ b/clutter/clutter/clutter-main.h
@@ -77,37 +77,6 @@ typedef enum
   CLUTTER_DEBUG_PAINT_MAX_RENDER_TIME           = 1 << 10,
 } ClutterDrawDebugFlag;
 
-/**
- * CLUTTER_INIT_ERROR:
- *
- * #GError domain for #ClutterInitError
- */
-#define CLUTTER_INIT_ERROR      (clutter_init_error_quark ())
-
-/**
- * ClutterInitError:
- * @CLUTTER_INIT_SUCCESS: Initialisation successful
- * @CLUTTER_INIT_ERROR_UNKNOWN: Unknown error
- * @CLUTTER_INIT_ERROR_THREADS: Thread initialisation failed
- * @CLUTTER_INIT_ERROR_BACKEND: Backend initialisation failed
- * @CLUTTER_INIT_ERROR_INTERNAL: Internal error
- *
- * Error conditions returned by clutter_init().
- *
- * Since: 0.2
- */
-typedef enum
-{
-  CLUTTER_INIT_SUCCESS        =  1,
-  CLUTTER_INIT_ERROR_UNKNOWN  =  0,
-  CLUTTER_INIT_ERROR_THREADS  = -1,
-  CLUTTER_INIT_ERROR_BACKEND  = -2,
-  CLUTTER_INIT_ERROR_INTERNAL = -3
-} ClutterInitError;
-
-CLUTTER_EXPORT
-GQuark clutter_init_error_quark (void);
-
 /**
  * CLUTTER_PRIORITY_REDRAW:
  *
@@ -121,18 +90,6 @@ GQuark clutter_init_error_quark (void);
  */
 #define CLUTTER_PRIORITY_REDRAW         (G_PRIORITY_HIGH_IDLE + 50)
 
-/* Initialisation */
-CLUTTER_EXPORT
-void                    clutter_base_init                       (void);
-CLUTTER_EXPORT
-ClutterInitError        clutter_init                            (int          *argc,
-                                                                 char       ***argv) G_GNUC_WARN_UNUSED_RESULT;
-
-CLUTTER_EXPORT
-GOptionGroup *          clutter_get_option_group                (void);
-CLUTTER_EXPORT
-GOptionGroup *          clutter_get_option_group_without_init   (void);
-
 CLUTTER_EXPORT
 void                    clutter_do_event                        (ClutterEvent *event);
 
@@ -180,9 +137,6 @@ PangoFontMap *          clutter_get_font_map                    (void);
 CLUTTER_EXPORT
 ClutterTextDirection    clutter_get_default_text_direction      (void);
 
-CLUTTER_EXPORT
-guint                   clutter_get_default_frame_rate          (void);
-
 CLUTTER_EXPORT
 void                    clutter_add_debug_flags                 (ClutterDebugFlag     debug_flags,
                                                                  ClutterDrawDebugFlag draw_flags,
diff --git a/clutter/clutter/clutter-mutter.h b/clutter/clutter/clutter-mutter.h
index 818a48bb9..b383ff518 100644
--- a/clutter/clutter/clutter-mutter.h
+++ b/clutter/clutter/clutter-mutter.h
@@ -38,6 +38,32 @@
 #include "clutter-stage-view-private.h"
 #include "clutter.h"
 
+typedef struct _ClutterMainContext ClutterContext;
+
+typedef ClutterBackend * (* ClutterBackendConstructor) (gpointer user_data);
+
+/**
+ * clutter_context_new: (skip)
+ */
+CLUTTER_EXPORT
+ClutterContext * clutter_context_new (ClutterBackendConstructor   backend_constructor,
+                                      gpointer                    user_data,
+                                      GError                    **error);
+
+/**
+ * clutter_context_free: (skip)
+ */
+CLUTTER_EXPORT
+void clutter_context_free (ClutterContext *clutter_context);
+
+/**
+ * clutter_context_get_backend:
+ *
+ * Returns: (transfer none): The corresponding %ClutterBackend
+ */
+CLUTTER_EXPORT
+ClutterBackend * clutter_context_get_backend (ClutterContext *clutter_context);
+
 CLUTTER_EXPORT
 GList * clutter_stage_peek_stage_views (ClutterStage *stage);
 
@@ -45,9 +71,6 @@ CLUTTER_EXPORT
 gboolean clutter_actor_is_effectively_on_stage_view (ClutterActor     *self,
                                                      ClutterStageView *view);
 
-CLUTTER_EXPORT
-void clutter_set_custom_backend_func (ClutterBackend *(* func) (void));
-
 CLUTTER_EXPORT
 int64_t clutter_stage_get_frame_counter (ClutterStage *stage);
 
@@ -85,6 +108,7 @@ void clutter_stage_update_device (ClutterStage         *stage,
                                   graphene_point_t      point,
                                   uint32_t              time,
                                   ClutterActor         *new_actor,
+                                  cairo_region_t       *region,
                                   gboolean              emit_crossing);
 
 CLUTTER_EXPORT
diff --git a/clutter/clutter/clutter-offscreen-effect.c b/clutter/clutter/clutter-offscreen-effect.c
index 7ff3a2ee0..bdb328851 100644
--- a/clutter/clutter/clutter-offscreen-effect.c
+++ b/clutter/clutter/clutter-offscreen-effect.c
@@ -153,9 +153,10 @@ clutter_offscreen_effect_real_create_texture (ClutterOffscreenEffect *effect,
                                               gfloat                  width,
                                               gfloat                  height)
 {
-  return cogl_texture_new_with_size (MAX (width, 1), MAX (height, 1),
-                                     COGL_TEXTURE_NO_SLICING,
-                                     COGL_PIXEL_FORMAT_RGBA_8888_PRE);
+  CoglContext *ctx =
+    clutter_backend_get_cogl_context (clutter_get_default_backend ());
+
+  return cogl_texture_2d_new_with_size (ctx, MAX (width, 1), MAX (height, 1));
 }
 
 static void
diff --git a/clutter/clutter/clutter-paint-node-private.h b/clutter/clutter/clutter-paint-node-private.h
index b084e81d4..c10f10f7e 100644
--- a/clutter/clutter/clutter-paint-node-private.h
+++ b/clutter/clutter/clutter-paint-node-private.h
@@ -27,6 +27,7 @@
 
 #include <glib-object.h>
 #include <json-glib/json-glib.h>
+#include <clutter/clutter-backend.h>
 #include <clutter/clutter-paint-context.h>
 #include <clutter/clutter-paint-node.h>
 
@@ -109,7 +110,7 @@ void                    _clutter_paint_operation_paint_path             (const C
 void                    _clutter_paint_operation_clip_path              (const ClutterPaintOperation *op);
 void                    _clutter_paint_operation_paint_primitive        (const ClutterPaintOperation *op);
 
-void                    _clutter_paint_node_init_types                  (void);
+void                    clutter_paint_node_init_types                   (ClutterBackend *clutter_backend);
 gpointer                _clutter_paint_node_create                      (GType gtype);
 
 ClutterPaintNode *      _clutter_transform_node_new                     (const graphene_matrix_t     *matrix);
diff --git a/clutter/clutter/clutter-paint-nodes.c b/clutter/clutter/clutter-paint-nodes.c
index 8ca509988..abf06450d 100644
--- a/clutter/clutter/clutter-paint-nodes.c
+++ b/clutter/clutter/clutter-paint-nodes.c
@@ -51,30 +51,30 @@ static CoglPipeline *default_color_pipeline   = NULL;
 static CoglPipeline *default_texture_pipeline = NULL;
 
 /*< private >
- * _clutter_paint_node_init_types:
+ * clutter_paint_node_init_types:
  *
  * Initializes the required types for ClutterPaintNode subclasses
  */
 void
-_clutter_paint_node_init_types (void)
+clutter_paint_node_init_types (ClutterBackend *clutter_backend)
 {
-  CoglContext *ctx;
+  CoglContext *cogl_context;
   CoglColor cogl_color;
   GType node_type G_GNUC_UNUSED;
 
   if (G_LIKELY (default_color_pipeline != NULL))
     return;
 
-  ctx = clutter_backend_get_cogl_context (clutter_get_default_backend ());
+  cogl_context = clutter_backend_get_cogl_context (clutter_backend);
 
   node_type = clutter_paint_node_get_type ();
 
   cogl_color_init_from_4f (&cogl_color, 1.0, 1.0, 1.0, 1.0);
 
-  default_color_pipeline = cogl_pipeline_new (ctx);
+  default_color_pipeline = cogl_pipeline_new (cogl_context);
   cogl_pipeline_set_color (default_color_pipeline, &cogl_color);
 
-  default_texture_pipeline = cogl_pipeline_new (ctx);
+  default_texture_pipeline = cogl_pipeline_new (cogl_context);
   cogl_pipeline_set_layer_null_texture (default_texture_pipeline, 0);
   cogl_pipeline_set_color (default_texture_pipeline, &cogl_color);
   cogl_pipeline_set_layer_wrap_mode (default_texture_pipeline, 0,
@@ -484,9 +484,9 @@ clutter_pipeline_node_draw (ClutterPaintNode    *node,
           break;
 
         case PAINT_OP_PRIMITIVE:
-          cogl_framebuffer_draw_primitive (fb,
-                                           pnode->pipeline,
-                                           op->op.primitive);
+          cogl_primitive_draw (op->op.primitive,
+                               fb,
+                               pnode->pipeline);
           break;
         }
     }
@@ -1467,9 +1467,9 @@ clutter_layer_node_post_draw (ClutterPaintNode    *node,
           break;
 
         case PAINT_OP_PRIMITIVE:
-          cogl_framebuffer_draw_primitive (fb,
-                                           lnode->pipeline,
-                                           op->op.primitive);
+          cogl_primitive_draw (op->op.primitive,
+                               fb,
+                               lnode->pipeline);
           break;
         }
     }
diff --git a/clutter/clutter/clutter-pan-action.c b/clutter/clutter/clutter-pan-action.c
index 5ad82ff6f..5521121ce 100644
--- a/clutter/clutter/clutter-pan-action.c
+++ b/clutter/clutter/clutter-pan-action.c
@@ -348,25 +348,6 @@ gesture_end (ClutterGestureAction *gesture,
     }
 }
 
-static gboolean
-clutter_pan_action_real_pan (ClutterPanAction *self,
-                             ClutterActor     *actor,
-                             gboolean          is_interpolated)
-{
-  gfloat dx, dy;
-  graphene_matrix_t transform;
-  graphene_matrix_t translate;
-
-  clutter_pan_action_get_constrained_motion_delta (self, 0, &dx, &dy);
-
-  clutter_actor_get_child_transform (actor, &transform);
-  graphene_matrix_init_translate (&translate,
-                                  &GRAPHENE_POINT3D_INIT (dx, dy, 0.0f));
-  graphene_matrix_multiply (&translate, &transform, &transform);
-  clutter_actor_set_child_transform (actor, &transform);
-  return TRUE;
-}
-
 static void
 clutter_pan_action_set_property (GObject      *gobject,
                                  guint         prop_id,
@@ -483,8 +464,6 @@ clutter_pan_action_class_init (ClutterPanActionClass *klass)
   ClutterGestureActionClass *gesture_class =
       CLUTTER_GESTURE_ACTION_CLASS (klass);
 
-  klass->pan = clutter_pan_action_real_pan;
-
   gesture_class->gesture_prepare = gesture_prepare;
   gesture_class->gesture_begin = gesture_begin;
   gesture_class->gesture_progress = gesture_progress;
@@ -586,8 +565,7 @@ clutter_pan_action_class_init (ClutterPanActionClass *klass)
     g_signal_new (I_("pan"),
                   G_TYPE_FROM_CLASS (klass),
                   G_SIGNAL_RUN_LAST,
-                  G_STRUCT_OFFSET (ClutterPanActionClass, pan),
-                  _clutter_boolean_continue_accumulator, NULL,
+                  0, g_signal_accumulator_true_handled, NULL,
                   _clutter_marshal_BOOLEAN__OBJECT_BOOLEAN,
                   G_TYPE_BOOLEAN, 2,
                   CLUTTER_TYPE_ACTOR,
diff --git a/clutter/clutter/clutter-pan-action.h b/clutter/clutter/clutter-pan-action.h
index 64115b69b..c74014792 100644
--- a/clutter/clutter/clutter-pan-action.h
+++ b/clutter/clutter/clutter-pan-action.h
@@ -84,9 +84,6 @@ struct _ClutterPanActionClass
   ClutterGestureActionClass parent_class;
 
   /*< public >*/
-  gboolean (* pan)               (ClutterPanAction    *action,
-                                  ClutterActor        *actor,
-                                  gboolean             is_interpolated);
   void     (* pan_stopped)       (ClutterPanAction    *action,
                                   ClutterActor        *actor);
 
diff --git a/clutter/clutter/clutter-pick-context.c b/clutter/clutter/clutter-pick-context.c
index 2f054d318..28e095bfa 100644
--- a/clutter/clutter/clutter-pick-context.c
+++ b/clutter/clutter/clutter-pick-context.c
@@ -118,6 +118,20 @@ clutter_pick_context_log_pick (ClutterPickContext    *pick_context,
   clutter_pick_stack_log_pick (pick_context->pick_stack, box, actor);
 }
 
+/**
+ * clutter_pick_context_log_overlap:
+ * @pick_context: a #ClutterPickContext
+ * @actor: a #ClutterActor
+ *
+ * Logs an overlapping actor into the pick stack.
+ */
+void
+clutter_pick_context_log_overlap (ClutterPickContext *pick_context,
+                                  ClutterActor       *actor)
+{
+  clutter_pick_stack_log_overlap (pick_context->pick_stack, actor);
+}
+
 /**
  * clutter_pick_context_push_clip:
  * @pick_context: a #ClutterPickContext
diff --git a/clutter/clutter/clutter-pick-context.h b/clutter/clutter/clutter-pick-context.h
index 5792be6b5..730db1a0a 100644
--- a/clutter/clutter/clutter-pick-context.h
+++ b/clutter/clutter/clutter-pick-context.h
@@ -50,6 +50,9 @@ CLUTTER_EXPORT
 void clutter_pick_context_log_pick (ClutterPickContext    *pick_context,
                                     const ClutterActorBox *box,
                                     ClutterActor          *actor);
+CLUTTER_EXPORT
+void clutter_pick_context_log_overlap (ClutterPickContext *pick_context,
+                                       ClutterActor       *actor);
 
 CLUTTER_EXPORT
 void clutter_pick_context_push_clip (ClutterPickContext    *pick_context,
diff --git a/clutter/clutter/clutter-pick-stack-private.h b/clutter/clutter/clutter-pick-stack-private.h
index 0523fcafe..9bcf5dd82 100644
--- a/clutter/clutter/clutter-pick-stack-private.h
+++ b/clutter/clutter/clutter-pick-stack-private.h
@@ -42,6 +42,8 @@ void clutter_pick_stack_seal (ClutterPickStack *pick_stack);
 void clutter_pick_stack_log_pick (ClutterPickStack      *pick_stack,
                                   const ClutterActorBox *box,
                                   ClutterActor          *actor);
+void clutter_pick_stack_log_overlap (ClutterPickStack *pick_stack,
+                                     ClutterActor     *actor);
 
 void clutter_pick_stack_push_clip (ClutterPickStack      *pick_stack,
                                    const ClutterActorBox *box);
@@ -57,9 +59,10 @@ void clutter_pick_stack_get_transform (ClutterPickStack  *pick_stack,
 void clutter_pick_stack_pop_transform (ClutterPickStack *pick_stack);
 
 ClutterActor *
-clutter_pick_stack_search_actor (ClutterPickStack         *pick_stack,
-                                 const graphene_point3d_t *point,
-                                 const graphene_ray_t     *ray);
+clutter_pick_stack_search_actor (ClutterPickStack          *pick_stack,
+                                 const graphene_point3d_t  *point,
+                                 const graphene_ray_t      *ray,
+                                 cairo_region_t           **clear_area);
 
 G_DEFINE_AUTOPTR_CLEANUP_FUNC (ClutterPickStack, clutter_pick_stack_unref)
 
diff --git a/clutter/clutter/clutter-pick-stack.c b/clutter/clutter/clutter-pick-stack.c
index 3e56ad704..c7d8a71b6 100644
--- a/clutter/clutter/clutter-pick-stack.c
+++ b/clutter/clutter/clutter-pick-stack.c
@@ -32,6 +32,7 @@ typedef struct
   Record base;
   ClutterActor *actor;
   int clip_index;
+  gboolean is_overlap;
 } PickRecord;
 
 typedef struct
@@ -342,9 +343,10 @@ clutter_pick_stack_log_pick (ClutterPickStack       *pick_stack,
 
   g_assert (!pick_stack->sealed);
 
+  rec.is_overlap = FALSE;
   rec.actor = actor;
   rec.clip_index = pick_stack->current_clip_stack_top;
-    rec.base.rect = *box;
+  rec.base.rect = *box;
   rec.base.projected = FALSE;
   rec.base.matrix_entry = cogl_matrix_stack_get_entry (pick_stack->matrix_stack);
   cogl_matrix_entry_ref (rec.base.matrix_entry);
@@ -352,6 +354,21 @@ clutter_pick_stack_log_pick (ClutterPickStack       *pick_stack,
   g_array_append_val (pick_stack->vertices_stack, rec);
 }
 
+void
+clutter_pick_stack_log_overlap (ClutterPickStack *pick_stack,
+                                ClutterActor     *actor)
+{
+  PickRecord rec = { 0 };
+
+  g_assert (!pick_stack->sealed);
+
+  rec.is_overlap = TRUE;
+  rec.actor = actor;
+  rec.clip_index = pick_stack->current_clip_stack_top;
+
+  g_array_append_val (pick_stack->vertices_stack, rec);
+}
+
 void
 clutter_pick_stack_push_clip (ClutterPickStack      *pick_stack,
                               const ClutterActorBox *box)
@@ -412,10 +429,82 @@ clutter_pick_stack_pop_transform (ClutterPickStack *pick_stack)
   cogl_matrix_stack_pop (pick_stack->matrix_stack);
 }
 
+static gboolean
+get_verts_rectangle (graphene_point3d_t     verts[4],
+                     cairo_rectangle_int_t *rect)
+{
+  if (verts[0].x != verts[2].x ||
+      verts[0].y != verts[1].y ||
+      verts[3].x != verts[1].x ||
+      verts[3].y != verts[2].y ||
+      verts[0].x > verts[3].x ||
+      verts[0].y > verts[3].y)
+    return FALSE;
+
+  *rect = (cairo_rectangle_int_t) {
+    .x = ceilf (verts[0].x),
+    .y = ceilf (verts[0].y),
+    .width = floor (verts[1].x - ceilf (verts[0].x)),
+    .height = floor (verts[2].y - ceilf (verts[0].y)),
+  };
+
+  return TRUE;
+}
+
+static void
+calculate_clear_area (ClutterPickStack  *pick_stack,
+                      int                elem,
+                      ClutterActor      *actor,
+                      cairo_region_t   **clear_area)
+{
+  cairo_region_t *area = NULL;
+  graphene_point3d_t verts[4];
+  cairo_rectangle_int_t rect;
+  int i;
+
+  clutter_actor_get_abs_allocation_vertices (actor,
+                                             (graphene_point3d_t *) &verts);
+  if (!get_verts_rectangle (verts, &rect))
+    {
+      if (clear_area)
+        *clear_area = NULL;
+      return;
+    }
+
+  area = cairo_region_create_rectangle (&rect);
+
+  for (i = elem + 1; i < pick_stack->vertices_stack->len; i++)
+    {
+      PickRecord *rec =
+        &g_array_index (pick_stack->vertices_stack, PickRecord, i);
+      ClutterActorBox paint_box;
+
+      if (!rec->is_overlap &&
+	  (rec->base.rect.x1 == rec->base.rect.x2 ||
+	   rec->base.rect.y1 == rec->base.rect.y2))
+        continue;
+
+      clutter_actor_get_paint_box (rec->actor, &paint_box);
+      cairo_region_subtract_rectangle (area,
+                                       &(cairo_rectangle_int_t) {
+                                         .x = paint_box.x1,
+                                         .y = paint_box.y1,
+                                         .width = paint_box.x2 - paint_box.x1,
+                                         .height = paint_box.y2 - paint_box.y1,
+                                       });
+    }
+
+  if (clear_area)
+    *clear_area = g_steal_pointer (&area);
+
+  g_clear_pointer (&area, cairo_region_destroy);
+}
+
 ClutterActor *
-clutter_pick_stack_search_actor (ClutterPickStack         *pick_stack,
-                                 const graphene_point3d_t *point,
-                                 const graphene_ray_t     *ray)
+clutter_pick_stack_search_actor (ClutterPickStack          *pick_stack,
+                                 const graphene_point3d_t  *point,
+                                 const graphene_ray_t      *ray,
+                                 cairo_region_t           **clear_area)
 {
   int i;
 
@@ -428,8 +517,13 @@ clutter_pick_stack_search_actor (ClutterPickStack         *pick_stack,
       PickRecord *rec =
         &g_array_index (pick_stack->vertices_stack, PickRecord, i);
 
-      if (rec->actor && ray_intersects_record (pick_stack, rec, point, ray))
-        return rec->actor;
+      if (!rec->is_overlap && rec->actor &&
+          ray_intersects_record (pick_stack, rec, point, ray))
+        {
+          if (clear_area)
+            calculate_clear_area (pick_stack, i, rec->actor, clear_area);
+          return rec->actor;
+        }
     }
 
   return NULL;
diff --git a/clutter/clutter/clutter-private.h b/clutter/clutter/clutter-private.h
index ccee4c4b6..377b31879 100644
--- a/clutter/clutter/clutter-private.h
+++ b/clutter/clutter/clutter-private.h
@@ -127,17 +127,6 @@ struct _ClutterMainContext
    * ordered from least recently added to most recently added */
   GList *event_filters;
 
-  /* default FPS; this is only used if we cannot sync to vblank */
-  guint frame_rate;
-
-  /* fb bit masks for col<->id mapping in picking */
-  gint fb_r_mask;
-  gint fb_g_mask;
-  gint fb_b_mask;
-  gint fb_r_mask_used;
-  gint fb_g_mask_used;
-  gint fb_b_mask_used;
-
   CoglPangoFontMap *font_map;   /* Global font map */
 
   /* stack of #ClutterEvent */
@@ -154,8 +143,6 @@ struct _ClutterMainContext
 
   /* boolean flags */
   guint is_initialized          : 1;
-  guint defer_display_setup     : 1;
-  guint options_parsed          : 1;
   guint show_fps                : 1;
 };
 
@@ -177,7 +164,8 @@ CLUTTER_EXPORT
 gboolean                _clutter_context_is_initialized                 (void);
 gboolean                _clutter_context_get_show_fps                   (void);
 
-gboolean      _clutter_feature_init (GError **error);
+gboolean clutter_feature_init (ClutterMainContext  *clutter_context,
+                               GError             **error);
 
 /* Diagnostic mode */
 gboolean        _clutter_diagnostic_enabled     (void);
diff --git a/clutter/clutter/clutter-rotate-action.c b/clutter/clutter/clutter-rotate-action.c
index 7a21607d5..21b1981e2 100644
--- a/clutter/clutter/clutter-rotate-action.c
+++ b/clutter/clutter/clutter-rotate-action.c
@@ -63,18 +63,6 @@ static guint rotate_signals[LAST_SIGNAL] = { 0, };
 
 G_DEFINE_TYPE_WITH_PRIVATE (ClutterRotateAction, clutter_rotate_action, CLUTTER_TYPE_GESTURE_ACTION)
 
-static gboolean
-clutter_rotate_action_real_rotate (ClutterRotateAction *action,
-                                   ClutterActor        *actor,
-                                   gdouble              angle)
-{
-  clutter_actor_set_rotation_angle (actor,
-                                    CLUTTER_Z_AXIS,
-                                    action->priv->initial_rotation + angle);
-
-  return TRUE;
-}
-
 static gboolean
 clutter_rotate_action_gesture_begin (ClutterGestureAction  *action,
                                      ClutterActor          *actor)
@@ -187,8 +175,6 @@ clutter_rotate_action_class_init (ClutterRotateActionClass *klass)
   GObjectClass *object_class =
     G_OBJECT_CLASS (klass);
 
-  klass->rotate = clutter_rotate_action_real_rotate;
-
   object_class->constructed = clutter_rotate_action_constructed;
 
   gesture_class->gesture_begin = clutter_rotate_action_gesture_begin;
@@ -215,8 +201,7 @@ clutter_rotate_action_class_init (ClutterRotateActionClass *klass)
     g_signal_new (I_("rotate"),
                   G_TYPE_FROM_CLASS (klass),
                   G_SIGNAL_RUN_LAST,
-                  G_STRUCT_OFFSET (ClutterRotateActionClass, rotate),
-                  _clutter_boolean_continue_accumulator, NULL,
+                  0, g_signal_accumulator_true_handled, NULL,
                   _clutter_marshal_BOOLEAN__OBJECT_DOUBLE,
                   G_TYPE_BOOLEAN, 2,
                   CLUTTER_TYPE_ACTOR,
diff --git a/clutter/clutter/clutter-rotate-action.h b/clutter/clutter/clutter-rotate-action.h
index faa240e6c..f393a21c0 100644
--- a/clutter/clutter/clutter-rotate-action.h
+++ b/clutter/clutter/clutter-rotate-action.h
@@ -74,12 +74,6 @@ struct _ClutterRotateActionClass
   /*< private >*/
   ClutterGestureActionClass parent_class;
 
-  /*< public >*/
-  gboolean (* rotate)  (ClutterRotateAction *action,
-                        ClutterActor        *actor,
-                        gdouble              angle);
-
-  /*< private >*/
   void (* _clutter_rotate_action1) (void);
   void (* _clutter_rotate_action2) (void);
   void (* _clutter_rotate_action3) (void);
diff --git a/clutter/clutter/clutter-stage-private.h b/clutter/clutter/clutter-stage-private.h
index 690a360fa..ac8e51517 100644
--- a/clutter/clutter/clutter-stage-private.h
+++ b/clutter/clutter/clutter-stage-private.h
@@ -31,6 +31,13 @@
 
 G_BEGIN_DECLS
 
+typedef enum
+{
+  CLUTTER_DEVICE_UPDATE_NONE = 0,
+  CLUTTER_DEVICE_UPDATE_EMIT_CROSSING = 1 << 0,
+  CLUTTER_DEVICE_UPDATE_IGNORE_CACHE = 1 << 1,
+} ClutterDeviceUpdateFlags;
+
 /* stage */
 ClutterStageWindow *_clutter_stage_get_default_window    (void);
 
@@ -81,11 +88,6 @@ void     _clutter_stage_process_queued_events             (ClutterStage *stage);
 void     _clutter_stage_update_input_devices              (ClutterStage *stage);
 gboolean _clutter_stage_has_full_redraw_queued            (ClutterStage *stage);
 
-ClutterActor *_clutter_stage_do_pick (ClutterStage    *stage,
-                                      float            x,
-                                      float            y,
-                                      ClutterPickMode  mode);
-
 ClutterPaintVolume *_clutter_stage_paint_volume_stack_allocate (ClutterStage *stage);
 void                _clutter_stage_paint_volume_stack_free_all (ClutterStage *stage);
 
@@ -134,11 +136,18 @@ void clutter_stage_update_device_entry (ClutterStage         *self,
                                         ClutterInputDevice   *device,
                                         ClutterEventSequence *sequence,
                                         graphene_point_t      coords,
-                                        ClutterActor         *actor);
+                                        ClutterActor         *actor,
+                                        cairo_region_t       *clear_area);
 
 void clutter_stage_remove_device_entry (ClutterStage         *self,
                                         ClutterInputDevice   *device,
                                         ClutterEventSequence *sequence);
+ClutterActor * clutter_stage_pick_and_update_device (ClutterStage             *stage,
+                                                     ClutterInputDevice       *device,
+                                                     ClutterEventSequence     *sequence,
+                                                     ClutterDeviceUpdateFlags  flags,
+                                                     graphene_point_t          point,
+                                                     uint32_t                  time_ms);
 
 G_END_DECLS
 
diff --git a/clutter/clutter/clutter-stage-view.c b/clutter/clutter/clutter-stage-view.c
index 9b7345983..ea7f57248 100644
--- a/clutter/clutter/clutter-stage-view.c
+++ b/clutter/clutter/clutter-stage-view.c
@@ -1146,7 +1146,6 @@ end_frame_timing_measurement (ClutterStageView *view)
 static ClutterFrameResult
 handle_frame_clock_frame (ClutterFrameClock *frame_clock,
                           int64_t            frame_count,
-                          int64_t            time_us,
                           gpointer           user_data)
 {
   ClutterStageView *view = user_data;
diff --git a/clutter/clutter/clutter-stage.c b/clutter/clutter/clutter-stage.c
index ae920bee3..03a957065 100644
--- a/clutter/clutter/clutter-stage.c
+++ b/clutter/clutter/clutter-stage.c
@@ -28,14 +28,6 @@
  * #ClutterStage is a top level 'window' on which child actors are placed
  * and manipulated.
  *
- * Backends might provide support for multiple stages. The support for this
- * feature can be checked at run-time using the clutter_feature_available()
- * function and the %CLUTTER_FEATURE_STAGE_MULTIPLE flag. If the backend used
- * supports multiple stages, new #ClutterStage instances can be created
- * using clutter_stage_new(). These stages must be managed by the developer
- * using clutter_actor_destroy(), which will take care of destroying all the
- * actors contained inside them.
- *
  * #ClutterStage is a proxy actor, wrapping the backend-specific implementation
  * (a #StageWindow) of the windowing system. It is possible to subclass
  * #ClutterStage, as long as every overridden virtual function chains up to the
@@ -104,6 +96,7 @@ typedef struct _PointerDeviceEntry
   ClutterEventSequence *sequence;
   graphene_point_t coords;
   ClutterActor *current_actor;
+  cairo_region_t *clear_area;
 } PointerDeviceEntry;
 
 struct _ClutterStagePrivate
@@ -136,7 +129,6 @@ struct _ClutterStagePrivate
   GHashTable *touch_sequences;
 
   guint throttle_motion_events : 1;
-  guint min_size_changed       : 1;
   guint motion_events_enabled  : 1;
   guint actor_needs_immediate_relayout : 1;
 };
@@ -281,6 +273,7 @@ clutter_stage_allocate (ClutterActor           *self,
   float new_width, new_height;
   float width, height;
   cairo_rectangle_int_t window_size;
+  ClutterActorBox children_box;
   ClutterLayoutManager *layout_manager = clutter_actor_get_layout_manager (self);
 
   if (priv->impl == NULL)
@@ -292,85 +285,26 @@ clutter_stage_allocate (ClutterActor           *self,
   /* the current Stage implementation size */
   _clutter_stage_window_get_geometry (priv->impl, &window_size);
 
-  /* if the stage is fixed size (for instance, it's using a EGL framebuffer)
-   * then we simply ignore any allocation request and override the
-   * allocation chain - because we cannot forcibly change the size of the
-   * stage window.
-   */
-  if (!clutter_feature_available (CLUTTER_FEATURE_STAGE_STATIC))
-    {
-      ClutterActorBox children_box;
+  children_box.x1 = children_box.y1 = 0.f;
+  children_box.x2 = box->x2 - box->x1;
+  children_box.y2 = box->y2 - box->y1;
 
-      children_box.x1 = children_box.y1 = 0.f;
-      children_box.x2 = box->x2 - box->x1;
-      children_box.y2 = box->y2 - box->y1;
+  CLUTTER_NOTE (LAYOUT,
+                "Following allocation to %.2fx%.2f",
+                width, height);
 
-      CLUTTER_NOTE (LAYOUT,
-                    "Following allocation to %.2fx%.2f",
-                    width, height);
+  clutter_actor_set_allocation (self, box);
 
-      clutter_actor_set_allocation (self, box);
+  clutter_layout_manager_allocate (layout_manager,
+                                   CLUTTER_CONTAINER (self),
+                                   &children_box);
 
-      clutter_layout_manager_allocate (layout_manager,
-                                       CLUTTER_CONTAINER (self),
-                                       &children_box);
-
-      /* Ensure the window is sized correctly */
-      if (priv->min_size_changed)
-        {
-          gfloat min_width, min_height;
-          gboolean min_width_set, min_height_set;
-
-          g_object_get (G_OBJECT (self),
-                        "min-width", &min_width,
-                        "min-width-set", &min_width_set,
-                        "min-height", &min_height,
-                        "min-height-set", &min_height_set,
-                        NULL);
-
-          if (!min_width_set)
-            min_width = 1;
-          if (!min_height_set)
-            min_height = 1;
-
-          if (width < min_width)
-            width = min_width;
-          if (height < min_height)
-            height = min_height;
-
-          priv->min_size_changed = FALSE;
-        }
-
-      if (window_size.width != CLUTTER_NEARBYINT (width) ||
-          window_size.height != CLUTTER_NEARBYINT (height))
-        {
-          _clutter_stage_window_resize (priv->impl,
-                                        CLUTTER_NEARBYINT (width),
-                                        CLUTTER_NEARBYINT (height));
-        }
-    }
-  else
+  if (window_size.width != CLUTTER_NEARBYINT (width) ||
+      window_size.height != CLUTTER_NEARBYINT (height))
     {
-      ClutterActorBox override = { 0, };
-
-      /* override the passed allocation */
-      override.x1 = 0;
-      override.y1 = 0;
-      override.x2 = window_size.width;
-      override.y2 = window_size.height;
-
-      CLUTTER_NOTE (LAYOUT,
-                    "Overriding original allocation of %.2fx%.2f "
-                    "with %.2fx%.2f",
-                    width, height,
-                    override.x2, override.y2);
-
-      /* and store the overridden allocation */
-      clutter_actor_set_allocation (self, &override);
-
-      clutter_layout_manager_allocate (layout_manager,
-                                       CLUTTER_CONTAINER (self),
-                                       &override);
+      _clutter_stage_window_resize (priv->impl,
+                                    CLUTTER_NEARBYINT (width),
+                                    CLUTTER_NEARBYINT (height));
     }
 
   /* set the viewport to the new allocation */
@@ -746,7 +680,6 @@ _clutter_stage_process_queued_events (ClutterStage *stage)
       ClutterEvent *next_event;
       ClutterInputDevice *device;
       ClutterInputDevice *next_device;
-      ClutterInputDeviceType device_type;
       gboolean check_device = FALSE;
 
       event = l->data;
@@ -762,16 +695,8 @@ _clutter_stage_process_queued_events (ClutterStage *stage)
       if (device != NULL && next_device != NULL)
         check_device = TRUE;
 
-      device_type = clutter_input_device_get_device_type (device);
-
-      /* Skip consecutive motion events coming from the same device,
-       * except those of tablet tools, since users of these events
-       * want no precision loss.
-       */
-      if (priv->throttle_motion_events && next_event != NULL &&
-          device_type != CLUTTER_TABLET_DEVICE &&
-          device_type != CLUTTER_PEN_DEVICE &&
-          device_type != CLUTTER_ERASER_DEVICE)
+      /* Skip consecutive motion events coming from the same device. */
+      if (priv->throttle_motion_events && next_event != NULL)
         {
           if (event->type == CLUTTER_MOTION &&
               (next_event->type == CLUTTER_MOTION ||
@@ -977,22 +902,17 @@ clutter_stage_update_devices (ClutterStage *stage,
     {
       ClutterInputDevice *device = l->data;
       PointerDeviceEntry *entry = NULL;
-      ClutterActor *new_actor;
 
       entry = g_hash_table_lookup (priv->pointer_devices, device);
       g_assert (entry != NULL);
 
-      new_actor = _clutter_stage_do_pick (stage,
-                                          entry->coords.x,
-                                          entry->coords.y,
-                                          CLUTTER_PICK_REACTIVE);
-
-      clutter_stage_update_device (stage,
-                                   device, NULL,
-                                   entry->coords,
-                                   CLUTTER_CURRENT_TIME,
-                                   new_actor,
-                                   TRUE);
+      clutter_stage_pick_and_update_device (stage,
+                                            device,
+                                            NULL,
+                                            CLUTTER_DEVICE_UPDATE_IGNORE_CACHE |
+                                            CLUTTER_DEVICE_UPDATE_EMIT_CROSSING,
+                                            entry->coords,
+                                            CLUTTER_CURRENT_TIME);
     }
 }
 
@@ -1066,11 +986,12 @@ setup_ray_for_coordinates (ClutterStage       *stage,
 }
 
 static ClutterActor *
-_clutter_stage_do_pick_on_view (ClutterStage     *stage,
-                                float             x,
-                                float             y,
-                                ClutterPickMode   mode,
-                                ClutterStageView *view)
+_clutter_stage_do_pick_on_view (ClutterStage      *stage,
+                                float              x,
+                                float              y,
+                                ClutterPickMode    mode,
+                                ClutterStageView  *view,
+                                cairo_region_t   **clear_area)
 {
   g_autoptr (ClutterPickStack) pick_stack = NULL;
   ClutterPickContext *pick_context;
@@ -1088,7 +1009,7 @@ _clutter_stage_do_pick_on_view (ClutterStage     *stage,
   pick_stack = clutter_pick_context_steal_stack (pick_context);
   clutter_pick_context_destroy (pick_context);
 
-  actor = clutter_pick_stack_search_actor (pick_stack, &p, &ray);
+  actor = clutter_pick_stack_search_actor (pick_stack, &p, &ray, clear_area);
   return actor ? actor : CLUTTER_ACTOR (stage);
 }
 
@@ -1119,11 +1040,12 @@ clutter_stage_get_view_at (ClutterStage *stage,
   return NULL;
 }
 
-ClutterActor *
-_clutter_stage_do_pick (ClutterStage   *stage,
-                        float           x,
-                        float           y,
-                        ClutterPickMode mode)
+static ClutterActor *
+_clutter_stage_do_pick (ClutterStage     *stage,
+                        float             x,
+                        float             y,
+                        ClutterPickMode   mode,
+                        cairo_region_t  **clear_area)
 {
   ClutterActor *actor = CLUTTER_ACTOR (stage);
   ClutterStagePrivate *priv = stage->priv;
@@ -1147,7 +1069,7 @@ _clutter_stage_do_pick (ClutterStage   *stage,
 
   view = clutter_stage_get_view_at (stage, x, y);
   if (view)
-    return _clutter_stage_do_pick_on_view (stage, x, y, mode, view);
+    return _clutter_stage_do_pick_on_view (stage, x, y, mode, view, clear_area);
 
   return actor;
 }
@@ -1174,25 +1096,6 @@ clutter_stage_constructed (GObject *gobject)
   /* this will take care to sinking the floating reference */
   _clutter_stage_manager_add_stage (stage_manager, self);
 
-  /* if this stage has been created on a backend that does not
-   * support multiple stages then it becomes the default stage
-   * as well; any other attempt at creating a ClutterStage will
-   * fail.
-   */
-  if (!clutter_feature_available (CLUTTER_FEATURE_STAGE_MULTIPLE))
-    {
-      if (G_UNLIKELY (clutter_stage_manager_get_default_stage (stage_manager) != NULL))
-        {
-          g_error ("Unable to create another stage: the backend of "
-                   "type '%s' does not support multiple stages. Use "
-                   "clutter_stage_manager_get_default_stage() instead "
-                   "to access the stage singleton.",
-                   G_OBJECT_TYPE_NAME (clutter_get_default_backend ()));
-        }
-
-      _clutter_stage_manager_set_default_stage (stage_manager, self);
-    }
-
   G_OBJECT_CLASS (clutter_stage_parent_class)->constructed (gobject);
 }
 
@@ -1282,6 +1185,9 @@ clutter_stage_dispose (GObject *object)
   stage_manager = clutter_stage_manager_get_default ();
   _clutter_stage_manager_remove_stage (stage_manager, stage);
 
+  g_hash_table_remove_all (priv->pointer_devices);
+  g_hash_table_remove_all (priv->touch_sequences);
+
   G_OBJECT_CLASS (clutter_stage_parent_class)->dispose (object);
 }
 
@@ -1591,12 +1497,6 @@ clutter_stage_class_init (ClutterStageClass *klass)
   klass->deactivate = clutter_stage_real_deactivate;
 }
 
-static void
-clutter_stage_notify_min_size (ClutterStage *self)
-{
-  self->priv->min_size_changed = TRUE;
-}
-
 static void
 clutter_stage_init (ClutterStage *self)
 {
@@ -1637,7 +1537,6 @@ clutter_stage_init (ClutterStage *self)
   priv->event_queue = g_queue_new ();
 
   priv->throttle_motion_events = TRUE;
-  priv->min_size_changed = FALSE;
   priv->motion_events_enabled = TRUE;
 
   priv->pointer_devices =
@@ -1655,12 +1554,6 @@ clutter_stage_init (ClutterStage *self)
   clutter_actor_set_reactive (CLUTTER_ACTOR (self), TRUE);
   clutter_stage_set_title (self, g_get_prgname ());
   clutter_stage_set_key_focus (self, NULL);
-
-  g_signal_connect (self, "notify::min-width",
-                    G_CALLBACK (clutter_stage_notify_min_size), NULL);
-  g_signal_connect (self, "notify::min-height",
-                    G_CALLBACK (clutter_stage_notify_min_size), NULL);
-
   clutter_stage_set_viewport (self, geom.width, geom.height);
 
   priv->pending_queue_redraws =
@@ -2016,7 +1909,7 @@ clutter_stage_get_actor_at_pos (ClutterStage    *stage,
 {
   g_return_val_if_fail (CLUTTER_IS_STAGE (stage), NULL);
 
-  return _clutter_stage_do_pick (stage, x, y, pick_mode);
+  return _clutter_stage_do_pick (stage, x, y, pick_mode, NULL);
 }
 
 /**
@@ -2544,87 +2437,6 @@ clutter_stage_get_throttle_motion_events (ClutterStage *stage)
   return stage->priv->throttle_motion_events;
 }
 
-/**
- * clutter_stage_set_minimum_size:
- * @stage: a #ClutterStage
- * @width: width, in pixels
- * @height: height, in pixels
- *
- * Sets the minimum size for a stage window, if the default backend
- * uses #ClutterStage inside a window
- *
- * This is a convenience function, and it is equivalent to setting the
- * #ClutterActor:min-width and #ClutterActor:min-height on @stage
- *
- * If the current size of @stage is smaller than the minimum size, the
- * @stage will be resized to the new @width and @height
- *
- * Since: 1.2
- */
-void
-clutter_stage_set_minimum_size (ClutterStage *stage,
-                                guint         width,
-                                guint         height)
-{
-  g_return_if_fail (CLUTTER_IS_STAGE (stage));
-  g_return_if_fail ((width > 0) && (height > 0));
-
-  g_object_set (G_OBJECT (stage),
-                "min-width", (gfloat) width,
-                "min-height", (gfloat )height,
-                NULL);
-}
-
-/**
- * clutter_stage_get_minimum_size:
- * @stage: a #ClutterStage
- * @width: (out): return location for the minimum width, in pixels,
- *   or %NULL
- * @height: (out): return location for the minimum height, in pixels,
- *   or %NULL
- *
- * Retrieves the minimum size for a stage window as set using
- * clutter_stage_set_minimum_size().
- *
- * The returned size may not correspond to the actual minimum size and
- * it is specific to the #ClutterStage implementation inside the
- * Clutter backend
- *
- * Since: 1.2
- */
-void
-clutter_stage_get_minimum_size (ClutterStage *stage,
-                                guint        *width_p,
-                                guint        *height_p)
-{
-  gfloat width, height;
-  gboolean width_set, height_set;
-
-  g_return_if_fail (CLUTTER_IS_STAGE (stage));
-
-  g_object_get (G_OBJECT (stage),
-                "min-width", &width,
-                "min-width-set", &width_set,
-                "min-height", &height,
-                "min-height-set", &height_set,
-                NULL);
-
-  /* if not width or height have been set, then the Stage
-   * minimum size is defined to be 1x1
-   */
-  if (!width_set)
-    width = 1;
-
-  if (!height_set)
-    height = 1;
-
-  if (width_p)
-    *width_p = (guint) width;
-
-  if (height_p)
-    *height_p = (guint) height;
-}
-
 /**
  * clutter_stage_schedule_update:
  * @stage: a #ClutterStage actor
@@ -3429,22 +3241,16 @@ on_device_actor_reactive_changed (ClutterActor       *actor,
                                   PointerDeviceEntry *entry)
 {
   ClutterStage *self = entry->stage;
-  ClutterActor *new_device_actor;
 
   g_assert (!clutter_actor_get_reactive (actor));
 
-  new_device_actor =
-    _clutter_stage_do_pick (self,
-                            entry->coords.x,
-                            entry->coords.y,
-                            CLUTTER_PICK_REACTIVE);
-
-  clutter_stage_update_device (self,
-                               entry->device, entry->sequence,
-                               entry->coords,
-                               CLUTTER_CURRENT_TIME,
-                               new_device_actor,
-                               TRUE);
+  clutter_stage_pick_and_update_device (self,
+                                        entry->device,
+                                        entry->sequence,
+                                        CLUTTER_DEVICE_UPDATE_IGNORE_CACHE |
+                                        CLUTTER_DEVICE_UPDATE_EMIT_CROSSING,
+                                        entry->coords,
+                                        CLUTTER_CURRENT_TIME);
 }
 
 static void
@@ -3454,11 +3260,10 @@ on_device_actor_destroyed (ClutterActor       *actor,
   /* Simply unset the current_actor pointer here, there's no need to
    * unset has_pointer or to disconnect any signals because the actor
    * is gone anyway.
-   * Also, as soon as the next repaint happens, a repick should be triggered
-   * and the PointerDeviceEntry will get updated again, so no need to
-   * trigger a repick here.
    */
   entry->current_actor = NULL;
+  g_clear_pointer (&entry->clear_area, cairo_region_destroy);
+  clutter_stage_repick_device (entry->stage, entry->device);
 }
 
 static void
@@ -3478,6 +3283,8 @@ free_pointer_device_entry (PointerDeviceEntry *entry)
       _clutter_actor_set_has_pointer (actor, FALSE);
    }
 
+  g_clear_pointer (&entry->clear_area, cairo_region_destroy);
+
   g_free (entry);
 }
 
@@ -3486,7 +3293,8 @@ clutter_stage_update_device_entry (ClutterStage         *self,
                                    ClutterInputDevice   *device,
                                    ClutterEventSequence *sequence,
                                    graphene_point_t      coords,
-                                   ClutterActor         *actor)
+                                   ClutterActor         *actor,
+                                   cairo_region_t       *clear_area)
 {
   ClutterStagePrivate *priv = self->priv;
   PointerDeviceEntry *entry = NULL;
@@ -3542,6 +3350,10 @@ clutter_stage_update_device_entry (ClutterStage         *self,
           _clutter_actor_set_has_pointer (actor, TRUE);
         }
     }
+
+  g_clear_pointer (&entry->clear_area, cairo_region_destroy);
+  if (clear_area)
+    entry->clear_area = cairo_region_reference (clear_area);
 }
 
 void
@@ -3618,3 +3430,198 @@ clutter_stage_get_device_coords (ClutterStage         *stage,
   if (entry && coords)
     *coords = entry->coords;
 }
+
+static void
+clutter_stage_set_device_coords (ClutterStage         *stage,
+                                 ClutterInputDevice   *device,
+                                 ClutterEventSequence *sequence,
+                                 graphene_point_t      coords)
+{
+  ClutterStagePrivate *priv = stage->priv;
+  PointerDeviceEntry *entry = NULL;
+
+  if (sequence != NULL)
+    entry = g_hash_table_lookup (priv->touch_sequences, sequence);
+  else
+    entry = g_hash_table_lookup (priv->pointer_devices, device);
+
+  if (entry)
+    entry->coords = coords;
+}
+
+static void
+create_crossing_event (ClutterStage         *stage,
+                       ClutterInputDevice   *device,
+                       ClutterEventSequence *sequence,
+                       ClutterEventType      event_type,
+                       ClutterActor         *source,
+                       ClutterActor         *related,
+                       graphene_point_t      coords,
+                       uint32_t              time_ms)
+{
+  ClutterEvent *event;
+
+  event = clutter_event_new (event_type);
+  event->crossing.time = time_ms;
+  event->crossing.flags = 0;
+  event->crossing.stage = stage;
+  event->crossing.source = source;
+  event->crossing.x = coords.x;
+  event->crossing.y = coords.y;
+  event->crossing.related = related;
+  event->crossing.sequence = sequence;
+  clutter_event_set_device (event, device);
+
+  /* we need to make sure that this event is processed
+   * before any other event we might have queued up until
+   * now, so we go on, and synthesize the event emission
+   * ourselves
+   */
+  if (!_clutter_event_process_filters (event))
+    _clutter_process_event (event);
+
+  clutter_event_free (event);
+}
+
+void
+clutter_stage_update_device (ClutterStage         *stage,
+                             ClutterInputDevice   *device,
+                             ClutterEventSequence *sequence,
+                             graphene_point_t      point,
+                             uint32_t              time_ms,
+                             ClutterActor         *new_actor,
+                             cairo_region_t       *clear_area,
+                             gboolean              emit_crossing)
+{
+  ClutterInputDeviceType device_type;
+  ClutterActor *old_actor;
+  gboolean device_actor_changed;
+
+  device_type = clutter_input_device_get_device_type (device);
+
+  g_assert (device_type != CLUTTER_KEYBOARD_DEVICE &&
+            device_type != CLUTTER_PAD_DEVICE);
+
+  old_actor = clutter_stage_get_device_actor (stage, device, sequence);
+  device_actor_changed = new_actor != old_actor;
+
+  clutter_stage_update_device_entry (stage,
+                                     device, sequence,
+                                     point,
+                                     new_actor,
+                                     clear_area);
+
+  if (device_actor_changed)
+    {
+      CLUTTER_NOTE (EVENT,
+                    "Updating actor under cursor (device %s, at %.2f, %.2f): %s",
+                    clutter_input_device_get_device_name (device),
+                    point.x,
+                    point.y,
+                    _clutter_actor_get_debug_name (new_actor));
+
+      if (old_actor && emit_crossing)
+        {
+          create_crossing_event (stage,
+                                 device, sequence,
+                                 CLUTTER_LEAVE,
+                                 old_actor, new_actor,
+                                 point, time_ms);
+        }
+
+      if (new_actor && emit_crossing)
+        {
+          create_crossing_event (stage,
+                                 device, sequence,
+                                 CLUTTER_ENTER,
+                                 new_actor, old_actor,
+                                 point, time_ms);
+        }
+    }
+}
+
+void
+clutter_stage_repick_device (ClutterStage       *stage,
+                             ClutterInputDevice *device)
+{
+  graphene_point_t point;
+
+  clutter_stage_get_device_coords (stage, device, NULL, &point);
+  clutter_stage_pick_and_update_device (stage,
+                                        device,
+                                        NULL,
+                                        CLUTTER_DEVICE_UPDATE_IGNORE_CACHE |
+                                        CLUTTER_DEVICE_UPDATE_EMIT_CROSSING,
+                                        point,
+                                        CLUTTER_CURRENT_TIME);
+}
+
+static gboolean
+clutter_stage_check_in_clear_area (ClutterStage         *stage,
+                                   ClutterInputDevice   *device,
+                                   ClutterEventSequence *sequence,
+                                   graphene_point_t      point)
+{
+  ClutterStagePrivate *priv = stage->priv;
+  PointerDeviceEntry *entry = NULL;
+
+  g_return_val_if_fail (CLUTTER_IS_STAGE (stage), FALSE);
+  g_return_val_if_fail (device != NULL, FALSE);
+
+  if (sequence != NULL)
+    entry = g_hash_table_lookup (priv->touch_sequences, sequence);
+  else
+    entry = g_hash_table_lookup (priv->pointer_devices, device);
+
+  if (!entry)
+    return FALSE;
+  if (!entry->clear_area)
+    return FALSE;
+
+  return cairo_region_contains_point (entry->clear_area,
+                                      point.x, point.y);
+}
+
+ClutterActor *
+clutter_stage_pick_and_update_device (ClutterStage             *stage,
+                                      ClutterInputDevice       *device,
+                                      ClutterEventSequence     *sequence,
+                                      ClutterDeviceUpdateFlags  flags,
+                                      graphene_point_t          point,
+                                      uint32_t                  time_ms)
+{
+  ClutterActor *new_actor;
+  cairo_region_t *clear_area = NULL;
+
+  if ((flags & CLUTTER_DEVICE_UPDATE_IGNORE_CACHE) == 0)
+    {
+      if (clutter_stage_check_in_clear_area (stage, device,
+                                             sequence, point))
+        {
+          clutter_stage_set_device_coords (stage, device,
+                                           sequence, point);
+          return clutter_stage_get_device_actor (stage, device, sequence);
+        }
+    }
+
+  new_actor = _clutter_stage_do_pick (stage,
+                                      point.x,
+                                      point.y,
+                                      CLUTTER_PICK_REACTIVE,
+                                      &clear_area);
+
+  /* Picking should never fail, but if it does, we bail out here */
+  g_return_val_if_fail (new_actor != NULL, NULL);
+
+  clutter_stage_update_device (stage,
+                               device, sequence,
+                               point,
+                               time_ms,
+                               new_actor,
+                               clear_area,
+                               !!(flags & CLUTTER_DEVICE_UPDATE_EMIT_CROSSING));
+
+  g_clear_pointer (&clear_area, cairo_region_destroy);
+
+  return new_actor;
+}
diff --git a/clutter/clutter/clutter-swipe-action.c b/clutter/clutter/clutter-swipe-action.c
index 2706e1d82..17cd75e5c 100644
--- a/clutter/clutter/clutter-swipe-action.c
+++ b/clutter/clutter/clutter-swipe-action.c
@@ -172,15 +172,6 @@ gesture_end (ClutterGestureAction *action,
     g_signal_emit (action, swipe_signals[SWEPT], 0, actor, direction);
 }
 
-/* XXX:2.0 remove */
-static gboolean
-clutter_swipe_action_real_swipe (ClutterSwipeAction    *action,
-                                 ClutterActor          *actor,
-                                 ClutterSwipeDirection  direction)
-{
-  return TRUE;
-}
-
 static void
 clutter_swipe_action_constructed (GObject *object)
 {
@@ -202,9 +193,6 @@ clutter_swipe_action_class_init (ClutterSwipeActionClass *klass)
   gesture_class->gesture_progress = gesture_progress;
   gesture_class->gesture_end = gesture_end;
 
-  /* XXX:2.0 remove */
-  klass->swipe = clutter_swipe_action_real_swipe;
-
   /**
    * ClutterSwipeAction::swept:
    * @action: the #ClutterSwipeAction that emitted the signal
@@ -248,8 +236,7 @@ clutter_swipe_action_class_init (ClutterSwipeActionClass *klass)
     g_signal_new (I_("swipe"),
                   G_TYPE_FROM_CLASS (klass),
                   G_SIGNAL_RUN_LAST,
-                  G_STRUCT_OFFSET (ClutterSwipeActionClass, swipe),
-                  _clutter_boolean_continue_accumulator, NULL,
+                  0, g_signal_accumulator_true_handled, NULL,
                   _clutter_marshal_BOOLEAN__OBJECT_FLAGS,
                   G_TYPE_BOOLEAN, 2,
                   CLUTTER_TYPE_ACTOR,
diff --git a/clutter/clutter/clutter-swipe-action.h b/clutter/clutter/clutter-swipe-action.h
index 1bf50c6bf..44d4766be 100644
--- a/clutter/clutter/clutter-swipe-action.h
+++ b/clutter/clutter/clutter-swipe-action.h
@@ -85,10 +85,6 @@ struct _ClutterSwipeActionClass
                    ClutterActor          *actor,
                    ClutterSwipeDirection  direction);
 
-  gboolean (* swipe) (ClutterSwipeAction    *action,
-                      ClutterActor          *actor,
-                      ClutterSwipeDirection  direction);
-
   /*< private >*/
   void (* _clutter_swipe_action1) (void);
   void (* _clutter_swipe_action2) (void);
diff --git a/clutter/clutter/clutter-text.c b/clutter/clutter/clutter-text.c
index fe28a9730..9244fc415 100644
--- a/clutter/clutter/clutter-text.c
+++ b/clutter/clutter/clutter-text.c
@@ -187,6 +187,11 @@ struct _ClutterTextPrivate
   ClutterInputContentHintFlags input_hints;
   ClutterInputContentPurpose input_purpose;
 
+  float last_click_x;
+  float last_click_y;
+  uint32_t last_click_time_ms;
+  int click_count;
+
   /* bitfields */
   guint alignment               : 2;
   guint wrap                    : 1;
@@ -2163,6 +2168,39 @@ clutter_text_select_line (ClutterText *self)
   clutter_text_set_selection (self, start_pos, end_pos);
 }
 
+static int
+clutter_text_update_click_count (ClutterText        *self,
+                                 const ClutterEvent *event)
+{
+  ClutterTextPrivate *priv = self->priv;
+  ClutterSettings *settings;
+  int double_click_time, double_click_distance;
+  uint32_t evtime;
+  float x, y;
+
+  settings = clutter_settings_get_default ();
+  clutter_event_get_coords (event, &x, &y);
+  evtime = clutter_event_get_time (event);
+
+  g_object_get (settings,
+                "double-click-distance", &double_click_distance,
+                "double-click-time", &double_click_time,
+                NULL);
+
+  if (evtime > (priv->last_click_time_ms + double_click_time) ||
+      (ABS (x - priv->last_click_x) > double_click_distance) ||
+      (ABS (y - priv->last_click_y) > double_click_distance))
+    priv->click_count = 0;
+
+  priv->last_click_time_ms = evtime;
+  priv->last_click_x = x;
+  priv->last_click_y = y;
+
+  priv->click_count = (priv->click_count % 3) + 1;
+
+  return priv->click_count;
+}
+
 static gboolean
 clutter_text_press (ClutterActor *actor,
                     ClutterEvent *event)
@@ -2219,7 +2257,9 @@ clutter_text_press (ClutterActor *actor,
        */
       if (type == CLUTTER_BUTTON_PRESS)
         {
-          gint click_count = clutter_event_get_click_count (event);
+          gint click_count;
+
+          click_count = clutter_text_update_click_count (self, event);
 
           if (click_count == 1)
             {
diff --git a/clutter/clutter/clutter-texture-content.c b/clutter/clutter/clutter-texture-content.c
index d045fdc6d..53aea4dc1 100644
--- a/clutter/clutter/clutter-texture-content.c
+++ b/clutter/clutter/clutter-texture-content.c
@@ -126,6 +126,8 @@ clutter_texture_content_new_from_texture (CoglTexture           *texture,
                                           cairo_rectangle_int_t *clip)
 {
   ClutterTextureContent *texture_content;
+  CoglContext *cogl_context =
+    clutter_backend_get_cogl_context (clutter_get_default_backend ());
 
   g_return_val_if_fail (texture != NULL, NULL);
 
@@ -134,11 +136,12 @@ clutter_texture_content_new_from_texture (CoglTexture           *texture,
   if (clip)
     {
       texture_content->texture =
-        cogl_texture_new_from_sub_texture (texture,
-                                           clip->x,
-                                           clip->y,
-                                           clip->width,
-                                           clip->height);
+        COGL_TEXTURE (cogl_sub_texture_new (cogl_context,
+                                            texture,
+                                            clip->x,
+                                            clip->y,
+                                            clip->width,
+                                            clip->height));
     }
   else
     {
diff --git a/clutter/clutter/clutter-timeline.c b/clutter/clutter/clutter-timeline.c
index 0c9fd2c1c..0f5ddaede 100644
--- a/clutter/clutter/clutter-timeline.c
+++ b/clutter/clutter/clutter-timeline.c
@@ -33,7 +33,7 @@
  * be used to update the state of the actors.
  *
  * It is important to note that #ClutterTimeline is not a generic API for
- * calling closures after an interval; each Timeline is tied into the master
+ * calling closures after an interval; each Timeline is tied into a frame
  * clock used to drive the frame cycle. If you need to schedule a closure
  * after an interval, see clutter_threads_add_timeout() instead.
  *
@@ -97,6 +97,7 @@
 #include "clutter-timeline.h"
 #include "deprecated/clutter-timeline.h"
 
+#include "clutter-actor-private.h"
 #include "clutter-debug.h"
 #include "clutter-easing.h"
 #include "clutter-enum-types.h"
@@ -162,7 +163,7 @@ struct _ClutterTimelinePrivate
   guint is_playing         : 1;
 
   /* If we've just started playing and haven't yet gotten
-   * a tick from the master clock
+   * a tick from the frame clock
    */
   guint waiting_first_tick : 1;
   guint auto_reverse       : 1;
@@ -428,7 +429,10 @@ update_frame_clock (ClutterTimeline *timeline)
   if (!stage)
     {
       if (priv->is_playing)
-        g_warning ("Timelines with detached actors are not supported");
+        g_warning ("Timelines with detached actors are not supported. "
+                   "%s in animation of duration %ums but not on stage.",
+                   _clutter_actor_get_debug_name (priv->actor),
+                   priv->duration);
       goto out;
     }
 
@@ -1880,9 +1884,11 @@ _clutter_timeline_advance (ClutterTimeline *timeline,
  * @tick_time: time of advance
  *
  * Advances @timeline based on the time passed in @tick_time. This
- * function is called by the master clock. The @timeline will use this
- * interval to emit the #ClutterTimeline::new-frame signal and
- * eventually skip frames.
+ * function is called by the frame clock and ideally passes the next
+ * presentation time in which consequences of our timeline will be visible.
+ * Otherwise an estimate using the current monotonic time is also acceptable.
+ * The @timeline will use this interval to emit the #ClutterTimeline::new-frame
+ * signal and eventually skip frames.
  */
 void
 _clutter_timeline_do_tick (ClutterTimeline *timeline,
diff --git a/clutter/clutter/clutter-zoom-action.c b/clutter/clutter/clutter-zoom-action.c
index c25b79688..4e87e2330 100644
--- a/clutter/clutter/clutter-zoom-action.c
+++ b/clutter/clutter/clutter-zoom-action.c
@@ -76,8 +76,6 @@ struct _ClutterZoomActionPrivate
 {
   ClutterStage *stage;
 
-  ClutterZoomAxis zoom_axis;
-
   ZoomPoint points[2];
 
   graphene_point_t initial_focal_point;
@@ -94,17 +92,6 @@ struct _ClutterZoomActionPrivate
   gdouble zoom_initial_distance;
 };
 
-enum
-{
-  PROP_0,
-
-  PROP_ZOOM_AXIS,
-
-  PROP_LAST
-};
-
-static GParamSpec *zoom_props[PROP_LAST] = { NULL, };
-
 enum
 {
   ZOOM,
@@ -235,89 +222,6 @@ clutter_zoom_action_gesture_cancel (ClutterGestureAction *action,
   clutter_actor_set_scale (actor, priv->initial_scale_x, priv->initial_scale_y);
 }
 
-static gboolean
-clutter_zoom_action_real_zoom (ClutterZoomAction *action,
-                               ClutterActor      *actor,
-                               graphene_point_t  *focal_point,
-                               gdouble            factor)
-{
-  ClutterZoomActionPrivate *priv = action->priv;
-  gfloat x, y, z;
-  gdouble scale_x, scale_y;
-  graphene_point3d_t out, in;
-
-  in.x = priv->transformed_focal_point.x;
-  in.y = priv->transformed_focal_point.y;
-  in.z = 0;
-
-  clutter_actor_apply_transform_to_point (actor, &in, &out);
-
-  clutter_actor_get_scale (actor, &scale_x, &scale_y);
-
-  switch (priv->zoom_axis)
-    {
-    case CLUTTER_ZOOM_BOTH:
-      clutter_actor_set_scale (actor, factor, factor);
-      break;
-
-    case CLUTTER_ZOOM_X_AXIS:
-      clutter_actor_set_scale (actor, factor, scale_y);
-      break;
-
-    case CLUTTER_ZOOM_Y_AXIS:
-      clutter_actor_set_scale (actor, scale_x, factor);
-      break;
-
-    default:
-      break;
-    }
-
-  x = priv->initial_x + priv->focal_point.x - priv->initial_focal_point.x;
-  y = priv->initial_y + priv->focal_point.y - priv->initial_focal_point.y;
-  clutter_actor_get_translation (actor, NULL, NULL, &z);
-  clutter_actor_set_translation (actor, x, y, z);
-
-  return TRUE;
-}
-
-static void
-clutter_zoom_action_set_property (GObject      *gobject,
-                                  guint         prop_id,
-                                  const GValue *value,
-                                  GParamSpec   *pspec)
-{
-  ClutterZoomAction *action = CLUTTER_ZOOM_ACTION (gobject);
-
-  switch (prop_id)
-    {
-    case PROP_ZOOM_AXIS:
-      clutter_zoom_action_set_zoom_axis (action, g_value_get_enum (value));
-      break;
-
-    default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);
-    }
-}
-
-static void
-clutter_zoom_action_get_property (GObject    *gobject,
-                                  guint       prop_id,
-                                  GValue     *value,
-                                  GParamSpec *pspec)
-{
-  ClutterZoomActionPrivate *priv = CLUTTER_ZOOM_ACTION (gobject)->priv;
-
-  switch (prop_id)
-    {
-    case PROP_ZOOM_AXIS:
-      g_value_set_enum (value, priv->zoom_axis);
-      break;
-
-    default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);
-    }
-}
-
 static void
 clutter_zoom_action_dispose (GObject *gobject)
 {
@@ -341,35 +245,12 @@ clutter_zoom_action_class_init (ClutterZoomActionClass *klass)
   GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
 
   gobject_class->constructed = clutter_zoom_action_constructed;
-  gobject_class->set_property = clutter_zoom_action_set_property;
-  gobject_class->get_property = clutter_zoom_action_get_property;
   gobject_class->dispose = clutter_zoom_action_dispose;
 
   gesture_class->gesture_begin = clutter_zoom_action_gesture_begin;
   gesture_class->gesture_progress = clutter_zoom_action_gesture_progress;
   gesture_class->gesture_cancel = clutter_zoom_action_gesture_cancel;
 
-  klass->zoom = clutter_zoom_action_real_zoom;
-
-  /**
-   * ClutterZoomAction:zoom-axis:
-   *
-   * Constraints the zooming action to the specified axis
-   *
-   * Since: 1.12
-   */
-  zoom_props[PROP_ZOOM_AXIS] =
-    g_param_spec_enum ("zoom-axis",
-                       P_("Zoom Axis"),
-                       P_("Constraints the zoom to an axis"),
-                       CLUTTER_TYPE_ZOOM_AXIS,
-                       CLUTTER_ZOOM_BOTH,
-                       CLUTTER_PARAM_READWRITE);
-
-  g_object_class_install_properties  (gobject_class,
-                                      PROP_LAST,
-                                      zoom_props);
-
   /**
    * ClutterZoomAction::zoom:
    * @action: the #ClutterZoomAction that emitted the signal
@@ -395,8 +276,7 @@ clutter_zoom_action_class_init (ClutterZoomActionClass *klass)
     g_signal_new (I_("zoom"),
                   G_TYPE_FROM_CLASS (klass),
                   G_SIGNAL_RUN_LAST,
-                  G_STRUCT_OFFSET (ClutterZoomActionClass, zoom),
-                  _clutter_boolean_continue_accumulator, NULL,
+                  0, g_signal_accumulator_true_handled, NULL,
                   _clutter_marshal_BOOLEAN__OBJECT_BOXED_DOUBLE,
                   G_TYPE_BOOLEAN, 3,
                   CLUTTER_TYPE_ACTOR,
@@ -410,7 +290,6 @@ clutter_zoom_action_init (ClutterZoomAction *self)
   ClutterGestureAction *gesture;
 
   self->priv = clutter_zoom_action_get_instance_private (self);
-  self->priv->zoom_axis = CLUTTER_ZOOM_BOTH;
 
   gesture = CLUTTER_GESTURE_ACTION (self);
   clutter_gesture_action_set_n_touch_points (gesture, 2);
@@ -431,50 +310,6 @@ clutter_zoom_action_new (void)
   return g_object_new (CLUTTER_TYPE_ZOOM_ACTION, NULL);
 }
 
-/**
- * clutter_zoom_action_set_zoom_axis:
- * @action: a #ClutterZoomAction
- * @axis: the axis to constraint the zooming to
- *
- * Restricts the zooming action to a specific axis
- *
- * Since: 1.12
- */
-void
-clutter_zoom_action_set_zoom_axis (ClutterZoomAction *action,
-                                   ClutterZoomAxis    axis)
-{
-  g_return_if_fail (CLUTTER_IS_ZOOM_ACTION (action));
-  g_return_if_fail (axis >= CLUTTER_ZOOM_X_AXIS &&
-                    axis <= CLUTTER_ZOOM_BOTH);
-
-  if (action->priv->zoom_axis == axis)
-    return;
-
-  action->priv->zoom_axis = axis;
-
-  g_object_notify_by_pspec (G_OBJECT (action), zoom_props[PROP_ZOOM_AXIS]);
-}
-
-/**
- * clutter_zoom_action_get_zoom_axis:
- * @action: a #ClutterZoomAction
- *
- * Retrieves the axis constraint set by clutter_zoom_action_set_zoom_axis()
- *
- * Return value: the axis constraint
- *
- * Since: 1.12
- */
-ClutterZoomAxis
-clutter_zoom_action_get_zoom_axis (ClutterZoomAction *action)
-{
-  g_return_val_if_fail (CLUTTER_IS_ZOOM_ACTION (action),
-                        CLUTTER_ZOOM_BOTH);
-
-  return action->priv->zoom_axis;
-}
-
 /**
  * clutter_zoom_action_get_focal_point:
  * @action: a #ClutterZoomAction
diff --git a/clutter/clutter/clutter-zoom-action.h b/clutter/clutter/clutter-zoom-action.h
index f1f7e572d..7cd944d95 100644
--- a/clutter/clutter/clutter-zoom-action.h
+++ b/clutter/clutter/clutter-zoom-action.h
@@ -76,13 +76,6 @@ struct _ClutterZoomActionClass
   /*< private >*/
   ClutterGestureActionClass parent_class;
 
-  /*< public >*/
-  gboolean (* zoom)  (ClutterZoomAction *action,
-                      ClutterActor      *actor,
-                      graphene_point_t  *focal_point,
-                      gdouble            factor);
-
-  /*< private >*/
   void (* _clutter_zoom_action1) (void);
   void (* _clutter_zoom_action2) (void);
   void (* _clutter_zoom_action3) (void);
@@ -96,12 +89,6 @@ GType clutter_zoom_action_get_type (void) G_GNUC_CONST;
 CLUTTER_EXPORT
 ClutterAction * clutter_zoom_action_new                         (void);
 
-CLUTTER_EXPORT
-void            clutter_zoom_action_set_zoom_axis               (ClutterZoomAction *action,
-                                                                 ClutterZoomAxis    axis);
-CLUTTER_EXPORT
-ClutterZoomAxis clutter_zoom_action_get_zoom_axis               (ClutterZoomAction *action);
-
 CLUTTER_EXPORT
 void            clutter_zoom_action_get_focal_point             (ClutterZoomAction *action,
                                                                  graphene_point_t  *point);
diff --git a/clutter/clutter/deprecated/clutter-container.h b/clutter/clutter/deprecated/clutter-container.h
index c1e256544..10cd9d0c0 100644
--- a/clutter/clutter/deprecated/clutter-container.h
+++ b/clutter/clutter/deprecated/clutter-container.h
@@ -52,22 +52,6 @@ CLUTTER_DEPRECATED_FOR(clutter_actor_remove_child)
 void            clutter_container_remove_actor                  (ClutterContainer *container,
                                                                  ClutterActor     *actor);
 
-CLUTTER_DEPRECATED_FOR(clutter_actor_get_children)
-GList *         clutter_container_get_children                  (ClutterContainer *container);
-
-CLUTTER_DEPRECATED_FOR(clutter_actor_set_child_above_sibling)
-void            clutter_container_raise_child                   (ClutterContainer *container,
-                                                                 ClutterActor     *actor,
-                                                                 ClutterActor     *sibling);
-
-CLUTTER_DEPRECATED_FOR(clutter_actor_set_child_below_sibling)
-void            clutter_container_lower_child                   (ClutterContainer *container,
-                                                                 ClutterActor     *actor,
-                                                                 ClutterActor     *sibling);
-
-CLUTTER_DEPRECATED
-void            clutter_container_sort_depth_order              (ClutterContainer *container);
-
 G_END_DECLS
 
 #endif /* __CLUTTER_CONTAINER_DEPRECATED_H__ */
diff --git a/cogl/cogl-pango/cogl-pango-display-list.c b/cogl/cogl-pango/cogl-pango-display-list.c
index 44db4c472..3f7dcf944 100644
--- a/cogl/cogl-pango/cogl-pango-display-list.c
+++ b/cogl/cogl-pango/cogl-pango-display-list.c
@@ -446,8 +446,9 @@ _cogl_pango_display_list_render (CoglFramebuffer *fb,
           break;
 
         case COGL_PANGO_DISPLAY_LIST_TRAPEZOID:
-          cogl_framebuffer_draw_primitive (fb, node->pipeline,
-                                           node->d.trapezoid.primitive);
+          cogl_primitive_draw (node->d.trapezoid.primitive, 
+                               fb,
+                               node->pipeline);
           break;
         }
     }
diff --git a/cogl/cogl/cogl-context-private.h b/cogl/cogl/cogl-context-private.h
index 5856f76e9..e3a463bf2 100644
--- a/cogl/cogl/cogl-context-private.h
+++ b/cogl/cogl/cogl-context-private.h
@@ -114,8 +114,6 @@ struct _CoglContext
   CoglBitmask       enable_custom_attributes_tmp;
   CoglBitmask       changed_bits_tmp;
 
-  gboolean          legacy_backface_culling_enabled;
-
   /* A few handy matrix constants */
   graphene_matrix_t identity_matrix;
   graphene_matrix_t y_flip_matrix;
@@ -162,8 +160,6 @@ struct _CoglContext
   float                 depth_range_near_cache;
   float                 depth_range_far_cache;
 
-  gboolean              legacy_depth_test_enabled;
-
   CoglBuffer       *current_buffer[COGL_BUFFER_BIND_TARGET_COUNT];
 
   /* Framebuffers */
diff --git a/cogl/cogl/cogl-context.c b/cogl/cogl/cogl-context.c
index 7ff9f050b..67bea6b8d 100644
--- a/cogl/cogl/cogl-context.c
+++ b/cogl/cogl/cogl-context.c
@@ -146,6 +146,7 @@ cogl_context_new (CoglDisplay *display,
       CoglRenderer *renderer = cogl_renderer_new ();
       if (!cogl_renderer_connect (renderer, error))
         {
+          cogl_object_unref (renderer);
           g_free (context);
           return NULL;
         }
@@ -223,8 +224,6 @@ cogl_context_new (CoglDisplay *display,
   context->current_clip_stack_valid = FALSE;
   context->current_clip_stack = NULL;
 
-  context->legacy_backface_culling_enabled = FALSE;
-
   graphene_matrix_init_identity (&context->identity_matrix);
   graphene_matrix_init_identity (&context->y_flip_matrix);
   graphene_matrix_scale (&context->y_flip_matrix, 1, -1, 1);
@@ -276,8 +275,6 @@ cogl_context_new (CoglDisplay *display,
   context->depth_range_near_cache = 0;
   context->depth_range_far_cache = 1;
 
-  context->legacy_depth_test_enabled = FALSE;
-
   context->pipeline_cache = _cogl_pipeline_cache_new ();
 
   for (i = 0; i < COGL_BUFFER_BIND_TARGET_COUNT; i++)
diff --git a/cogl/cogl/cogl-defines.h.meson b/cogl/cogl/cogl-defines.h.meson
index 4c9535239..911b0abdd 100644
--- a/cogl/cogl/cogl-defines.h.meson
+++ b/cogl/cogl/cogl-defines.h.meson
@@ -39,7 +39,6 @@
 #mesondefine COGL_HAS_GL
 #mesondefine CLUTTER_COGL_HAS_GL
 #mesondefine COGL_HAS_GLX_SUPPORT
-#mesondefine COGL_HAS_WAYLAND_EGL_SERVER_SUPPORT
 #mesondefine COGL_HAS_EGL_PLATFORM_XLIB_SUPPORT
 #mesondefine COGL_HAS_EGL_SUPPORT
 #mesondefine COGL_HAS_X11
diff --git a/cogl/cogl/cogl-framebuffer.c b/cogl/cogl/cogl-framebuffer.c
index 525b24293..6f24b2e42 100644
--- a/cogl/cogl/cogl-framebuffer.c
+++ b/cogl/cogl/cogl-framebuffer.c
@@ -2497,14 +2497,6 @@ _cogl_framebuffer_draw_indexed_attributes (CoglFramebuffer *framebuffer,
     }
 }
 
-void
-cogl_framebuffer_draw_primitive (CoglFramebuffer *framebuffer,
-                                 CoglPipeline *pipeline,
-                                 CoglPrimitive *primitive)
-{
-  _cogl_primitive_draw (primitive, framebuffer, pipeline, 0);
-}
-
 void
 cogl_framebuffer_draw_rectangle (CoglFramebuffer *framebuffer,
                                  CoglPipeline *pipeline,
diff --git a/cogl/cogl/cogl-framebuffer.h b/cogl/cogl/cogl-framebuffer.h
index 571b48998..8e5aeb2e7 100644
--- a/cogl/cogl/cogl-framebuffer.h
+++ b/cogl/cogl/cogl-framebuffer.h
@@ -1046,36 +1046,6 @@ cogl_framebuffer_clear4f (CoglFramebuffer *framebuffer,
                           float blue,
                           float alpha);
 
-/**
- * cogl_framebuffer_draw_primitive: (skip)
- * @framebuffer: A destination #CoglFramebuffer
- * @pipeline: A #CoglPipeline state object
- * @primitive: A #CoglPrimitive geometry object
- *
- * Draws the given @primitive geometry to the specified destination
- * @framebuffer using the graphics processing state described by @pipeline.
- *
- * This drawing api doesn't support high-level meta texture types such
- * as #CoglTexture2DSliced so it is the user's responsibility to
- * ensure that only low-level textures that can be directly sampled by
- * a GPU such as #CoglTexture2D are associated with layers of the given
- * @pipeline.
- *
- * <note>This api doesn't support any of the legacy global state options such
- * as cogl_set_depth_test_enabled() or
- * cogl_set_backface_culling_enabled().</note>
- *
- * Stability: unstable
- * Since: 1.10
- * Deprecated: 1.16: Use #CoglPrimitive<!-- -->s and
- *                   cogl_primitive_draw() instead
- */
-COGL_DEPRECATED_FOR (cogl_primitive_draw)
-COGL_EXPORT void
-cogl_framebuffer_draw_primitive (CoglFramebuffer *framebuffer,
-                                 CoglPipeline *pipeline,
-                                 CoglPrimitive *primitive);
-
 /**
  * cogl_framebuffer_draw_rectangle:
  * @framebuffer: A destination #CoglFramebuffer
diff --git a/cogl/cogl/cogl-onscreen.c b/cogl/cogl/cogl-onscreen.c
index cff5df50c..ff9e1749a 100644
--- a/cogl/cogl/cogl-onscreen.c
+++ b/cogl/cogl/cogl-onscreen.c
@@ -300,6 +300,19 @@ cogl_onscreen_bind (CoglOnscreen *onscreen)
   COGL_ONSCREEN_GET_CLASS (onscreen)->bind (onscreen);
 }
 
+void
+cogl_onscreen_queue_damage_region (CoglOnscreen *onscreen,
+                                   const int    *rectangles,
+                                   int           n_rectangles)
+{
+  CoglOnscreenClass *klass = COGL_ONSCREEN_GET_CLASS (onscreen);
+
+  if (!klass->queue_damage_region)
+    return;
+
+  klass->queue_damage_region (onscreen, rectangles, n_rectangles);
+}
+
 void
 cogl_onscreen_swap_buffers_with_damage (CoglOnscreen *onscreen,
                                         const int *rectangles,
diff --git a/cogl/cogl/cogl-onscreen.h b/cogl/cogl/cogl-onscreen.h
index 7284e04d5..677893493 100644
--- a/cogl/cogl/cogl-onscreen.h
+++ b/cogl/cogl/cogl-onscreen.h
@@ -74,6 +74,10 @@ struct _CoglOnscreenClass
                         CoglFrameInfo *info,
                         gpointer       user_data);
 
+  void (* queue_damage_region) (CoglOnscreen *onscreen,
+                                const int    *rectangles,
+                                int           n_rectangles);
+
   gboolean (* direct_scanout) (CoglOnscreen   *onscreen,
                                CoglScanout    *scanout,
                                CoglFrameInfo  *info,
@@ -227,6 +231,23 @@ cogl_onscreen_swap_buffers (CoglOnscreen  *onscreen,
 COGL_EXPORT int
 cogl_onscreen_get_buffer_age (CoglOnscreen *onscreen);
 
+/**
+ * cogl_onscreen_queue_damage_region:
+ * @onscreen: A #CoglOnscreen framebuffer
+ * @rectangles: An array of integer 4-tuples representing damaged
+ *              rectangles as (x, y, width, height) tuples.
+ * @n_rectangles: The number of 4-tuples to be read from @rectangles
+ *
+ * Implementation for https://www.khronos.org/registry/EGL/extensions/KHR/EGL_KHR_partial_update.txt
+ * This immediately queues state to OpenGL that will be used for the
+ * next swap.
+ * This needs to be called every frame.
+ */
+COGL_EXPORT void
+cogl_onscreen_queue_damage_region (CoglOnscreen *onscreen,
+                                   const int    *rectangles,
+                                   int           n_rectangles);
+
 /**
  * cogl_onscreen_swap_buffers_with_damage:
  * @onscreen: A #CoglOnscreen framebuffer
diff --git a/cogl/cogl/cogl-pipeline-debug.c b/cogl/cogl/cogl-pipeline-debug.c
index 7555257d0..9f1007b94 100644
--- a/cogl/cogl/cogl-pipeline-debug.c
+++ b/cogl/cogl/cogl-pipeline-debug.c
@@ -103,9 +103,10 @@ dump_layer_cb (CoglNode *node, void *user_data)
     {
       g_string_append_printf (changes_label, "\"];\n");
       g_string_append (state->graph, changes_label->str);
-      g_string_free (changes_label, TRUE);
     }
 
+  g_string_free (changes_label, TRUE);
+
   state_out.parent_id = layer_id;
 
   state_out.node_id_ptr = state->node_id_ptr;
@@ -210,9 +211,10 @@ dump_pipeline_cb (CoglNode *node, void *user_data)
     {
       g_string_append_printf (changes_label, "\"];\n");
       g_string_append (state->graph, changes_label->str);
-      g_string_free (changes_label, TRUE);
     }
 
+  g_string_free (changes_label, TRUE);
+
   if (layers)
     {
       g_list_foreach (pipeline->layer_differences,
diff --git a/cogl/cogl/cogl-renderer.c b/cogl/cogl/cogl-renderer.c
index d815757a0..5b37d8634 100644
--- a/cogl/cogl/cogl-renderer.c
+++ b/cogl/cogl/cogl-renderer.c
@@ -529,7 +529,7 @@ gboolean
 cogl_renderer_connect (CoglRenderer *renderer, GError **error)
 {
   int i;
-  GString *error_message;
+  g_autoptr (GString) error_message = NULL;
   gboolean constraints_failed = FALSE;
 
   if (renderer->connected)
@@ -594,7 +594,6 @@ cogl_renderer_connect (CoglRenderer *renderer, GError **error)
       else
         {
           renderer->connected = TRUE;
-          g_string_free (error_message, TRUE);
           return TRUE;
         }
     }
@@ -613,7 +612,6 @@ cogl_renderer_connect (CoglRenderer *renderer, GError **error)
       g_set_error (error, COGL_WINSYS_ERROR, COGL_WINSYS_ERROR_INIT,
                    "Failed to connected to any renderer: %s",
                    error_message->str);
-      g_string_free (error_message, TRUE);
       return FALSE;
     }
 
diff --git a/cogl/cogl/cogl-texture-2d.c b/cogl/cogl/cogl-texture-2d.c
index bababf749..07ab82074 100644
--- a/cogl/cogl/cogl-texture-2d.c
+++ b/cogl/cogl/cogl-texture-2d.c
@@ -51,10 +51,6 @@
 #include <string.h>
 #include <math.h>
 
-#ifdef COGL_HAS_WAYLAND_EGL_SERVER_SUPPORT
-#include "cogl-wayland-server.h"
-#endif
-
 static void _cogl_texture_2d_free (CoglTexture2D *tex_2d);
 
 COGL_TEXTURE_DEFINE (Texture2D, texture_2d);
diff --git a/cogl/cogl/cogl-types.h b/cogl/cogl/cogl-types.h
index cd92b2ecd..c55ad1f4c 100644
--- a/cogl/cogl/cogl-types.h
+++ b/cogl/cogl/cogl-types.h
@@ -423,10 +423,6 @@ typedef enum _CoglFilterReturn { /*< prefix=COGL_FILTER >*/
 
 typedef enum _CoglWinsysFeature
 {
-  /* Available if the window system can support multiple onscreen
-   * framebuffers at the same time. */
-  COGL_WINSYS_FEATURE_MULTIPLE_ONSCREEN,
-
   /* Available if its possible to query a counter that
    * increments at each vblank. */
   COGL_WINSYS_FEATURE_VBLANK_COUNTER,
diff --git a/cogl/cogl/cogl-wayland-server.h b/cogl/cogl/cogl-wayland-server.h
deleted file mode 100644
index f4d83bc24..000000000
--- a/cogl/cogl/cogl-wayland-server.h
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Cogl
- *
- * A Low Level GPU Graphics and Utilities API
- *
- * Copyright (C) 2012 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person
- * obtaining a copy of this software and associated documentation
- * files (the "Software"), to deal in the Software without
- * restriction, including without limitation the rights to use, copy,
- * modify, merge, publish, distribute, sublicense, and/or sell copies
- * of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
- * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
- * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- *
- */
-
-#ifndef __COGL_WAYLAND_SERVER_H
-#define __COGL_WAYLAND_SERVER_H
-
-#include <wayland-server.h>
-
-/* NB: this is a top-level header that can be included directly but we
- * want to be careful not to define __COGL_H_INSIDE__ when this is
- * included internally while building Cogl itself since
- * __COGL_H_INSIDE__ is used in headers to guard public vs private api
- * definitions
- */
-#ifndef COGL_COMPILATION
-
-/* Note: When building Cogl .gir we explicitly define
- * __COGL_H_INSIDE__ */
-#ifndef __COGL_H_INSIDE__
-#define __COGL_H_INSIDE__
-#define __COGL_MUST_UNDEF_COGL_H_INSIDE_COGL_WAYLAND_SERVER_
-#endif
-
-#endif /* COGL_COMPILATION */
-
-#include <cogl/cogl-context.h>
-#include <cogl/cogl-texture-2d.h>
-
-G_BEGIN_DECLS
-
-/**
- * cogl_wayland_display_set_compositor_display:
- * @display: a #CoglDisplay
- * @wayland_display: A compositor's Wayland display pointer
- *
- * Informs Cogl of a compositor's Wayland display pointer. This
- * enables Cogl to register private wayland extensions required to
- * pass buffers between the clients and compositor.
- *
- * Since: 1.10
- * Stability: unstable
- */
-COGL_EXPORT void
-cogl_wayland_display_set_compositor_display (CoglDisplay *display,
-                                          struct wl_display *wayland_display);
-
-G_END_DECLS
-
-/* The gobject introspection scanner seems to parse public headers in
- * isolation which means we need to be extra careful about how we
- * define and undefine __COGL_H_INSIDE__ used to detect when internal
- * headers are incorrectly included by developers. In the gobject
- * introspection case we have to manually define __COGL_H_INSIDE__ as
- * a commandline argument for the scanner which means we must be
- * careful not to undefine it in a header...
- */
-#ifdef __COGL_MUST_UNDEF_COGL_H_INSIDE_COGL_WAYLAND_SERVER_
-#undef __COGL_H_INSIDE__
-#undef __COGL_MUST_UNDEF_COGL_H_INSIDE_COGL_WAYLAND_SERVER_
-#endif
-
-#endif /* __COGL_WAYLAND_SERVER_H */
diff --git a/cogl/cogl/cogl.c b/cogl/cogl/cogl.c
index 807594f1b..469a64bb4 100644
--- a/cogl/cogl/cogl.c
+++ b/cogl/cogl/cogl.c
@@ -73,45 +73,6 @@ _cogl_check_extension (const char *name, char * const *ext)
   return FALSE;
 }
 
-/* XXX: This API has been deprecated */
-void
-cogl_set_depth_test_enabled (gboolean setting)
-{
-  _COGL_GET_CONTEXT (ctx, NO_RETVAL);
-
-  if (ctx->legacy_depth_test_enabled == setting)
-    return;
-
-  ctx->legacy_depth_test_enabled = setting;
-}
-
-/* XXX: This API has been deprecated */
-gboolean
-cogl_get_depth_test_enabled (void)
-{
-  _COGL_GET_CONTEXT (ctx, FALSE);
-  return ctx->legacy_depth_test_enabled;
-}
-
-void
-cogl_set_backface_culling_enabled (gboolean setting)
-{
-  _COGL_GET_CONTEXT (ctx, NO_RETVAL);
-
-  if (ctx->legacy_backface_culling_enabled == setting)
-    return;
-
-  ctx->legacy_backface_culling_enabled = setting;
-}
-
-gboolean
-cogl_get_backface_culling_enabled (void)
-{
-  _COGL_GET_CONTEXT (ctx, FALSE);
-
-  return ctx->legacy_backface_culling_enabled;
-}
-
 gboolean
 cogl_has_feature (CoglContext *ctx, CoglFeatureID feature)
 {
diff --git a/cogl/cogl/cogl.h b/cogl/cogl/cogl.h
index 4a63a368f..5c13614d4 100644
--- a/cogl/cogl/cogl.h
+++ b/cogl/cogl/cogl.h
@@ -85,7 +85,6 @@
 
 #include <cogl/deprecated/cogl-auto-texture.h>
 #include <cogl/deprecated/cogl-shader.h>
-#include <cogl/deprecated/cogl-material-compat.h>
 
 #ifdef COGL_ENABLE_MUTTER_API
 #include <cogl/cogl-mutter.h>
diff --git a/cogl/cogl/cogl1-context.h b/cogl/cogl/cogl1-context.h
index 755a48452..b36c3e731 100644
--- a/cogl/cogl/cogl1-context.h
+++ b/cogl/cogl/cogl1-context.h
@@ -79,65 +79,6 @@ cogl_get_option_group (void);
 COGL_EXPORT GCallback
 cogl_get_proc_address (const char *name);
 
-/**
- * cogl_set_depth_test_enabled:
- * @setting: %TRUE to enable depth testing or %FALSE to disable.
- *
- * Sets whether depth testing is enabled. If it is disabled then the
- * order that actors are layered on the screen depends solely on the
- * order specified using clutter_actor_raise() and
- * clutter_actor_lower(), otherwise it will also take into account the
- * actor's depth. Depth testing is disabled by default.
- *
- * Deprecated: 1.16: Use cogl_pipeline_set_depth_state() instead
- */
-COGL_DEPRECATED_FOR (cogl_pipeline_set_depth_state)
-COGL_EXPORT void
-cogl_set_depth_test_enabled (gboolean setting);
-
-/**
- * cogl_get_depth_test_enabled:
- *
- * Queries if depth testing has been enabled via cogl_set_depth_test_enable()
- *
- * Return value: %TRUE if depth testing is enabled, and %FALSE otherwise
- *
- * Deprecated: 1.16: Use cogl_pipeline_set_depth_state() instead
- */
-COGL_DEPRECATED_FOR (cogl_pipeline_set_depth_state)
-COGL_EXPORT gboolean
-cogl_get_depth_test_enabled (void);
-
-/**
- * cogl_set_backface_culling_enabled:
- * @setting: %TRUE to enable backface culling or %FALSE to disable.
- *
- * Sets whether textures positioned so that their backface is showing
- * should be hidden. This can be used to efficiently draw two-sided
- * textures or fully closed cubes without enabling depth testing. This
- * only affects calls to the cogl_rectangle* family of functions and
- * cogl_vertex_buffer_draw*. Backface culling is disabled by default.
- *
- * Deprecated: 1.16: Use cogl_pipeline_set_cull_face_mode() instead
- */
-COGL_DEPRECATED_FOR (cogl_pipeline_set_cull_face_mode)
-COGL_EXPORT void
-cogl_set_backface_culling_enabled (gboolean setting);
-
-/**
- * cogl_get_backface_culling_enabled:
- *
- * Queries if backface culling has been enabled via
- * cogl_set_backface_culling_enabled()
- *
- * Return value: %TRUE if backface culling is enabled, and %FALSE otherwise
- *
- * Deprecated: 1.16: Use cogl_pipeline_get_cull_face_mode() instead
- */
-COGL_DEPRECATED_FOR (cogl_pipeline_get_cull_face_mode)
-COGL_EXPORT gboolean
-cogl_get_backface_culling_enabled (void);
-
 /**
  * cogl_flush:
  *
diff --git a/cogl/cogl/deprecated/cogl-auto-texture.c b/cogl/cogl/deprecated/cogl-auto-texture.c
index 99431a5c2..f8dbb2aa0 100644
--- a/cogl/cogl/deprecated/cogl-auto-texture.c
+++ b/cogl/cogl/deprecated/cogl-auto-texture.c
@@ -68,66 +68,6 @@ set_auto_mipmap_cb (CoglTexture *sub_texture,
                                           FALSE);
 }
 
-CoglTexture *
-cogl_texture_new_with_size (unsigned int width,
-			    unsigned int height,
-                            CoglTextureFlags flags,
-			    CoglPixelFormat internal_format)
-{
-  CoglTexture *tex;
-  GError *skip_error = NULL;
-
-  _COGL_GET_CONTEXT (ctx, NULL);
-
-  /* First try creating a fast-path non-sliced texture */
-  tex = COGL_TEXTURE (cogl_texture_2d_new_with_size (ctx, width, height));
-
-  _cogl_texture_set_internal_format (tex, internal_format);
-
-  if (!cogl_texture_allocate (tex, &skip_error))
-    {
-      g_error_free (skip_error);
-      skip_error = NULL;
-      cogl_object_unref (tex);
-      tex = NULL;
-    }
-
-  if (!tex)
-    {
-      /* If it fails resort to sliced textures */
-      int max_waste = flags & COGL_TEXTURE_NO_SLICING ? -1 : COGL_TEXTURE_MAX_WASTE;
-      tex = COGL_TEXTURE (cogl_texture_2d_sliced_new_with_size (ctx,
-                                                                width,
-                                                                height,
-                                                                max_waste));
-
-      _cogl_texture_set_internal_format (tex, internal_format);
-    }
-
-  /* NB: This api existed before Cogl introduced lazy allocation of
-   * textures and so we maintain its original synchronous allocation
-   * semantics and return NULL if allocation fails... */
-  if (!cogl_texture_allocate (tex, &skip_error))
-    {
-      g_error_free (skip_error);
-      cogl_object_unref (tex);
-      return NULL;
-    }
-
-  if (tex &&
-      flags & COGL_TEXTURE_NO_AUTO_MIPMAP)
-    {
-      cogl_meta_texture_foreach_in_region (COGL_META_TEXTURE (tex),
-                                           0, 0, 1, 1,
-                                           COGL_PIPELINE_WRAP_MODE_CLAMP_TO_EDGE,
-                                           COGL_PIPELINE_WRAP_MODE_CLAMP_TO_EDGE,
-                                           set_auto_mipmap_cb,
-                                           NULL);
-    }
-
-  return tex;
-}
-
 static CoglTexture *
 _cogl_texture_new_from_data (CoglContext *ctx,
                              int width,
@@ -333,16 +273,3 @@ cogl_texture_new_from_file (const char        *filename,
 
   return texture;
 }
-
-CoglTexture *
-cogl_texture_new_from_sub_texture (CoglTexture *full_texture,
-                                   int sub_x,
-                                   int sub_y,
-                                   int sub_width,
-                                   int sub_height)
-{
-  _COGL_GET_CONTEXT (ctx, NULL);
-  return COGL_TEXTURE (cogl_sub_texture_new (ctx,
-                                             full_texture, sub_x, sub_y,
-                                             sub_width, sub_height));
-}
diff --git a/cogl/cogl/deprecated/cogl-auto-texture.h b/cogl/cogl/deprecated/cogl-auto-texture.h
index 61ac84ed2..1bfd47249 100644
--- a/cogl/cogl/deprecated/cogl-auto-texture.h
+++ b/cogl/cogl/deprecated/cogl-auto-texture.h
@@ -35,29 +35,6 @@ G_BEGIN_DECLS
 
 #include <cogl/cogl-texture.h>
 
-/**
- * cogl_texture_new_with_size:
- * @width: width of texture in pixels.
- * @height: height of texture in pixels.
- * @flags: Optional flags for the texture, or %COGL_TEXTURE_NONE
- * @internal_format: the #CoglPixelFormat to use for the GPU storage of the
- *    texture.
- *
- * Creates a new #CoglTexture with the specified dimensions and pixel format.
- *
- * Return value: (transfer full): A newly created #CoglTexture or %NULL on failure
- *
- * Since: 0.8
- * Deprecated: 1.18: Use specific constructors such as
- *                   cogl_texture_2d_new_with_size()
- */
-COGL_DEPRECATED_FOR (cogl_texture_2d_new_with_size__OR__cogl_texture_2d_sliced_new_with_size)
-COGL_EXPORT CoglTexture *
-cogl_texture_new_with_size (unsigned int width,
-                            unsigned int height,
-                            CoglTextureFlags flags,
-                            CoglPixelFormat internal_format);
-
 /**
  * cogl_texture_new_from_file:
  * @filename: the file to load
@@ -147,38 +124,6 @@ cogl_texture_new_from_bitmap (CoglBitmap *bitmap,
                               CoglTextureFlags flags,
                               CoglPixelFormat internal_format);
 
-/**
- * cogl_texture_new_from_sub_texture:
- * @full_texture: a #CoglTexture pointer
- * @sub_x: X coordinate of the top-left of the subregion
- * @sub_y: Y coordinate of the top-left of the subregion
- * @sub_width: Width in pixels of the subregion
- * @sub_height: Height in pixels of the subregion
- *
- * Creates a new texture which represents a subregion of another
- * texture. The GL resources will be shared so that no new texture
- * data is actually allocated.
- *
- * Sub textures have undefined behaviour texture coordinates outside
- * of the range [0,1] are used.
- *
- * The sub texture will keep a reference to the full texture so you do
- * not need to keep one separately if you only want to use the sub
- * texture.
- *
- * Return value: (transfer full): A newly created #CoglTexture or
- *               %NULL on failure
- * Since: 1.2
- * Deprecated: 1.18: Use cogl_sub_texture_new()
- */
-COGL_DEPRECATED_FOR (cogl_sub_texture_new)
-COGL_EXPORT CoglTexture *
-cogl_texture_new_from_sub_texture (CoglTexture *full_texture,
-                                   int sub_x,
-                                   int sub_y,
-                                   int sub_width,
-                                   int sub_height);
-
 G_END_DECLS
 
 #endif /* __COGL_AUTO_TEXTURE_H__ */
diff --git a/cogl/cogl/deprecated/cogl-material-compat.c b/cogl/cogl/deprecated/cogl-material-compat.c
deleted file mode 100644
index ac7923325..000000000
--- a/cogl/cogl/deprecated/cogl-material-compat.c
+++ /dev/null
@@ -1,162 +0,0 @@
-/*
- * Cogl
- *
- * A Low Level GPU Graphics and Utilities API
- *
- * Copyright (C) 2010 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person
- * obtaining a copy of this software and associated documentation
- * files (the "Software"), to deal in the Software without
- * restriction, including without limitation the rights to use, copy,
- * modify, merge, publish, distribute, sublicense, and/or sell copies
- * of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
- * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
- * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- *
- * Authors:
- *  Robert Bragg <robert@linux.intel.com>
- */
-
-#include "cogl-config.h"
-
-#include <cogl-pipeline.h>
-#include <cogl-pipeline-private.h>
-#include <cogl-types.h>
-#include <cogl-context-private.h>
-#include <deprecated/cogl-material-compat.h>
-
-G_DEFINE_BOXED_TYPE (CoglMaterial, cogl_material,
-                     cogl_object_ref, cogl_object_unref)
-
-CoglMaterial *
-cogl_material_new (void)
-{
-  _COGL_GET_CONTEXT(ctx, NULL);
-  return COGL_MATERIAL (cogl_pipeline_new (ctx));
-}
-
-void
-cogl_material_set_color (CoglMaterial    *material,
-                         const CoglColor *color)
-{
-  cogl_pipeline_set_color (COGL_PIPELINE (material), color);
-}
-
-void
-cogl_material_set_color4ub (CoglMaterial *material,
-			    uint8_t red,
-                            uint8_t green,
-                            uint8_t blue,
-                            uint8_t alpha)
-{
-  cogl_pipeline_set_color4ub (COGL_PIPELINE (material),
-                              red, green, blue, alpha);
-}
-
-gboolean
-cogl_material_set_blend (CoglMaterial *material,
-                         const char   *blend_string,
-                         GError **error)
-{
-  return cogl_pipeline_set_blend (COGL_PIPELINE (material),
-                                  blend_string,
-                                  error);
-}
-
-void
-cogl_material_set_blend_constant (CoglMaterial *material,
-                                  const CoglColor *constant_color)
-{
-  cogl_pipeline_set_blend_constant (COGL_PIPELINE (material), constant_color);
-}
-
-void
-cogl_material_set_point_size (CoglMaterial *material,
-                              float         point_size)
-{
-  cogl_pipeline_set_point_size (COGL_PIPELINE (material), point_size);
-}
-
-void
-cogl_material_set_user_program (CoglMaterial *material,
-                                CoglHandle program)
-{
-  cogl_pipeline_set_user_program (COGL_PIPELINE (material), program);
-}
-
-void
-cogl_material_set_layer (CoglMaterial *material,
-			 int           layer_index,
-			 CoglHandle    texture)
-{
-  cogl_pipeline_set_layer_texture (COGL_PIPELINE (material),
-                                   layer_index, texture);
-}
-
-gboolean
-cogl_material_set_layer_combine (CoglMaterial *material,
-				 int           layer_index,
-				 const char   *blend_string,
-                                 GError **error)
-{
-  return cogl_pipeline_set_layer_combine (COGL_PIPELINE (material),
-                                          layer_index,
-                                          blend_string,
-                                          error);
-}
-
-void
-cogl_material_set_layer_combine_constant (CoglMaterial    *material,
-                                          int              layer_index,
-                                          const CoglColor *constant)
-{
-  cogl_pipeline_set_layer_combine_constant (COGL_PIPELINE (material),
-                                            layer_index,
-                                            constant);
-}
-
-void
-cogl_material_set_layer_matrix (CoglMaterial            *material,
-                                int                      layer_index,
-                                const graphene_matrix_t *matrix)
-{
-  cogl_pipeline_set_layer_matrix (COGL_PIPELINE (material),
-                                  layer_index, matrix);
-}
-
-void
-cogl_material_set_layer_filters (CoglMaterial      *material,
-                                 int                layer_index,
-                                 CoglMaterialFilter min_filter,
-                                 CoglMaterialFilter mag_filter)
-{
-  cogl_pipeline_set_layer_filters (COGL_PIPELINE (material),
-                                   layer_index,
-                                   min_filter,
-                                   mag_filter);
-}
-
-gboolean
-cogl_material_set_layer_point_sprite_coords_enabled (CoglMaterial *material,
-                                                     int           layer_index,
-                                                     gboolean      enable,
-                                                     GError      **error)
-{
-  CoglPipeline *pipeline = COGL_PIPELINE (material);
-  return cogl_pipeline_set_layer_point_sprite_coords_enabled (pipeline,
-                                                              layer_index,
-                                                              enable,
-                                                              error);
-}
diff --git a/cogl/cogl/deprecated/cogl-material-compat.h b/cogl/cogl/deprecated/cogl-material-compat.h
deleted file mode 100644
index 04842f546..000000000
--- a/cogl/cogl/deprecated/cogl-material-compat.h
+++ /dev/null
@@ -1,642 +0,0 @@
-/*
- * Cogl
- *
- * A Low Level GPU Graphics and Utilities API
- *
- * Copyright (C) 2007,2008,2009 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person
- * obtaining a copy of this software and associated documentation
- * files (the "Software"), to deal in the Software without
- * restriction, including without limitation the rights to use, copy,
- * modify, merge, publish, distribute, sublicense, and/or sell copies
- * of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
- * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
- * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- *
- *
- */
-
-#if !defined(__COGL_H_INSIDE__) && !defined(COGL_COMPILATION)
-#error "Only <cogl/cogl.h> can be included directly."
-#endif
-
-#ifndef __COGL_MATERIAL_H__
-#define __COGL_MATERIAL_H__
-
-#include <cogl/cogl-types.h>
-#include <cogl/cogl-depth-state.h>
-#include <cogl/cogl-macros.h>
-#include <cogl/cogl-object.h>
-
-G_BEGIN_DECLS
-
-/**
- * SECTION:cogl-material
- * @short_description: Functions for creating and manipulating materials
- *
- * COGL allows creating and manipulating materials used to fill in
- * geometry. Materials may simply be lighting attributes (such as an
- * ambient and diffuse colour) or might represent one or more textures
- * blended together.
- */
-
-typedef struct _CoglMaterial	      CoglMaterial;
-typedef struct _CoglMaterialLayer     CoglMaterialLayer;
-
-#define COGL_TYPE_MATERIAL (cogl_material_get_type ())
-COGL_EXPORT
-GType cogl_material_get_type (void);
-
-#define COGL_MATERIAL(OBJECT) ((CoglMaterial *)OBJECT)
-
-/**
- * CoglMaterialFilter:
- * @COGL_MATERIAL_FILTER_NEAREST: Measuring in manhatten distance from the,
- *   current pixel center, use the nearest texture texel
- * @COGL_MATERIAL_FILTER_LINEAR: Use the weighted average of the 4 texels
- *   nearest the current pixel center
- * @COGL_MATERIAL_FILTER_NEAREST_MIPMAP_NEAREST: Select the mimap level whose
- *   texel size most closely matches the current pixel, and use the
- *   %COGL_MATERIAL_FILTER_NEAREST criterion
- * @COGL_MATERIAL_FILTER_LINEAR_MIPMAP_NEAREST: Select the mimap level whose
- *   texel size most closely matches the current pixel, and use the
- *   %COGL_MATERIAL_FILTER_LINEAR criterion
- * @COGL_MATERIAL_FILTER_NEAREST_MIPMAP_LINEAR: Select the two mimap levels
- *   whose texel size most closely matches the current pixel, use
- *   the %COGL_MATERIAL_FILTER_NEAREST criterion on each one and take
- *   their weighted average
- * @COGL_MATERIAL_FILTER_LINEAR_MIPMAP_LINEAR: Select the two mimap levels
- *   whose texel size most closely matches the current pixel, use
- *   the %COGL_MATERIAL_FILTER_LINEAR criterion on each one and take
- *   their weighted average
- *
- * Texture filtering is used whenever the current pixel maps either to more
- * than one texture element (texel) or less than one. These filter enums
- * correspond to different strategies used to come up with a pixel color, by
- * possibly referring to multiple neighbouring texels and taking a weighted
- * average or simply using the nearest texel.
- */
-typedef enum
-{
-  COGL_MATERIAL_FILTER_NEAREST = 0x2600,
-  COGL_MATERIAL_FILTER_LINEAR = 0x2601,
-  COGL_MATERIAL_FILTER_NEAREST_MIPMAP_NEAREST = 0x2700,
-  COGL_MATERIAL_FILTER_LINEAR_MIPMAP_NEAREST = 0x2701,
-  COGL_MATERIAL_FILTER_NEAREST_MIPMAP_LINEAR = 0x2702,
-  COGL_MATERIAL_FILTER_LINEAR_MIPMAP_LINEAR = 0x2703
-} CoglMaterialFilter;
-/* NB: these values come from the equivalents in gl.h */
-
-/**
- * CoglMaterialWrapMode:
- * @COGL_MATERIAL_WRAP_MODE_REPEAT: The texture will be repeated. This
- *   is useful for example to draw a tiled background.
- * @COGL_MATERIAL_WRAP_MODE_CLAMP_TO_EDGE: The coordinates outside the
- *   range 0→1 will sample copies of the edge pixels of the
- *   texture. This is useful to avoid artifacts if only one copy of
- *   the texture is being rendered.
- * @COGL_MATERIAL_WRAP_MODE_AUTOMATIC: Cogl will try to automatically
- *   decide which of the above two to use. For cogl_rectangle(), it
- *   will use repeat mode if any of the texture coordinates are
- *   outside the range 0→1, otherwise it will use clamp to edge. For
- *   cogl_polygon() it will always use repeat mode. For
- *   cogl_vertex_buffer_draw() it will use repeat mode except for
- *   layers that have point sprite coordinate generation enabled. This
- *   is the default value.
- *
- * The wrap mode specifies what happens when texture coordinates
- * outside the range 0→1 are used. Note that if the filter mode is
- * anything but %COGL_MATERIAL_FILTER_NEAREST then texels outside the
- * range 0→1 might be used even when the coordinate is exactly 0 or 1
- * because OpenGL will try to sample neighbouring pixels. For example
- * if you are trying to render the full texture then you may get
- * artifacts around the edges when the pixels from the other side are
- * merged in if the wrap mode is set to repeat.
- *
- * Since: 1.4
- */
-/* GL_ALWAYS is just used here as a value that is known not to clash
- * with any valid GL wrap modes
- *
- * XXX: keep the values in sync with the CoglMaterialWrapModeInternal
- * enum so no conversion is actually needed.
- */
-typedef enum
-{
-  COGL_MATERIAL_WRAP_MODE_REPEAT = 0x2901,
-  COGL_MATERIAL_WRAP_MODE_CLAMP_TO_EDGE = 0x812F,
-  COGL_MATERIAL_WRAP_MODE_AUTOMATIC = 0x0207
-} CoglMaterialWrapMode;
-/* NB: these values come from the equivalents in gl.h */
-
-/**
- * cogl_material_new:
- *
- * Allocates and initializes a blank white material
- *
- * Return value: a pointer to a new #CoglMaterial
- * Deprecated: 1.16: Use cogl_pipeline_new() instead
- */
-COGL_DEPRECATED_FOR (cogl_pipeline_new)
-COGL_EXPORT CoglMaterial *
-cogl_material_new (void);
-
-/**
- * cogl_material_set_color:
- * @material: A #CoglMaterial object
- * @color: The components of the color
- *
- * Sets the basic color of the material, used when no lighting is enabled.
- *
- * Note that if you don't add any layers to the material then the color
- * will be blended unmodified with the destination; the default blend
- * expects premultiplied colors: for example, use (0.5, 0.0, 0.0, 0.5) for
- * semi-transparent red. See cogl_color_premultiply().
- *
- * The default value is (1.0, 1.0, 1.0, 1.0)
- *
- * Since: 1.0
- * Deprecated: 1.16: Use cogl_pipeline_set_color() instead
- */
-COGL_DEPRECATED_FOR (cogl_pipeline_set_color)
-COGL_EXPORT void
-cogl_material_set_color (CoglMaterial    *material,
-                         const CoglColor *color);
-
-/**
- * cogl_material_set_color4ub:
- * @material: A #CoglMaterial object
- * @red: The red component
- * @green: The green component
- * @blue: The blue component
- * @alpha: The alpha component
- *
- * Sets the basic color of the material, used when no lighting is enabled.
- *
- * The default value is (0xff, 0xff, 0xff, 0xff)
- *
- * Since: 1.0
- * Deprecated: 1.16: Use cogl_pipeline_set_color4ub() instead
- */
-COGL_DEPRECATED_FOR (cogl_pipeline_set_color4ub)
-COGL_EXPORT void
-cogl_material_set_color4ub (CoglMaterial *material,
-			    uint8_t red,
-                            uint8_t green,
-                            uint8_t blue,
-                            uint8_t alpha);
-
-/**
- * CoglMaterialAlphaFunc:
- * @COGL_MATERIAL_ALPHA_FUNC_NEVER: Never let the fragment through.
- * @COGL_MATERIAL_ALPHA_FUNC_LESS: Let the fragment through if the incoming
- *   alpha value is less than the reference alpha value
- * @COGL_MATERIAL_ALPHA_FUNC_EQUAL: Let the fragment through if the incoming
- *   alpha value equals the reference alpha value
- * @COGL_MATERIAL_ALPHA_FUNC_LEQUAL: Let the fragment through if the incoming
- *   alpha value is less than or equal to the reference alpha value
- * @COGL_MATERIAL_ALPHA_FUNC_GREATER: Let the fragment through if the incoming
- *   alpha value is greater than the reference alpha value
- * @COGL_MATERIAL_ALPHA_FUNC_NOTEQUAL: Let the fragment through if the incoming
- *   alpha value does not equal the reference alpha value
- * @COGL_MATERIAL_ALPHA_FUNC_GEQUAL: Let the fragment through if the incoming
- *   alpha value is greater than or equal to the reference alpha value.
- * @COGL_MATERIAL_ALPHA_FUNC_ALWAYS: Always let the fragment through.
- *
- * Alpha testing happens before blending primitives with the framebuffer and
- * gives an opportunity to discard fragments based on a comparison with the
- * incoming alpha value and a reference alpha value. The #CoglMaterialAlphaFunc
- * determines how the comparison is done.
- */
-typedef enum
-{
-  COGL_MATERIAL_ALPHA_FUNC_NEVER    = 0x0200,
-  COGL_MATERIAL_ALPHA_FUNC_LESS	    = 0x0201,
-  COGL_MATERIAL_ALPHA_FUNC_EQUAL    = 0x0202,
-  COGL_MATERIAL_ALPHA_FUNC_LEQUAL   = 0x0203,
-  COGL_MATERIAL_ALPHA_FUNC_GREATER  = 0x0204,
-  COGL_MATERIAL_ALPHA_FUNC_NOTEQUAL = 0x0205,
-  COGL_MATERIAL_ALPHA_FUNC_GEQUAL   = 0x0206,
-  COGL_MATERIAL_ALPHA_FUNC_ALWAYS   = 0x0207
-} CoglMaterialAlphaFunc;
-
-/**
- * cogl_material_set_alpha_test_function:
- * @material: A #CoglMaterial object
- * @alpha_func: A @CoglMaterialAlphaFunc constant
- * @alpha_reference: A reference point that the chosen alpha function uses
- *   to compare incoming fragments to.
- *
- * Before a primitive is blended with the framebuffer, it goes through an
- * alpha test stage which lets you discard fragments based on the current
- * alpha value. This function lets you change the function used to evaluate
- * the alpha channel, and thus determine which fragments are discarded
- * and which continue on to the blending stage.
- *
- * The default is %COGL_MATERIAL_ALPHA_FUNC_ALWAYS
- *
- * Since: 1.0
- * Deprecated: 1.16: Use cogl_pipeline_set_alpha_test_function() instead
- */
-COGL_DEPRECATED_FOR (cogl_pipeline_set_alpha_test_function)
-COGL_EXPORT void
-cogl_material_set_alpha_test_function (CoglMaterial         *material,
-				       CoglMaterialAlphaFunc alpha_func,
-				       float                 alpha_reference);
-
-/**
- * cogl_material_set_blend:
- * @material: A #CoglMaterial object
- * @blend_string: A <link linkend="cogl-Blend-Strings">Cogl blend string</link>
- *   describing the desired blend function.
- * @error: return location for a #GError that may report lack of driver
- *   support if you give separate blend string statements for the alpha
- *   channel and RGB channels since some drivers, or backends such as
- *   GLES 1.1, don't support this feature. May be %NULL, in which case a
- *   warning will be printed out using GLib's logging facilities if an
- *   error is encountered.
- *
- * If not already familiar; please refer <link linkend="cogl-Blend-Strings">here</link>
- * for an overview of what blend strings are, and their syntax.
- *
- * Blending occurs after the alpha test function, and combines fragments with
- * the framebuffer.
-
- * Currently the only blend function Cogl exposes is ADD(). So any valid
- * blend statements will be of the form:
- *
- * |[
- *   &lt;channel-mask&gt;=ADD(SRC_COLOR*(&lt;factor&gt;), DST_COLOR*(&lt;factor&gt;))
- * ]|
- *
- * <warning>The brackets around blend factors are currently not
- * optional!</warning>
- *
- * This is the list of source-names usable as blend factors:
- * <itemizedlist>
- *   <listitem><para>SRC_COLOR: The color of the incoming fragment</para></listitem>
- *   <listitem><para>DST_COLOR: The color of the framebuffer</para></listitem>
- *   <listitem><para>CONSTANT: The constant set via cogl_material_set_blend_constant()</para></listitem>
- * </itemizedlist>
- *
- * The source names can be used according to the
- * <link linkend="cogl-Blend-String-syntax">color-source and factor syntax</link>,
- * so for example "(1-SRC_COLOR[A])" would be a valid factor, as would
- * "(CONSTANT[RGB])"
- *
- * These can also be used as factors:
- * <itemizedlist>
- *   <listitem>0: (0, 0, 0, 0)</listitem>
- *   <listitem>1: (1, 1, 1, 1)</listitem>
- *   <listitem>SRC_ALPHA_SATURATE_FACTOR: (f,f,f,1) where f = MIN(SRC_COLOR[A],1-DST_COLOR[A])</listitem>
- * </itemizedlist>
- *
- * <note>Remember; all color components are normalized to the range [0, 1]
- * before computing the result of blending.</note>
- *
- * <example id="cogl-Blend-Strings-blend-unpremul">
- *   <title>Blend Strings/1</title>
- *   <para>Blend a non-premultiplied source over a destination with
- *   premultiplied alpha:</para>
- *   <programlisting>
- * "RGB = ADD(SRC_COLOR*(SRC_COLOR[A]), DST_COLOR*(1-SRC_COLOR[A]))"
- * "A   = ADD(SRC_COLOR, DST_COLOR*(1-SRC_COLOR[A]))"
- *   </programlisting>
- * </example>
- *
- * <example id="cogl-Blend-Strings-blend-premul">
- *   <title>Blend Strings/2</title>
- *   <para>Blend a premultiplied source over a destination with
- *   premultiplied alpha</para>
- *   <programlisting>
- * "RGBA = ADD(SRC_COLOR, DST_COLOR*(1-SRC_COLOR[A]))"
- *   </programlisting>
- * </example>
- *
- * The default blend string is:
- * |[
- *    RGBA = ADD (SRC_COLOR, DST_COLOR*(1-SRC_COLOR[A]))
- * ]|
- *
- * That gives normal alpha-blending when the calculated color for the material
- * is in premultiplied form.
- *
- * Return value: %TRUE if the blend string was successfully parsed, and the
- *   described blending is supported by the underlying driver/hardware. If
- *   there was an error, %FALSE is returned and @error is set accordingly (if
- *   present).
- *
- * Since: 1.0
- * Deprecated: 1.16: Use cogl_pipeline_set_blend() instead
- */
-COGL_DEPRECATED_FOR (cogl_pipeline_set_blend)
-COGL_EXPORT gboolean
-cogl_material_set_blend (CoglMaterial *material,
-                         const char   *blend_string,
-                         GError      **error);
-
-/**
- * cogl_material_set_blend_constant:
- * @material: A #CoglMaterial object
- * @constant_color: The constant color you want
- *
- * When blending is setup to reference a CONSTANT blend factor then
- * blending will depend on the constant set with this function.
- *
- * Since: 1.0
- * Deprecated: 1.16: Use cogl_pipeline_set_blend_constant() instead
- */
-COGL_DEPRECATED_FOR (cogl_pipeline_set_blend_constant)
-COGL_EXPORT void
-cogl_material_set_blend_constant (CoglMaterial *material,
-                                  const CoglColor *constant_color);
-
-/**
- * cogl_material_set_point_size:
- * @material: a material.
- * @point_size: the new point size.
- *
- * Changes the size of points drawn when %COGL_VERTICES_MODE_POINTS is
- * used with the vertex buffer API. Note that typically the GPU will
- * only support a limited minimum and maximum range of point sizes. If
- * the chosen point size is outside that range then the nearest value
- * within that range will be used instead. The size of a point is in
- * screen space so it will be the same regardless of any
- * transformations. The default point size is 1.0.
- *
- * Since: 1.4
- * Deprecated: 1.16: Use cogl_pipeline_set_point_size() instead
- */
-COGL_DEPRECATED_FOR (cogl_pipeline_set_point_size)
-COGL_EXPORT void
-cogl_material_set_point_size (CoglMaterial *material,
-                              float         point_size);
-
-/**
- * cogl_material_set_user_program:
- * @material: a #CoglMaterial object.
- * @program: A #CoglHandle to a linked CoglProgram
- *
- * Associates a linked CoglProgram with the given material so that the
- * program can take full control of vertex and/or fragment processing.
- *
- * This is an example of how it can be used to associate an ARBfp
- * program with a #CoglMaterial:
- * |[
- * CoglHandle shader;
- * CoglHandle program;
- * CoglMaterial *material;
- *
- * shader = cogl_create_shader (COGL_SHADER_TYPE_FRAGMENT);
- * cogl_shader_source (shader,
- *                     "!!ARBfp1.0\n"
- *                     "MOV result.color,fragment.color;\n"
- *                     "END\n");
- *
- * program = cogl_create_program ();
- * cogl_program_attach_shader (program, shader);
- * cogl_program_link (program);
- *
- * material = cogl_material_new ();
- * cogl_material_set_user_program (material, program);
- *
- * cogl_set_source_color4ub (0xff, 0x00, 0x00, 0xff);
- * cogl_rectangle (0, 0, 100, 100);
- * ]|
- *
- * It is possibly worth keeping in mind that this API is not part of
- * the long term design for how we want to expose shaders to Cogl
- * developers (We are planning on deprecating the cogl_program and
- * cogl_shader APIs in favour of a "snippet" framework) but in the
- * meantime we hope this will handle most practical GLSL and ARBfp
- * requirements.
- *
- * Since: 1.4
- * Deprecated: 1.16: Use #CoglSnippet api instead instead
- */
-COGL_DEPRECATED_FOR (cogl_snippet_)
-COGL_EXPORT void
-cogl_material_set_user_program (CoglMaterial *material,
-                                CoglHandle program);
-
-/**
- * cogl_material_set_layer:
- * @material: A #CoglMaterial object
- * @layer_index: the index of the layer
- * @texture: a #CoglHandle for the layer object
- *
- * In addition to the standard OpenGL lighting model a Cogl material may have
- * one or more layers comprised of textures that can be blended together in
- * order, with a number of different texture combine modes. This function
- * defines a new texture layer.
- *
- * The index values of multiple layers do not have to be consecutive; it is
- * only their relative order that is important.
- *
- * <note>In the future, we may define other types of material layers, such
- * as purely GLSL based layers.</note>
- *
- * Since: 1.0
- * Deprecated: 1.16: Use cogl_pipeline_set_layer() instead
- */
-COGL_DEPRECATED_FOR (cogl_pipeline_set_layer)
-COGL_EXPORT void
-cogl_material_set_layer (CoglMaterial *material,
-			 int           layer_index,
-			 CoglHandle    texture);
-
-/**
- * cogl_material_set_layer_combine:
- * @material: A #CoglMaterial object
- * @layer_index: Specifies the layer you want define a combine function for
- * @blend_string: A <link linkend="cogl-Blend-Strings">Cogl blend string</link>
- *    describing the desired texture combine function.
- * @error: A #GError that may report parse errors or lack of GPU/driver
- *   support. May be %NULL, in which case a warning will be printed out if an
- *   error is encountered.
- *
- * If not already familiar; you can refer
- * <link linkend="cogl-Blend-Strings">here</link> for an overview of what blend
- * strings are and there syntax.
- *
- * These are all the functions available for texture combining:
- * <itemizedlist>
- *   <listitem>REPLACE(arg0) = arg0</listitem>
- *   <listitem>MODULATE(arg0, arg1) = arg0 x arg1</listitem>
- *   <listitem>ADD(arg0, arg1) = arg0 + arg1</listitem>
- *   <listitem>ADD_SIGNED(arg0, arg1) = arg0 + arg1 - 0.5</listitem>
- *   <listitem>INTERPOLATE(arg0, arg1, arg2) = arg0 x arg2 + arg1 x (1 - arg2)</listitem>
- *   <listitem>SUBTRACT(arg0, arg1) = arg0 - arg1</listitem>
- *   <listitem>
- *     <programlisting>
- *  DOT3_RGB(arg0, arg1) = 4 x ((arg0[R] - 0.5)) * (arg1[R] - 0.5) +
- *                              (arg0[G] - 0.5)) * (arg1[G] - 0.5) +
- *                              (arg0[B] - 0.5)) * (arg1[B] - 0.5))
- *     </programlisting>
- *   </listitem>
- *   <listitem>
- *     <programlisting>
- *  DOT3_RGBA(arg0, arg1) = 4 x ((arg0[R] - 0.5)) * (arg1[R] - 0.5) +
- *                               (arg0[G] - 0.5)) * (arg1[G] - 0.5) +
- *                               (arg0[B] - 0.5)) * (arg1[B] - 0.5))
- *     </programlisting>
- *   </listitem>
- * </itemizedlist>
- *
- * Refer to the
- * <link linkend="cogl-Blend-String-syntax">color-source syntax</link> for
- * describing the arguments. The valid source names for texture combining
- * are:
- * <variablelist>
- *   <varlistentry>
- *     <term>TEXTURE</term>
- *     <listitem>Use the color from the current texture layer</listitem>
- *   </varlistentry>
- *   <varlistentry>
- *     <term>TEXTURE_0, TEXTURE_1, etc</term>
- *     <listitem>Use the color from the specified texture layer</listitem>
- *   </varlistentry>
- *   <varlistentry>
- *     <term>CONSTANT</term>
- *     <listitem>Use the color from the constant given with
- *     cogl_material_set_layer_constant()</listitem>
- *   </varlistentry>
- *   <varlistentry>
- *     <term>PRIMARY</term>
- *     <listitem>Use the color of the material as set with
- *     cogl_material_set_color()</listitem>
- *   </varlistentry>
- *   <varlistentry>
- *     <term>PREVIOUS</term>
- *     <listitem>Either use the texture color from the previous layer, or
- *     if this is layer 0, use the color of the material as set with
- *     cogl_material_set_color()</listitem>
- *   </varlistentry>
- * </variablelist>
- *
- * <refsect2 id="cogl-Layer-Combine-Examples">
- *   <title>Layer Combine Examples</title>
- *   <para>This is effectively what the default blending is:</para>
- *   <informalexample><programlisting>
- *   RGBA = MODULATE (PREVIOUS, TEXTURE)
- *   </programlisting></informalexample>
- *   <para>This could be used to cross-fade between two images, using
- *   the alpha component of a constant as the interpolator. The constant
- *   color is given by calling cogl_material_set_layer_constant.</para>
- *   <informalexample><programlisting>
- *   RGBA = INTERPOLATE (PREVIOUS, TEXTURE, CONSTANT[A])
- *   </programlisting></informalexample>
- * </refsect2>
- *
- * <note>You can't give a multiplication factor for arguments as you can
- * with blending.</note>
- *
- * Return value: %TRUE if the blend string was successfully parsed, and the
- *   described texture combining is supported by the underlying driver and
- *   or hardware. On failure, %FALSE is returned and @error is set
- *
- * Since: 1.0
- * Deprecated: 1.16: Use cogl_pipeline_set_layer_combine() instead
- */
-COGL_DEPRECATED_FOR (cogl_pipeline_set_layer_combine)
-COGL_EXPORT gboolean
-cogl_material_set_layer_combine (CoglMaterial *material,
-				 int           layer_index,
-				 const char   *blend_string,
-                                 GError      **error);
-
-/**
- * cogl_material_set_layer_combine_constant:
- * @material: A #CoglMaterial object
- * @layer_index: Specifies the layer you want to specify a constant used
- *               for texture combining
- * @constant: The constant color you want
- *
- * When you are using the 'CONSTANT' color source in a layer combine
- * description then you can use this function to define its value.
- *
- * Since: 1.0
- * Deprecated: 1.16: Use cogl_pipeline_set_layer_combine_constant()
- * instead
- */
-COGL_DEPRECATED_FOR (cogl_pipeline_set_layer_combine_constant)
-COGL_EXPORT void
-cogl_material_set_layer_combine_constant (CoglMaterial    *material,
-                                          int              layer_index,
-                                          const CoglColor *constant);
-
-/**
- * cogl_material_set_layer_matrix:
- * @material: A #CoglMaterial object
- * @layer_index: the index for the layer inside @material
- * @matrix: the transformation matrix for the layer
- *
- * This function lets you set a matrix that can be used to e.g. translate
- * and rotate a single layer of a material used to fill your geometry.
- * Deprecated: 1.16: Use cogl_pipeline_set_layer_matrix() instead
- */
-COGL_DEPRECATED_FOR (cogl_pipeline_set_layer_matrix)
-COGL_EXPORT void
-cogl_material_set_layer_matrix (CoglMaterial            *material,
-                                int                      layer_index,
-                                const graphene_matrix_t *matrix);
-
-/**
- * cogl_material_set_layer_filters:
- * @material: A #CoglMaterial object
- * @layer_index: the layer number to change.
- * @min_filter: the filter used when scaling a texture down.
- * @mag_filter: the filter used when magnifying a texture.
- *
- * Changes the decimation and interpolation filters used when a texture is
- * drawn at other scales than 100%.
- * Deprecated: 1.16: Use cogl_pipeline_set_layer_filters() instead
- */
-COGL_DEPRECATED_FOR (cogl_pipeline_set_layer_filters)
-COGL_EXPORT void
-cogl_material_set_layer_filters (CoglMaterial      *material,
-                                 int                layer_index,
-                                 CoglMaterialFilter min_filter,
-                                 CoglMaterialFilter mag_filter);
-
-/**
- * cogl_material_set_layer_point_sprite_coords_enabled:
- * @material: a #CoglHandle to a material.
- * @layer_index: the layer number to change.
- * @enable: whether to enable point sprite coord generation.
- * @error: A return location for a GError, or NULL to ignore errors.
- *
- * When rendering points, if @enable is %TRUE then the texture
- * coordinates for this layer will be replaced with coordinates that
- * vary from 0.0 to 1.0 across the primitive. The top left of the
- * point will have the coordinates 0.0,0.0 and the bottom right will
- * have 1.0,1.0. If @enable is %FALSE then the coordinates will be
- * fixed for the entire point.
- *
- * Return value: %TRUE if the function succeeds, %FALSE otherwise.
- * Since: 1.4
- * Deprecated: 1.16: Use cogl_pipeline_set_layer_point_sprite_coords_enabled()
- *                  instead
- */
-COGL_DEPRECATED_FOR (cogl_pipeline_set_layer_point_sprite_coords_enabled)
-COGL_EXPORT gboolean
-cogl_material_set_layer_point_sprite_coords_enabled (CoglMaterial *material,
-                                                     int           layer_index,
-                                                     gboolean      enable,
-                                                     GError      **error);
-
-G_END_DECLS
-
-#endif /* __COGL_MATERIAL_H__ */
diff --git a/cogl/cogl/driver/gl/cogl-texture-2d-gl-private.h b/cogl/cogl/driver/gl/cogl-texture-2d-gl-private.h
index c10637627..574c10fb0 100644
--- a/cogl/cogl/driver/gl/cogl-texture-2d-gl-private.h
+++ b/cogl/cogl/driver/gl/cogl-texture-2d-gl-private.h
@@ -60,6 +60,13 @@ _cogl_texture_2d_gl_new_from_bitmap (CoglBitmap *bmp,
                                      gboolean can_convert_in_place,
                                      GError **error);
 
+#if defined (COGL_HAS_EGL_SUPPORT)
+gboolean
+cogl_texture_2d_gl_bind_egl_image (CoglTexture2D *tex_2d,
+                                   EGLImageKHR    image,
+                                   GError       **error);
+#endif
+
 #if defined (COGL_HAS_EGL_SUPPORT) && defined (EGL_KHR_image_base)
 CoglTexture2D *
 _cogl_egl_texture_2d_gl_new_from_image (CoglContext *ctx,
diff --git a/cogl/cogl/driver/gl/cogl-texture-2d-gl.c b/cogl/cogl/driver/gl/cogl-texture-2d-gl.c
index 4862dbe2e..23111eabf 100644
--- a/cogl/cogl/driver/gl/cogl-texture-2d-gl.c
+++ b/cogl/cogl/driver/gl/cogl-texture-2d-gl.c
@@ -274,18 +274,11 @@ allocate_from_egl_image (CoglTexture2D *tex_2d,
 
   tex_2d->gl_texture =
     ctx->texture_driver->gen (ctx, GL_TEXTURE_2D, internal_format);
-  _cogl_bind_gl_texture_transient (GL_TEXTURE_2D,
-                                   tex_2d->gl_texture);
-  _cogl_gl_util_clear_gl_errors (ctx);
 
-  ctx->glEGLImageTargetTexture2D (GL_TEXTURE_2D, loader->src.egl_image.image);
-  if (_cogl_gl_util_get_error (ctx) != GL_NO_ERROR)
+  if (!cogl_texture_2d_gl_bind_egl_image (tex_2d,
+                                          loader->src.egl_image.image,
+                                          error))
     {
-      g_set_error_literal (error,
-                           COGL_TEXTURE_ERROR,
-                           COGL_TEXTURE_ERROR_BAD_PARAMETER,
-                           "Could not create a CoglTexture2D from a given "
-                           "EGLImage");
       GE( ctx, glDeleteTextures (1, &tex_2d->gl_texture) );
       return FALSE;
     }
@@ -360,6 +353,31 @@ allocate_custom_egl_image_external (CoglTexture2D *tex_2d,
   return TRUE;
 }
 
+gboolean
+cogl_texture_2d_gl_bind_egl_image (CoglTexture2D *tex_2d,
+                                   EGLImageKHR    image,
+                                   GError       **error)
+{
+  CoglContext *ctx = COGL_TEXTURE (tex_2d)->context;
+
+  _cogl_bind_gl_texture_transient (GL_TEXTURE_2D,
+                                   tex_2d->gl_texture);
+  _cogl_gl_util_clear_gl_errors (ctx);
+
+  ctx->glEGLImageTargetTexture2D (GL_TEXTURE_2D, image);
+  if (_cogl_gl_util_get_error (ctx) != GL_NO_ERROR)
+    {
+      g_set_error_literal (error,
+                           COGL_TEXTURE_ERROR,
+                           COGL_TEXTURE_ERROR_BAD_PARAMETER,
+                           "Could not bind the given EGLImage to a "
+                           "CoglTexture2D");
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
 CoglTexture2D *
 cogl_texture_2d_new_from_egl_image_external (CoglContext *ctx,
                                              int width,
diff --git a/cogl/cogl/driver/gl/cogl-util-gl.c b/cogl/cogl/driver/gl/cogl-util-gl.c
index 80c417913..59d2e74d4 100644
--- a/cogl/cogl/driver/gl/cogl-util-gl.c
+++ b/cogl/cogl/driver/gl/cogl-util-gl.c
@@ -363,13 +363,17 @@ _cogl_context_get_gl_extensions (CoglContext *context)
       char **split_env_disabled_extensions;
       char **src, **dst;
 
-      if (env_disabled_extensions)
-        split_env_disabled_extensions =
-          g_strsplit (env_disabled_extensions,
-                      ",",
-                      0 /* no max tokens */);
+      if (*env_disabled_extensions)
+        {
+          split_env_disabled_extensions =
+            g_strsplit (env_disabled_extensions,
+                        ",",
+                        0 /* no max tokens */);
+        }
       else
-        split_env_disabled_extensions = NULL;
+        {
+          split_env_disabled_extensions = NULL;
+        }
 
       for (dst = ret, src = ret;
            *src;
diff --git a/cogl/cogl/driver/gl/gles/cogl-driver-gles.c b/cogl/cogl/driver/gl/gles/cogl-driver-gles.c
index a9c3e7f32..33d28848c 100644
--- a/cogl/cogl/driver/gl/gles/cogl-driver-gles.c
+++ b/cogl/cogl/driver/gl/gles/cogl-driver-gles.c
@@ -348,6 +348,7 @@ _cogl_driver_update_features (CoglContext *context,
                        COGL_DRIVER_ERROR,
                        COGL_DRIVER_ERROR_INVALID_VERSION,
                        "OpenGL ES 2.0 or better is required");
+      g_strfreev (gl_extensions);
       return FALSE;
     }
 
diff --git a/cogl/cogl/meson.build b/cogl/cogl/meson.build
index a76b9685c..531cf8f43 100644
--- a/cogl/cogl/meson.build
+++ b/cogl/cogl/meson.build
@@ -5,7 +5,6 @@ cdata = configuration_data()
 cdata.set('COGL_HAS_GL', have_gl)
 cdata.set('CLUTTER_COGL_HAS_GL', have_gl)
 cdata.set('COGL_HAS_GLX_SUPPORT', have_glx)
-cdata.set('COGL_HAS_WAYLAND_EGL_SERVER_SUPPORT', have_wayland)
 cdata.set('COGL_HAS_EGL_PLATFORM_XLIB_SUPPORT', have_egl_xlib)
 cdata.set('COGL_HAS_EGL_SUPPORT', have_egl)
 cdata.set('COGL_HAS_X11', have_x11)
@@ -65,7 +64,6 @@ cogl_egl_defines_h = configure_file(
 built_headers += [cogl_gl_header_h]
 
 cogl_deprecated_headers = [
-  'deprecated/cogl-material-compat.h',
   'deprecated/cogl-shader.h',
   'deprecated/cogl-clutter.h',
   'deprecated/cogl-type-casts.h',
@@ -351,7 +349,6 @@ cogl_sources = [
   'cogl-fence.c',
   'cogl-fence-private.h',
   'cogl-scanout.c',
-  'deprecated/cogl-material-compat.c',
   'deprecated/cogl-program.c',
   'deprecated/cogl-program-private.h',
   'deprecated/cogl-auto-texture.c',
@@ -398,12 +395,6 @@ if have_glx
   ]
 endif
 
-if have_wayland
-  cogl_nonintrospected_headers += [
-    'cogl-wayland-server.h',
-  ]
-endif
-
 if have_egl
   cogl_nonintrospected_headers += [
     'cogl-egl.h',
diff --git a/cogl/cogl/winsys/cogl-onscreen-egl.c b/cogl/cogl/winsys/cogl-onscreen-egl.c
index 20b3c60ef..8a587049e 100644
--- a/cogl/cogl/winsys/cogl-onscreen-egl.c
+++ b/cogl/cogl/winsys/cogl-onscreen-egl.c
@@ -242,6 +242,31 @@ cogl_onscreen_egl_swap_region (CoglOnscreen  *onscreen,
     g_warning ("Error reported by eglSwapBuffersRegion");
 }
 
+static void
+cogl_onscreen_egl_queue_damage_region (CoglOnscreen *onscreen,
+                                       const int    *rectangles,
+                                       int           n_rectangles)
+{
+  CoglOnscreenEgl *onscreen_egl = COGL_ONSCREEN_EGL (onscreen);
+  CoglOnscreenEglPrivate *priv =
+    cogl_onscreen_egl_get_instance_private (onscreen_egl);
+  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
+  CoglContext *context = cogl_framebuffer_get_context (framebuffer);
+  CoglRenderer *renderer = context->display->renderer;
+  CoglRendererEGL *egl_renderer = renderer->winsys;
+
+  g_return_if_fail (n_rectangles > 0);
+
+  if (!egl_renderer->pf_eglSetDamageRegion)
+    return;
+
+  if (egl_renderer->pf_eglSetDamageRegion (egl_renderer->edpy,
+                                           priv->egl_surface,
+                                           rectangles,
+                                           n_rectangles) == EGL_FALSE)
+    g_warning ("Error reported by eglSetDamageRegion");
+}
+
 static void
 cogl_onscreen_egl_swap_buffers_with_damage (CoglOnscreen  *onscreen,
                                             const int     *rectangles,
@@ -345,6 +370,8 @@ cogl_onscreen_egl_class_init (CoglOnscreenEglClass *klass)
   object_class->dispose = cogl_onscreen_egl_dispose;
 
   onscreen_class->bind = cogl_onscreen_egl_bind;
+  onscreen_class->queue_damage_region =
+    cogl_onscreen_egl_queue_damage_region;
   onscreen_class->swap_buffers_with_damage =
     cogl_onscreen_egl_swap_buffers_with_damage;
   onscreen_class->swap_region = cogl_onscreen_egl_swap_region;
diff --git a/cogl/cogl/winsys/cogl-winsys-egl-feature-functions.h b/cogl/cogl/winsys/cogl-winsys-egl-feature-functions.h
index e10c01938..53d9bd27b 100644
--- a/cogl/cogl/winsys/cogl-winsys-egl-feature-functions.h
+++ b/cogl/cogl/winsys/cogl-winsys-egl-feature-functions.h
@@ -116,6 +116,17 @@ COGL_WINSYS_FEATURE_FUNCTION (EGLBoolean, eglSwapBuffersWithDamage,
                                EGLint n_rects))
 COGL_WINSYS_FEATURE_END ()
 
+COGL_WINSYS_FEATURE_BEGIN (partial_update,
+                           "KHR\0",
+                           "partial_update\0",
+                           COGL_EGL_WINSYS_FEATURE_BUFFER_AGE)
+COGL_WINSYS_FEATURE_FUNCTION (EGLBoolean, eglSetDamageRegion,
+                              (EGLDisplay dpy,
+                               EGLSurface surface,
+                               const EGLint *rects,
+                               EGLint n_rects))
+COGL_WINSYS_FEATURE_END ()
+
 #if defined(EGL_KHR_fence_sync) || defined(EGL_KHR_reusable_sync)
 COGL_WINSYS_FEATURE_BEGIN (fence_sync,
                            "KHR\0",
diff --git a/cogl/cogl/winsys/cogl-winsys-egl-x11.c b/cogl/cogl/winsys/cogl-winsys-egl-x11.c
index 2c8141fae..bef385a55 100644
--- a/cogl/cogl/winsys/cogl-winsys-egl-x11.c
+++ b/cogl/cogl/winsys/cogl-winsys-egl-x11.c
@@ -43,6 +43,7 @@
 #include "cogl-renderer-private.h"
 #include "cogl-texture-pixmap-x11-private.h"
 #include "cogl-texture-2d-private.h"
+#include "driver/gl/cogl-texture-2d-gl-private.h"
 #include "cogl-texture-2d.h"
 #include "cogl-poll-private.h"
 #include "winsys/cogl-onscreen-egl.h"
@@ -62,6 +63,7 @@ typedef struct _CoglTexturePixmapEGL
 {
   EGLImageKHR image;
   CoglTexture *texture;
+  gboolean bind_tex_image_queued;
 } CoglTexturePixmapEGL;
 #endif
 
@@ -325,10 +327,6 @@ _cogl_winsys_egl_context_init (CoglContext *context,
                                  event_filter_cb,
                                  context);
 
-  COGL_FLAGS_SET (context->winsys_features,
-                  COGL_WINSYS_FEATURE_MULTIPLE_ONSCREEN,
-                  TRUE);
-
   /* We'll manually handle queueing dirty events in response to
    * Expose events from X */
   COGL_FLAGS_SET (context->private_features,
@@ -500,6 +498,9 @@ _cogl_winsys_texture_pixmap_x11_create (CoglTexturePixmapX11 *tex_pixmap)
                                         COGL_EGL_IMAGE_FLAG_NONE,
                                         NULL));
 
+  /* The image is initially bound as part of the creation */
+  egl_tex_pixmap->bind_tex_image_queued = FALSE;
+
   tex_pixmap->winsys = egl_tex_pixmap;
 
   return TRUE;
@@ -534,15 +535,42 @@ _cogl_winsys_texture_pixmap_x11_update (CoglTexturePixmapX11 *tex_pixmap,
                                         CoglTexturePixmapStereoMode stereo_mode,
                                         gboolean needs_mipmap)
 {
+  CoglTexturePixmapEGL *egl_tex_pixmap = tex_pixmap->winsys;
+  CoglTexture2D *tex_2d;
+  GError *error = NULL;
+
   if (needs_mipmap)
     return FALSE;
 
+  if (egl_tex_pixmap->bind_tex_image_queued)
+    {
+      COGL_NOTE (TEXTURE_PIXMAP, "Rebinding GLXPixmap for %p", tex_pixmap);
+
+      tex_2d = COGL_TEXTURE_2D (egl_tex_pixmap->texture);
+
+      if (cogl_texture_2d_gl_bind_egl_image (tex_2d,
+                                             egl_tex_pixmap->image,
+                                             &error))
+        {
+          egl_tex_pixmap->bind_tex_image_queued = FALSE;
+        }
+      else
+        {
+          g_warning ("Failed to rebind EGLImage to CoglTexture2D: %s",
+                     error->message);
+          g_error_free (error);
+        }
+    }
+
   return TRUE;
 }
 
 static void
 _cogl_winsys_texture_pixmap_x11_damage_notify (CoglTexturePixmapX11 *tex_pixmap)
 {
+  CoglTexturePixmapEGL *egl_tex_pixmap = tex_pixmap->winsys;
+
+  egl_tex_pixmap->bind_tex_image_queued = TRUE;
 }
 
 static CoglTexture *
diff --git a/cogl/cogl/winsys/cogl-winsys-egl.c b/cogl/cogl/winsys/cogl-winsys-egl.c
index 8ea1008b5..99afdca8f 100644
--- a/cogl/cogl/winsys/cogl-winsys-egl.c
+++ b/cogl/cogl/winsys/cogl-winsys-egl.c
@@ -674,7 +674,7 @@ _cogl_egl_create_image (CoglContext *ctx,
     egl_ctx = EGL_NO_CONTEXT;
   else
 #endif
-#ifdef COGL_HAS_WAYLAND_EGL_SERVER_SUPPORT
+#ifdef EGL_WL_bind_wayland_display
   /* The WL_bind_wayland_display spec states that EGL_NO_CONTEXT is to be used
    * in conjunction with the EGL_WAYLAND_BUFFER_WL target */
   if (target == EGL_WAYLAND_BUFFER_WL)
diff --git a/cogl/cogl/winsys/cogl-winsys-glx.c b/cogl/cogl/winsys/cogl-winsys-glx.c
index f3738e07c..f3230ef5d 100644
--- a/cogl/cogl/winsys/cogl-winsys-glx.c
+++ b/cogl/cogl/winsys/cogl-winsys-glx.c
@@ -379,11 +379,6 @@ update_base_winsys_features (CoglRenderer *renderer)
                   COGL_WINSYS_FEATURE_VBLANK_COUNTER,
                   FALSE);
 
-
-  COGL_FLAGS_SET (glx_renderer->base_winsys_features,
-                  COGL_WINSYS_FEATURE_MULTIPLE_ONSCREEN,
-                  TRUE);
-
   /* Because of the direct-context dependency, the VBLANK_WAIT feature
    * doesn't reflect the presence of GLX_SGI_video_sync.
    */
diff --git a/cogl/tests/conform/mutter-cogl.test.in b/cogl/tests/conform/mutter-cogl.test.in
index fae4f5c56..0546d15af 100644
--- a/cogl/tests/conform/mutter-cogl.test.in
+++ b/cogl/tests/conform/mutter-cogl.test.in
@@ -1,4 +1,6 @@
 [Test]
 Type=session
-TestEnvironment=COGL_TEST_VERBOSE=1
-Exec=sh -c "cd @libexecdir@/installed-tests/mutter-@apiversion@/cogl/conform; xvfb-run -a -s '+iglx -noreset' ./run-tests.sh ./config.env ./test-conformance ./unit-tests"
+# Can't use TestEnvironment for COGL_TEST_VERBOSE until there's a solution
+# for https://gitlab.gnome.org/GNOME/gnome-desktop-testing/-/issues/1,
+# and anyway we'd still need to use the shell to 'cd'
+Exec=sh -ec "export COGL_TEST_VERBOSE=1; cd @libexecdir@/installed-tests/mutter-@apiversion@/cogl/conform; xvfb-run -a -s '+iglx -noreset' ./run-tests.sh ./config.env ./test-conformance ./unit-tests"
diff --git a/cogl/tests/conform/test-multitexture.c b/cogl/tests/conform/test-multitexture.c
index 1d438fd67..625720673 100644
--- a/cogl/tests/conform/test-multitexture.c
+++ b/cogl/tests/conform/test-multitexture.c
@@ -104,7 +104,7 @@ on_paint (ClutterActor        *actor,
           TestState           *state)
 {
   CoglHandle tex0, tex1;
-  CoglHandle material;
+  CoglPipeline *pipeline;
   gboolean status;
   GError *error = NULL;
   float tex_coords[] = {
@@ -115,27 +115,27 @@ on_paint (ClutterActor        *actor,
   tex0 = make_texture (0x00);
   tex1 = make_texture (0x11);
 
-  material = cogl_material_new ();
+  pipeline = cogl_pipeline_new ();
 
   /* An arbitrary color which should be replaced by the first texture layer */
-  cogl_material_set_color4ub (material, 0x80, 0x80, 0x80, 0x80);
-  cogl_material_set_blend (material, "RGBA = ADD (SRC_COLOR, 0)", NULL);
+  cogl_pipeline_set_color4ub (pipeline, 0x80, 0x80, 0x80, 0x80);
+  cogl_pipekine_set_blend (pipeline, "RGBA = ADD (SRC_COLOR, 0)", NULL);
 
-  cogl_material_set_layer (material, 0, tex0);
-  cogl_material_set_layer_combine (material, 0,
+  cogl_pipeline_set_layer_texture (pipeline, 0, tex0);
+  cogl_pipeline_set_layer_combine (pipeline, 0,
                                    "RGBA = REPLACE (TEXTURE)", NULL);
   /* We'll use nearest filtering mode on the textures, otherwise the
      edge of the quad can pull in texels from the neighbouring
      quarters of the texture due to imprecision */
-  cogl_material_set_layer_filters (material, 0,
-                                   COGL_MATERIAL_FILTER_NEAREST,
-                                   COGL_MATERIAL_FILTER_NEAREST);
-
-  cogl_material_set_layer (material, 1, tex1);
-  cogl_material_set_layer_filters (material, 1,
-                                   COGL_MATERIAL_FILTER_NEAREST,
-                                   COGL_MATERIAL_FILTER_NEAREST);
-  status = cogl_material_set_layer_combine (material, 1,
+  cogl_pipeline_set_layer_filters (pipeline, 0,
+                                   COGL_PIPELINE_FILTER_NEAREST,
+                                   COGL_PIPELINE_FILTER_NEAREST);
+
+  cogl_pipeline_set_layer (pipeline, 1, tex1);
+  cogl_pipeline_set_layer_filters (pipeline, 1,
+                                   COGL_PIPELINE_FILTER_NEAREST,
+                                   COGL_PIPELINE_FILTER_NEAREST);
+  status = cogl_pipeline_set_layer_combine (pipeline, 1,
                                             "RGBA = ADD (PREVIOUS, TEXTURE)",
                                             &error);
   if (!status)
@@ -147,11 +147,11 @@ on_paint (ClutterActor        *actor,
                error->message);
     }
 
-  cogl_set_source (material);
+  cogl_set_source (pipeline);
   cogl_rectangle_with_multitexture_coords (0, 0, QUAD_WIDTH, QUAD_WIDTH,
                                            tex_coords, 8);
 
-  cogl_object_unref (material);
+  cogl_object_unref (pipeline);
   cogl_object_unref (tex0);
   cogl_object_unref (tex1);
 
diff --git a/cogl/tests/conform/test-texture-mipmaps.c b/cogl/tests/conform/test-texture-mipmaps.c
index 4bab5e829..eb9e0cd31 100644
--- a/cogl/tests/conform/test-texture-mipmaps.c
+++ b/cogl/tests/conform/test-texture-mipmaps.c
@@ -50,27 +50,27 @@ on_paint (ClutterActor        *actor,
           TestState           *state)
 {
   CoglHandle tex;
-  CoglHandle material;
+  CoglPipeline *pipeline;
   uint8_t pixels[8];
 
   tex = make_texture ();
-  material = cogl_material_new ();
-  cogl_material_set_layer (material, 0, tex);
+  pipeline = cogl_pipeline_new ();
+  cogl_pipeline_set_layer (pipeline, 0, tex);
   cogl_object_unref (tex);
 
   /* Render a 1x1 pixel quad without mipmaps */
-  cogl_set_source (material);
-  cogl_material_set_layer_filters (material, 0,
-                                   COGL_MATERIAL_FILTER_NEAREST,
-                                   COGL_MATERIAL_FILTER_NEAREST);
+  cogl_set_source (pipeline);
+  cogl_pipeline_set_layer_filters (pipeline, 0,
+                                   COGL_PIPELINE_FILTER_NEAREST,
+                                   COGL_PIPELINE_FILTER_NEAREST);
   cogl_rectangle (0, 0, 1, 1);
   /* Then with mipmaps */
-  cogl_material_set_layer_filters (material, 0,
-                                   COGL_MATERIAL_FILTER_NEAREST_MIPMAP_NEAREST,
-                                   COGL_MATERIAL_FILTER_NEAREST);
+  cogl_pipeline_set_layer_filters (pipeline, 0,
+                                   COGL_PIPELINE_FILTER_NEAREST_MIPMAP_NEAREST,
+                                   COGL_PIPELINE_FILTER_NEAREST);
   cogl_rectangle (1, 0, 2, 1);
 
-  cogl_object_unref (material);
+  cogl_object_unref (pipeline);
 
   /* Read back the two pixels we rendered */
   cogl_read_pixels (0, 0, 2, 1,
diff --git a/cogl/tests/conform/test-texture-pixmap-x11.c b/cogl/tests/conform/test-texture-pixmap-x11.c
index 41555266f..f8eb813f6 100644
--- a/cogl/tests/conform/test-texture-pixmap-x11.c
+++ b/cogl/tests/conform/test-texture-pixmap-x11.c
@@ -144,23 +144,23 @@ on_after_paint (ClutterActor        *actor,
                 ClutterPaintContext *paint_context,
                 TestState           *state)
 {
-  CoglHandle material;
+  CoglPipeline *pipeline;
 
-  material = cogl_material_new ();
-  cogl_material_set_layer (material, 0, state->tfp);
+  pipeline = cogl_pipeline_new ();
+  cogl_pipeline_set_layer (pipeline, 0, state->tfp);
   if (state->frame_count == FRAME_COUNT_MIPMAP)
     {
-      const CoglMaterialFilter min_filter =
-        COGL_MATERIAL_FILTER_NEAREST_MIPMAP_NEAREST;
-      cogl_material_set_layer_filters (material, 0,
+      const CoglPipelineFilter min_filter =
+        COGL_PIPELINE_FILTER_NEAREST_MIPMAP_NEAREST;;
+      cogl_pipeline_set_layer_filters (pipeline, 0,
                                        min_filter,
-                                       COGL_MATERIAL_FILTER_NEAREST);
+                                       COGL_PIPELINE_FILTER_NEAREST);
     }
   else
-    cogl_material_set_layer_filters (material, 0,
-                                     COGL_MATERIAL_FILTER_NEAREST,
-                                     COGL_MATERIAL_FILTER_NEAREST);
-  cogl_set_source (material);
+    cogl_pipeline_set_layer_filters (pipeline, 0,
+                                     COGL_PIPELINE_FILTER_NEAREST,
+                                     COGL_PIPELINE_FILTER_NEAREST);
+  cogl_set_source (pipeline);
 
   cogl_rectangle (0, 0, PIXMAP_WIDTH, PIXMAP_HEIGHT);
 
diff --git a/data/61-mutter.rules b/data/61-mutter.rules
index edc03e6c1..7c2b96349 100644
--- a/data/61-mutter.rules
+++ b/data/61-mutter.rules
@@ -1,5 +1,2 @@
 DRIVERS=="i915", SUBSYSTEM=="drm", TAG+="mutter-device-disable-kms-modifiers"
-DRIVERS=="nouveau", SUBSYSTEM=="drm", TAG+="mutter-device-disable-kms-modifiers"
-DRIVERS=="amdgpu", SUBSYSTEM=="drm", TAG+="mutter-device-disable-kms-modifiers"
-DRIVERS=="radeon", SUBSYSTEM=="drm", TAG+="mutter-device-disable-kms-modifiers"
 ENV{ID_PATH}=="platform-vkms", TAG+="mutter-device-ignore"
diff --git a/data/dbus-interfaces/meson.build b/data/dbus-interfaces/meson.build
new file mode 100644
index 000000000..0cdb8441e
--- /dev/null
+++ b/data/dbus-interfaces/meson.build
@@ -0,0 +1 @@
+dbus_interfaces_dir = meson.current_source_dir()
diff --git a/data/dbus-interfaces/org.freedesktop.RealtimeKit1.xml b/data/dbus-interfaces/org.freedesktop.RealtimeKit1.xml
new file mode 100644
index 000000000..305e767b1
--- /dev/null
+++ b/data/dbus-interfaces/org.freedesktop.RealtimeKit1.xml
@@ -0,0 +1,42 @@
+<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
+"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
+<node>
+        <interface name="org.freedesktop.RealtimeKit1">
+                <method name="MakeThreadRealtime">
+                        <arg name="thread" type="t" direction="in"/>
+                        <arg name="priority" type="u" direction="in"/>
+                </method>
+                <method name="MakeThreadRealtimeWithPID">
+                        <arg name="process" type="t" direction="in"/>
+                        <arg name="thread" type="t" direction="in"/>
+                        <arg name="priority" type="u" direction="in"/>
+                </method>
+                <method name="MakeThreadHighPriority">
+                        <arg name="thread" type="t" direction="in"/>
+                        <arg name="priority" type="i" direction="in"/>
+                </method>
+                <method name="MakeThreadHighPriorityWithPID">
+                        <arg name="process" type="t" direction="in"/>
+                        <arg name="thread" type="t" direction="in"/>
+                        <arg name="priority" type="i" direction="in"/>
+                </method>
+                <method name="ResetKnown"/>
+                <method name="ResetAll"/>
+                <method name="Exit"/>
+                <property name="RTTimeUSecMax" type="x" access="read"/>
+                <property name="MaxRealtimePriority" type="i" access="read"/>
+                <property name="MinNiceLevel" type="i" access="read"/>
+        </interface>
+        <interface name="org.freedesktop.DBus.Properties">
+                <method name="Get">
+                       <arg name="interface" direction="in" type="s"/>
+                       <arg name="property" direction="in" type="s"/>
+                       <arg name="value" direction="out" type="v"/>
+                </method>
+        </interface>
+        <interface name="org.freedesktop.DBus.Introspectable">
+                <method name="Introspect">
+                        <arg name="data" type="s" direction="out"/>
+                </method>
+        </interface>
+</node>
diff --git a/src/org.freedesktop.login1.xml b/data/dbus-interfaces/org.freedesktop.login1.xml
similarity index 100%
rename from src/org.freedesktop.login1.xml
rename to data/dbus-interfaces/org.freedesktop.login1.xml
diff --git a/src/org.gnome.Mutter.DisplayConfig.xml b/data/dbus-interfaces/org.gnome.Mutter.DisplayConfig.xml
similarity index 100%
rename from src/org.gnome.Mutter.DisplayConfig.xml
rename to data/dbus-interfaces/org.gnome.Mutter.DisplayConfig.xml
diff --git a/src/org.gnome.Mutter.IdleMonitor.xml b/data/dbus-interfaces/org.gnome.Mutter.IdleMonitor.xml
similarity index 100%
rename from src/org.gnome.Mutter.IdleMonitor.xml
rename to data/dbus-interfaces/org.gnome.Mutter.IdleMonitor.xml
diff --git a/src/org.gnome.Mutter.RemoteDesktop.xml b/data/dbus-interfaces/org.gnome.Mutter.RemoteDesktop.xml
similarity index 100%
rename from src/org.gnome.Mutter.RemoteDesktop.xml
rename to data/dbus-interfaces/org.gnome.Mutter.RemoteDesktop.xml
diff --git a/src/org.gnome.Mutter.ScreenCast.xml b/data/dbus-interfaces/org.gnome.Mutter.ScreenCast.xml
similarity index 97%
rename from src/org.gnome.Mutter.ScreenCast.xml
rename to data/dbus-interfaces/org.gnome.Mutter.ScreenCast.xml
index d9f1f4435..afc09c61b 100644
--- a/src/org.gnome.Mutter.ScreenCast.xml
+++ b/data/dbus-interfaces/org.gnome.Mutter.ScreenCast.xml
@@ -190,6 +190,14 @@
   -->
   <interface name="org.gnome.Mutter.ScreenCast.Stream">
 
+    <!--
+	Start:
+	@short_description: Start new stream
+
+	Start a stream of an already started session.
+    -->
+    <method name="Start"/>
+
     <!--
 	PipeWireStreamAdded:
 	@short_description: Pipewire stream added
diff --git a/data/meson.build b/data/meson.build
index b55ded908..ae9832199 100644
--- a/data/meson.build
+++ b/data/meson.build
@@ -64,3 +64,5 @@ if have_libgudev
     install_dir: join_paths(udev_dir, 'rules.d'),
   )
 endif
+
+subdir('dbus-interfaces')
diff --git a/data/org.gnome.mutter.gschema.xml.in b/data/org.gnome.mutter.gschema.xml.in
index 23fa9f3ad..f93eb70fe 100644
--- a/data/org.gnome.mutter.gschema.xml.in
+++ b/data/org.gnome.mutter.gschema.xml.in
@@ -1,4 +1,13 @@
 <schemalist>
+
+  <flags id="org.gnome.mutter.MetaExperimentalFeature">
+    <value nick="scale-monitor-framebuffer" value="1"/>
+    <value nick="kms-modifiers" value="2"/>
+    <value nick="rt-scheduler" value="4"/>
+    <value nick="dma-buf-screen-sharing" value="8"/>
+    <value nick="autoclose-xwayland" value="16"/>
+  </flags>
+
   <schema id="org.gnome.mutter" path="/org/gnome/mutter/"
           gettext-domain="@GETTEXT_DOMAIN@">
 
@@ -102,7 +111,8 @@
       </description>
     </key>
 
-    <key name="experimental-features" type="as">
+    <key name="experimental-features"
+        flags='org.gnome.mutter.MetaExperimentalFeature'>
       <default>[]</default>
       <summary>Enable experimental features</summary>
       <description>
@@ -121,12 +131,15 @@
                                         to manage HiDPI monitors. Does not
                                         require a restart.
 
+        • “kms-modifiers”             — makes mutter always allocate scanout
+                                        buffers with explicit modifiers, if
+                                        supported by the driver. Requires a
+                                        restart.
+
         • “rt-scheduler”              — makes mutter request a low priority
-                                        real-time scheduling. The executable
-                                        or user must have CAP_SYS_NICE.
-                                        Requires a restart.
+                                        real-time scheduling. Requires a restart.
 
-        • “dma-buf-screen-sharing"    — enables DMA buffered screen sharing. This
+        • “dma-buf-screen-sharing”    — enables DMA buffered screen sharing. This
                                         is already enabled by default when using
                                         the i915 driver, but disabled for 
                                         everything else. Requires a restart.
diff --git a/doc/man/mutter.1 b/doc/man/mutter.1
index 998d0f826..6d9122cde 100644
--- a/doc/man/mutter.1
+++ b/doc/man/mutter.1
@@ -19,7 +19,7 @@
 MUTTER \- Clutter based compositing GTK2 Window Manager
 .SH SYNOPSIS
 .B mutter
-[\-\-display=\fIDISPLAY\fP] [\-\-replace] [\-\-sm\-client\-id=\fIID\fP] [\-\-sm\-disable] [\-\-sm\-save\-file=\fIFILENAME\fP] [\-\-version] [\-\-help]
+[\-\-display=\fIDISPLAY\fP] [\-\-replace] [\-\-sm\-client\-id=\fIID\fP] [\-\-sm\-disable] [\-\-sm\-save\-file=\fIFILENAME\fP] [\-\-version] [\-\-help] [[\-\-] command [argument...]]
 .SH DESCRIPTION
 This manual page documents briefly
 .B mutter\fP.
diff --git a/meson.build b/meson.build
index d3a6bf0ca..d110d55cd 100644
--- a/meson.build
+++ b/meson.build
@@ -1,15 +1,13 @@
 project('mutter', 'c',
-  version: '41.4',
+  version: '41.0',
   meson_version: '>= 0.53.0',
   license: 'GPLv2+'
 )
 
 split_version = meson.project_version().split('.')
 
-# Automatically increase API version each development cycle,
-# starting with 0 in 3.23.x
-api_version = split_version[0].to_int() - 32
-libmutter_api_version = '@0@'.format(api_version)
+# API version, bump each development cycle
+libmutter_api_version = '10'
 
 mutter_srcdir = meson.current_source_dir()
 mutter_builddir = meson.current_build_dir()
@@ -44,10 +42,10 @@ gudev_req = '>= 232'
 
 # wayland version requirements
 wayland_server_req = '>= 1.18'
-wayland_protocols_req = '>= 1.21'
+wayland_protocols_req = '>= 1.24'
 
 # native backend version requirements
-libinput_req = '>= 1.18.0'
+libinput_req = '>= 1.19.0'
 gbm_req = '>= 17.3'
 
 # screen cast version requirements
@@ -85,7 +83,6 @@ libmutter_name = 'mutter-' + libmutter_api_version
 
 mutter_installed_tests_datadir = join_paths(
   datadir, 'installed-tests', libmutter_name)
-
 mutter_installed_tests_libexecdir = join_paths(
   libexecdir, 'installed-tests', libmutter_name)
 
@@ -305,6 +302,8 @@ if have_tests
     exe_wrapper: default_test_wrappers,
   )
 
+  add_test_setup('plain')
+
   add_test_setup('CI',
     env: [
       'MUTTER_DEBUG_DUMMY_MODE_SPECS=800x600@10.0',
diff --git a/po/es.po b/po/es.po
index de61bb258..d3c344c52 100644
--- a/po/es.po
+++ b/po/es.po
@@ -13,7 +13,7 @@ msgid ""
 msgstr ""
 "Project-Id-Version: mutter.master\n"
 "Report-Msgid-Bugs-To: https://gitlab.gnome.org/GNOME/mutter/issues\n"
-"POT-Creation-Date: 2021-07-27 14:35+0000\n"
+"POT-Creation-Date: 2021-11-04 20:03+0000\n"
 "PO-Revision-Date: 2021-08-17 13:28+0200\n"
 "Last-Translator: Daniel Mustieles <daniel.mustieles@gmail.com>\n"
 "Language-Team: Spanish - Spain <gnome-es-list@gnome.org>\n"
@@ -184,10 +184,6 @@ msgstr "Sistema"
 msgid "Show the run command prompt"
 msgstr "Mostrar el elemento «ejecutar comando»"
 
-#: data/50-mutter-system.xml:10
-msgid "Show the activities overview"
-msgstr "Mostrar la vista de actividades"
-
 #: data/50-mutter-wayland.xml:8
 msgid "Restore the keyboard shortcuts"
 msgstr "Restaurar los atajos de teclado"
@@ -256,11 +252,11 @@ msgstr "Maximizar la ventana verticalmente"
 msgid "Maximize window horizontally"
 msgstr "Maximizar la ventana horizontalmente"
 
-#: data/50-mutter-windows.xml:41 data/org.gnome.mutter.gschema.xml.in:166
+#: data/50-mutter-windows.xml:41 data/org.gnome.mutter.gschema.xml.in:179
 msgid "View split on left"
 msgstr "Ver división a la izquierda"
 
-#: data/50-mutter-windows.xml:45 data/org.gnome.mutter.gschema.xml.in:171
+#: data/50-mutter-windows.xml:45 data/org.gnome.mutter.gschema.xml.in:184
 msgid "View split on right"
 msgstr "Ver división a la derecha"
 
@@ -268,12 +264,12 @@ msgstr "Ver división a la derecha"
 msgid "Mutter"
 msgstr "Mutter"
 
-#: data/org.gnome.mutter.gschema.xml.in:7
+#: data/org.gnome.mutter.gschema.xml.in:16
 msgid "Modifier to use for extended window management operations"
 msgstr ""
 "Modificador que usar para extender las operaciones de gestión sobre ventanas"
 
-#: data/org.gnome.mutter.gschema.xml.in:8
+#: data/org.gnome.mutter.gschema.xml.in:17
 msgid ""
 "This key will initiate the “overlay”, which is a combination window overview "
 "and application launching system. The default is intended to be the “Windows "
@@ -283,14 +279,14 @@ msgstr ""
 "Esta clave iniciará el «revestimiento» («overlay»), que es una combinación "
 "de vista general de la ventana y el sistema de lanzamiento de aplicaciones. "
 "Lo predeterminado está pensado para la «tecla de Windows». Se espera que "
-"esta combinación de tecla sea la predeterminada o se establezca a una cadena "
+"este atajo del teclado sea el predeterminado o se establezca a una cadena "
 "vacía."
 
-#: data/org.gnome.mutter.gschema.xml.in:20
+#: data/org.gnome.mutter.gschema.xml.in:29
 msgid "Attach modal dialogs"
 msgstr "Adjuntar diálogos modales"
 
-#: data/org.gnome.mutter.gschema.xml.in:21
+#: data/org.gnome.mutter.gschema.xml.in:30
 msgid ""
 "When true, instead of having independent titlebars, modal dialogs appear "
 "attached to the titlebar of the parent window and are moved together with "
@@ -300,13 +296,13 @@ msgstr ""
 "aparecen diálogos modales adjuntos a la barra de título de la ventana padre "
 "y se mueven junto con la ventana padre."
 
-#: data/org.gnome.mutter.gschema.xml.in:30
+#: data/org.gnome.mutter.gschema.xml.in:39
 msgid "Enable edge tiling when dropping windows on screen edges"
 msgstr ""
 "Activar el mosaico en los bordes al arrastrar ventanas a los bordes de la "
 "ventana"
 
-#: data/org.gnome.mutter.gschema.xml.in:31
+#: data/org.gnome.mutter.gschema.xml.in:40
 msgid ""
 "If enabled, dropping windows on vertical screen edges maximizes them "
 "vertically and resizes them horizontally to cover half of the available "
@@ -317,11 +313,11 @@ msgstr ""
 "mitad del área disponible. Arrastrar ventanas al borde superior de la "
 "pantalla las maximiza por completo."
 
-#: data/org.gnome.mutter.gschema.xml.in:40
+#: data/org.gnome.mutter.gschema.xml.in:49
 msgid "Workspaces are managed dynamically"
 msgstr "Las áreas de trabajo se gestionan dinámicamente"
 
-#: data/org.gnome.mutter.gschema.xml.in:41
+#: data/org.gnome.mutter.gschema.xml.in:50
 msgid ""
 "Determines whether workspaces are managed dynamically or whether there’s a "
 "static number of workspaces (determined by the num-workspaces key in org."
@@ -331,11 +327,11 @@ msgstr ""
 "número estático de áreas de trabajo (determinado por la clave «num-"
 "workspaces» en «org.gnome.desktop.wm.preferences»)."
 
-#: data/org.gnome.mutter.gschema.xml.in:50
+#: data/org.gnome.mutter.gschema.xml.in:59
 msgid "Workspaces only on primary"
 msgstr "Áreas de trabajo sólo en el primario"
 
-#: data/org.gnome.mutter.gschema.xml.in:51
+#: data/org.gnome.mutter.gschema.xml.in:60
 msgid ""
 "Determines whether workspace switching should happen for windows on all "
 "monitors or only for windows on the primary monitor."
@@ -343,11 +339,11 @@ msgstr ""
 "Determina si el cambio entre áreas de trabajo debería suceder para las "
 "ventanas en todos los monitores o sólo para ventanas en el monitor primario."
 
-#: data/org.gnome.mutter.gschema.xml.in:59
+#: data/org.gnome.mutter.gschema.xml.in:68
 msgid "No tab popup"
 msgstr "No hay pestaña emergente"
 
-#: data/org.gnome.mutter.gschema.xml.in:60
+#: data/org.gnome.mutter.gschema.xml.in:69
 msgid ""
 "Determines whether the use of popup and highlight frame should be disabled "
 "for window cycling."
@@ -355,11 +351,11 @@ msgstr ""
 "Determina si el uso de ventanas emergentes y marcos resaltados se debe "
 "desactivar al cambiar entre ventanas."
 
-#: data/org.gnome.mutter.gschema.xml.in:68
+#: data/org.gnome.mutter.gschema.xml.in:77
 msgid "Delay focus changes until the pointer stops moving"
 msgstr "Retrasar el cambio de foco hasta detener el puntero"
 
-#: data/org.gnome.mutter.gschema.xml.in:69
+#: data/org.gnome.mutter.gschema.xml.in:78
 msgid ""
 "If set to true, and the focus mode is either “sloppy” or “mouse” then the "
 "focus will not be changed immediately when entering a window, but only after "
@@ -369,11 +365,11 @@ msgstr ""
 "entonces el foco no se cambiará inmediatamente al entrar en una ventana, "
 "pero sí después de dejar quieto el puntero."
 
-#: data/org.gnome.mutter.gschema.xml.in:79
+#: data/org.gnome.mutter.gschema.xml.in:88
 msgid "Draggable border width"
 msgstr "Anchura arrastrable del borde"
 
-#: data/org.gnome.mutter.gschema.xml.in:80
+#: data/org.gnome.mutter.gschema.xml.in:89
 msgid ""
 "The amount of total draggable borders. If the theme’s visible borders are "
 "not enough, invisible borders will be added to meet this value."
@@ -382,13 +378,13 @@ msgstr ""
 "del tema no son suficientes, se añadirán bordes invisibles para satisfacer "
 "este valor."
 
-#: data/org.gnome.mutter.gschema.xml.in:89
+#: data/org.gnome.mutter.gschema.xml.in:98
 msgid "Auto maximize nearly monitor sized windows"
 msgstr ""
 "Maximizar automáticamente las ventanas que casi tengan el tamaño de la "
 "pantalla"
 
-#: data/org.gnome.mutter.gschema.xml.in:90
+#: data/org.gnome.mutter.gschema.xml.in:99
 msgid ""
 "If enabled, new windows that are initially the size of the monitor "
 "automatically get maximized."
@@ -396,11 +392,11 @@ msgstr ""
 "Si está activada, las ventanas nuevas que inicialmente tienen el tamaño de "
 "la pantalla, se maximizan."
 
-#: data/org.gnome.mutter.gschema.xml.in:98
+#: data/org.gnome.mutter.gschema.xml.in:107
 msgid "Place new windows in the center"
 msgstr "Colocar las ventanas nuevas en el centro"
 
-#: data/org.gnome.mutter.gschema.xml.in:99
+#: data/org.gnome.mutter.gschema.xml.in:108
 msgid ""
 "When true, the new windows will always be put in the center of the active "
 "screen of the monitor."
@@ -408,11 +404,28 @@ msgstr ""
 "Cuando es cierto, las ventanas nuevas se colocarán siempre en el centro de "
 "la pantalla activa del monitor."
 
-#: data/org.gnome.mutter.gschema.xml.in:107
+#: data/org.gnome.mutter.gschema.xml.in:117
 msgid "Enable experimental features"
 msgstr "Activar las características experimentales"
 
-#: data/org.gnome.mutter.gschema.xml.in:108
+#: data/org.gnome.mutter.gschema.xml.in:118
+#, fuzzy
+#| msgid ""
+#| "To enable experimental features, add the feature keyword to the list. "
+#| "Whether the feature requires restarting the compositor depends on the "
+#| "given feature. Any experimental feature is not required to still be "
+#| "available, or configurable. Don’t expect adding anything in this setting "
+#| "to be future proof. Currently possible keywords: • “scale-monitor-"
+#| "framebuffer” — makes mutter default to layout logical monitors in a "
+#| "logical pixel coordinate space, while scaling monitor framebuffers "
+#| "instead of window content, to manage HiDPI monitors. Does not require a "
+#| "restart. • “rt-scheduler” — makes mutter request a low priority real-time "
+#| "scheduling. The executable or user must have CAP_SYS_NICE. Requires a "
+#| "restart. • “dma-buf-screen-sharing\" — enables DMA buffered screen "
+#| "sharing. This is already enabled by default when using the i915 driver, "
+#| "but disabled for everything else. Requires a restart. • “autoclose-"
+#| "xwayland” — automatically terminates Xwayland if all relevant X11 clients "
+#| "are gone. Does not require a restart."
 msgid ""
 "To enable experimental features, add the feature keyword to the list. "
 "Whether the feature requires restarting the compositor depends on the given "
@@ -421,13 +434,15 @@ msgid ""
 "proof. Currently possible keywords: • “scale-monitor-framebuffer” — makes "
 "mutter default to layout logical monitors in a logical pixel coordinate "
 "space, while scaling monitor framebuffers instead of window content, to "
-"manage HiDPI monitors. Does not require a restart. • “rt-scheduler” — makes "
-"mutter request a low priority real-time scheduling. The executable or user "
-"must have CAP_SYS_NICE. Requires a restart. • “dma-buf-screen-sharing\" — "
-"enables DMA buffered screen sharing. This is already enabled by default when "
-"using the i915 driver, but disabled for everything else. Requires a restart. "
-"• “autoclose-xwayland” — automatically terminates Xwayland if all relevant "
-"X11 clients are gone. Does not require a restart."
+"manage HiDPI monitors. Does not require a restart. • “kms-modifiers” — makes "
+"mutter always advertise valid buffer modifiers on Wayland. This is currently "
+"not the case when using the i915 driver. Does not require a restart. • “rt-"
+"scheduler” — makes mutter request a low priority real-time scheduling. "
+"Requires a restart. • “dma-buf-screen-sharing” — enables DMA buffered screen "
+"sharing. This is already enabled by default when using the i915 driver, but "
+"disabled for everything else. Requires a restart. • “autoclose-xwayland” — "
+"automatically terminates Xwayland if all relevant X11 clients are gone. Does "
+"not require a restart."
 msgstr ""
 "Para activar las características experimentales, añada la palabra clave de "
 "la característica a la lista. Depende de la característica que se deba "
@@ -448,19 +463,19 @@ msgstr ""
 "— termina Xwayland automáticamente si todos los clientes X11 relevantes ya "
 "no están. No requiere un reinicio."
 
-#: data/org.gnome.mutter.gschema.xml.in:143
+#: data/org.gnome.mutter.gschema.xml.in:156
 msgid "Modifier to use to locate the pointer"
 msgstr "Modificador que usar para encontrar el puntero"
 
-#: data/org.gnome.mutter.gschema.xml.in:144
+#: data/org.gnome.mutter.gschema.xml.in:157
 msgid "This key will initiate the “locate pointer” action."
 msgstr "Esta tecla iniciará la acción de encontrar el puntero."
 
-#: data/org.gnome.mutter.gschema.xml.in:151
+#: data/org.gnome.mutter.gschema.xml.in:164
 msgid "Timeout for check-alive ping"
 msgstr "Tiempo de espera para la comprobación de ping"
 
-#: data/org.gnome.mutter.gschema.xml.in:152
+#: data/org.gnome.mutter.gschema.xml.in:165
 msgid ""
 "Number of milliseconds a client has to respond to a ping request in order to "
 "not be detected as frozen. Using 0 will disable the alive check completely."
@@ -468,19 +483,19 @@ msgstr ""
 "Número de milisegundos que tiene un cliente para responder a ping y que no "
 "se le detecte como caído. Usar 0 desactivará esta comprobación."
 
-#: data/org.gnome.mutter.gschema.xml.in:176
+#: data/org.gnome.mutter.gschema.xml.in:189
 msgid "Select window from tab popup"
 msgstr "Seleccionar ventana de la pestaña emergente"
 
-#: data/org.gnome.mutter.gschema.xml.in:181
+#: data/org.gnome.mutter.gschema.xml.in:194
 msgid "Cancel tab popup"
 msgstr "Cancelar pestaña emergente"
 
-#: data/org.gnome.mutter.gschema.xml.in:186
+#: data/org.gnome.mutter.gschema.xml.in:199
 msgid "Switch monitor configurations"
 msgstr "Cambiar la configuración del monitor"
 
-#: data/org.gnome.mutter.gschema.xml.in:191
+#: data/org.gnome.mutter.gschema.xml.in:204
 msgid "Rotates the built-in monitor configuration"
 msgstr "Rota la configuración del monitor empotrado"
 
@@ -607,26 +622,26 @@ msgstr ""
 "tiene efecto si XWayland ha construido sin soporte para esas extensiones. "
 "XWayland necesita reiniciarse para que este cambio surta efecto."
 
-#: src/backends/meta-monitor.c:235
+#: src/backends/meta-monitor.c:246
 msgid "Built-in display"
 msgstr "Pantalla integrada"
 
-#: src/backends/meta-monitor.c:264
+#: src/backends/meta-monitor.c:275
 msgid "Unknown"
 msgstr "Desconocida"
 
-#: src/backends/meta-monitor.c:266
+#: src/backends/meta-monitor.c:277
 msgid "Unknown Display"
 msgstr "Pantalla desconocida"
 
-#: src/backends/meta-monitor.c:274
+#: src/backends/meta-monitor.c:285
 #, c-format
 msgctxt ""
 "This is a monitor vendor name, followed by a size in inches, like 'Dell 15\"'"
 msgid "%s %s"
 msgstr "%s %s"
 
-#: src/backends/meta-monitor.c:282
+#: src/backends/meta-monitor.c:293
 #, c-format
 msgctxt ""
 "This is a monitor vendor name followed by product/model name where size in "
@@ -639,28 +654,9 @@ msgstr "%s %s"
 msgid "Compositor"
 msgstr "Compositor"
 
-#: src/backends/x11/meta-clutter-backend-x11.c:237
-#| msgid "X Display to use"
-msgid "X display to use"
-msgstr "Pantalla X que usar"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:243
-#| msgid "X Display to use"
-msgid "X screen to use"
-msgstr "Pantalla X que usar"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:248
-#: src/core/meta-context-main.c:583
-msgid "Make X calls synchronous"
-msgstr "Hacer que las llamadas a las X sean síncronas"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:254
-msgid "Disable XInput support"
-msgstr "Desactivar soporte de XInput"
-
 #. This probably means that a non-WM compositor like xcompmgr is running;
 #. * we have no way to get it to exit
-#: src/compositor/compositor.c:513
+#: src/compositor/compositor.c:504
 #, c-format
 msgid ""
 "Another compositing manager is already running on screen %i on display “%s”."
@@ -698,55 +694,59 @@ msgstr "_Forzar la salida"
 msgid "_Wait"
 msgstr "_Esperar"
 
-#: src/core/meta-context-main.c:553
+#: src/core/meta-context-main.c:555
 msgid "Replace the running window manager"
 msgstr "Reemplazar el gestor de ventanas en ejecución"
 
-#: src/core/meta-context-main.c:559
+#: src/core/meta-context-main.c:561
 msgid "X Display to use"
 msgstr "Pantalla X que usar"
 
-#: src/core/meta-context-main.c:565
+#: src/core/meta-context-main.c:567
 msgid "Disable connection to session manager"
 msgstr "Desactivar conexión al gestor de sesión"
 
-#: src/core/meta-context-main.c:571
+#: src/core/meta-context-main.c:573
 msgid "Specify session management ID"
 msgstr "Especificar el ID se gestión de sesión"
 
-#: src/core/meta-context-main.c:577
+#: src/core/meta-context-main.c:579
 msgid "Initialize session from savefile"
 msgstr "Inicializar sesión desde el archivo de salvaguarda"
 
-#: src/core/meta-context-main.c:590
+#: src/core/meta-context-main.c:585
+msgid "Make X calls synchronous"
+msgstr "Hacer que las llamadas a las X sean síncronas"
+
+#: src/core/meta-context-main.c:592
 msgid "Run as a wayland compositor"
 msgstr "Ejecutar como compositor Wayland"
 
-#: src/core/meta-context-main.c:596
+#: src/core/meta-context-main.c:598
 msgid "Run as a nested compositor"
 msgstr "Ejecutar como compositor anidado"
 
-#: src/core/meta-context-main.c:602
+#: src/core/meta-context-main.c:604
 msgid "Run wayland compositor without starting Xwayland"
 msgstr "Ejecutar el compositor wayland sin iniciar Xwayland"
 
-#: src/core/meta-context-main.c:608
+#: src/core/meta-context-main.c:610
 msgid "Specify Wayland display name to use"
 msgstr "Especifique el nombre de pantalla Wayland que usar"
 
-#: src/core/meta-context-main.c:616
+#: src/core/meta-context-main.c:618
 msgid "Run as a full display server, rather than nested"
 msgstr "Ejecutar como servidor completo, en lugar de anidado"
 
-#: src/core/meta-context-main.c:621
+#: src/core/meta-context-main.c:623
 msgid "Run as a headless display server"
 msgstr "Ejecutar como servidor sin periféricos"
 
-#: src/core/meta-context-main.c:626
+#: src/core/meta-context-main.c:628
 msgid "Add persistent virtual monitor (WxH or WxH@R)"
 msgstr "Añadir monitor virtual persistente WxH o WxH@R)"
 
-#: src/core/meta-context-main.c:632
+#: src/core/meta-context-main.c:639
 msgid "Run with X11 backend"
 msgstr "Ejecutar con «backend» de X11"
 
@@ -769,11 +769,11 @@ msgstr "Cambiar monitor"
 msgid "Show on-screen help"
 msgstr "Mostrar la ayuda en pantalla"
 
-#: src/core/mutter.c:47
+#: src/core/mutter.c:74
 msgid "Print version"
 msgstr "Imprimir versión"
 
-#: src/core/mutter.c:53
+#: src/core/mutter.c:80
 msgid "Mutter plugin to use"
 msgstr "Complemento de mutter que usar"
 
@@ -782,7 +782,7 @@ msgstr "Complemento de mutter que usar"
 msgid "Workspace %d"
 msgstr "Área de trabajo %d"
 
-#: src/core/util.c:148
+#: src/core/util.c:149
 msgid "Mutter was compiled without support for verbose mode"
 msgstr "Mutter se compiló sin soporte para modo detallado"
 
@@ -809,7 +809,7 @@ msgstr "Falló al inicializar GDK"
 msgid "Failed to open X Window System display “%s”"
 msgstr "Falló al abrir la pantalla del sistema X-Window «%s»"
 
-#: src/x11/meta-x11-display.c:1175
+#: src/x11/meta-x11-display.c:1181
 #, c-format
 msgid "Screen %d on display “%s” is invalid"
 msgstr "La ventana %d en la pantalla «%s» no es válida"
@@ -819,7 +819,7 @@ msgstr "La ventana %d en la pantalla «%s» no es válida"
 msgid "Format %s not supported"
 msgstr "Formato %s no soportado"
 
-#: src/x11/session.c:1845
+#: src/x11/session.c:1823
 msgid ""
 "These windows do not support “save current setup” and will have to be "
 "restarted manually next time you log in."
@@ -832,6 +832,20 @@ msgstr ""
 msgid "%s (on %s)"
 msgstr "%s (on %s)"
 
+#~ msgid "Show the activities overview"
+#~ msgstr "Mostrar la vista de actividades"
+
+#~| msgid "X Display to use"
+#~ msgid "X display to use"
+#~ msgstr "Pantalla X que usar"
+
+#~| msgid "X Display to use"
+#~ msgid "X screen to use"
+#~ msgstr "Pantalla X que usar"
+
+#~ msgid "Disable XInput support"
+#~ msgstr "Desactivar soporte de XInput"
+
 #~ msgid ""
 #~ "mutter %s\n"
 #~ "Copyright © 2001-%d Havoc Pennington, Red Hat, Inc., and others\n"
diff --git a/po/eu.po b/po/eu.po
index 1b760fcd7..30edf55f1 100644
--- a/po/eu.po
+++ b/po/eu.po
@@ -10,8 +10,8 @@
 msgid ""
 msgstr "Project-Id-Version: mutter master\n"
 "Report-Msgid-Bugs-To: https://gitlab.gnome.org/GNOME/mutter/issues\n"
-"POT-Creation-Date: 2021-07-27 14:35+0000\n"
-"PO-Revision-Date: 2021-08-20 10:00+0100\n"
+"POT-Creation-Date: 2021-12-22 20:30+0000\n"
+"PO-Revision-Date: 2021-12-24 10:00+0100\n"
 "Last-Translator: Asier Sarasua Garmendia <asiersarasua@ni.eus>\n"
 "Language-Team: Basque <librezale@librezale.eus>\n"
 "Language: eu\n"
@@ -180,10 +180,6 @@ msgstr "Sistema"
 msgid "Show the run command prompt"
 msgstr "Erakutsi gonbitea komandoa exekutatzeko"
 
-#: data/50-mutter-system.xml:10
-msgid "Show the activities overview"
-msgstr "Erakutsi jardueren aurkezpen orokorra"
-
 #: data/50-mutter-wayland.xml:8
 msgid "Restore the keyboard shortcuts"
 msgstr "Leheneratu laster-teklak"
@@ -252,11 +248,11 @@ msgstr "Maximizatu leihoa bertikalean"
 msgid "Maximize window horizontally"
 msgstr "Maximizatu leihoa horizontalean"
 
-#: data/50-mutter-windows.xml:41 data/org.gnome.mutter.gschema.xml.in:166
+#: data/50-mutter-windows.xml:41 data/org.gnome.mutter.gschema.xml.in:179
 msgid "View split on left"
 msgstr "Ikusi zatia ezkerrean"
 
-#: data/50-mutter-windows.xml:45 data/org.gnome.mutter.gschema.xml.in:171
+#: data/50-mutter-windows.xml:45 data/org.gnome.mutter.gschema.xml.in:184
 msgid "View split on right"
 msgstr "Ikusi zatia eskuinean"
 
@@ -264,11 +260,11 @@ msgstr "Ikusi zatia eskuinean"
 msgid "Mutter"
 msgstr "Mutter"
 
-#: data/org.gnome.mutter.gschema.xml.in:7
+#: data/org.gnome.mutter.gschema.xml.in:16
 msgid "Modifier to use for extended window management operations"
 msgstr "Aldatzailea leihoak kudeatzeko eragiketa hedatuetan erabiltzeko"
 
-#: data/org.gnome.mutter.gschema.xml.in:8
+#: data/org.gnome.mutter.gschema.xml.in:17
 msgid ""
 "This key will initiate the “overlay”, which is a combination window overview "
 "and application launching system. The default is intended to be the “Windows "
@@ -276,105 +272,105 @@ msgid ""
 "set to the empty string."
 msgstr "Gako honek “overlay” (gainjarria) hasieratuko du: hau leihoaren ikuspegi orokorraren eta aplikazioa abiarazteko sistemaren arteko konbinazioa da. Lehenetsi gisa, PC ordenagailuko “Windows tekla” da. Tekla konbinazio hau lehenetsia izatea edo kate huts gisa ezartzea da."
 
-#: data/org.gnome.mutter.gschema.xml.in:20
+#: data/org.gnome.mutter.gschema.xml.in:29
 msgid "Attach modal dialogs"
 msgstr "Erantsi elkarrizketa-koadro modala"
 
-#: data/org.gnome.mutter.gschema.xml.in:21
+#: data/org.gnome.mutter.gschema.xml.in:30
 msgid ""
 "When true, instead of having independent titlebars, modal dialogs appear "
 "attached to the titlebar of the parent window and are moved together with "
 "the parent window."
 msgstr "True (egia) bada, titulu-barra independenteak eduki ordez, elkarrizketa-koadro modalak agertuko dira leiho gurasoko titulu-barrari erantsita eta leiho gurasoarekin batera mugituko dira."
 
-#: data/org.gnome.mutter.gschema.xml.in:30
+#: data/org.gnome.mutter.gschema.xml.in:39
 msgid "Enable edge tiling when dropping windows on screen edges"
 msgstr "Gaitu lauzatzea leihoak pantailaren ertzetan jaregitean"
 
-#: data/org.gnome.mutter.gschema.xml.in:31
+#: data/org.gnome.mutter.gschema.xml.in:40
 msgid ""
 "If enabled, dropping windows on vertical screen edges maximizes them "
 "vertically and resizes them horizontally to cover half of the available "
 "area. Dropping windows on the top screen edge maximizes them completely."
 msgstr "Gaituta egonez gero, pantailaren ertz bertikaletan leihoak jaregiteak hauek bertikalean maximizatuko dira, eta horizontalean tamainaz aldatuko dira area erabilgarriaren erdia estaltzeko. Pantailaren goiko ertzean leihoak jaregitean, hauek erabat maximizatuko dira."
 
-#: data/org.gnome.mutter.gschema.xml.in:40
+#: data/org.gnome.mutter.gschema.xml.in:49
 msgid "Workspaces are managed dynamically"
 msgstr "Laneko areak dinamikoki kudeatzen dira"
 
-#: data/org.gnome.mutter.gschema.xml.in:41
+#: data/org.gnome.mutter.gschema.xml.in:50
 msgid ""
 "Determines whether workspaces are managed dynamically or whether there’s a "
 "static number of workspaces (determined by the num-workspaces key in org."
 "gnome.desktop.wm.preferences)."
 msgstr "Laneko areak dinamikoki kudeatzen diren edo laneko areak kopuru estatikoa (“org.gnome.desktop.wm.preferences“-eko “num-workspaces” gakoak zehazten du) daukan zehazten du ."
 
-#: data/org.gnome.mutter.gschema.xml.in:50
+#: data/org.gnome.mutter.gschema.xml.in:59
 msgid "Workspaces only on primary"
 msgstr "Laneko areak soilik nagusian"
 
-#: data/org.gnome.mutter.gschema.xml.in:51
+#: data/org.gnome.mutter.gschema.xml.in:60
 msgid ""
 "Determines whether workspace switching should happen for windows on all "
 "monitors or only for windows on the primary monitor."
 msgstr "Laneko areaz aldatzean pantaila guztietako leihoei eragingo dien edo pantaila nagusiko leihoei soilik zehazten du."
 
-#: data/org.gnome.mutter.gschema.xml.in:59
+#: data/org.gnome.mutter.gschema.xml.in:68
 msgid "No tab popup"
 msgstr "Laster-fitxarik ez"
 
-#: data/org.gnome.mutter.gschema.xml.in:60
+#: data/org.gnome.mutter.gschema.xml.in:69
 msgid ""
 "Determines whether the use of popup and highlight frame should be disabled "
 "for window cycling."
 msgstr "Leihoen artean aldatzean laster-leiho eta nabarmentzeko markoen erabilpena desgaitu behar den edo ez zehazten du."
 
-#: data/org.gnome.mutter.gschema.xml.in:68
+#: data/org.gnome.mutter.gschema.xml.in:77
 msgid "Delay focus changes until the pointer stops moving"
 msgstr "Atzeratu fokuaren aldaketa erakuslea mugitzeari utzi arte"
 
-#: data/org.gnome.mutter.gschema.xml.in:69
+#: data/org.gnome.mutter.gschema.xml.in:78
 msgid ""
 "If set to true, and the focus mode is either “sloppy” or “mouse” then the "
 "focus will not be changed immediately when entering a window, but only after "
 "the pointer stops moving."
 msgstr "TRUE (egia) gisa ezartzen bada, eta fokuaren modua “sloppy” edo “mouse” bada, fokua ez da berehala aldatuko leiho batean sartzean baizik eta soilik erakuslea gelditzean."
 
-#: data/org.gnome.mutter.gschema.xml.in:79
+#: data/org.gnome.mutter.gschema.xml.in:88
 msgid "Draggable border width"
 msgstr "Ertz arrastragarriaren zabalera"
 
-#: data/org.gnome.mutter.gschema.xml.in:80
+#: data/org.gnome.mutter.gschema.xml.in:89
 msgid ""
 "The amount of total draggable borders. If the theme’s visible borders are "
 "not enough, invisible borders will be added to meet this value."
 msgstr "Ertz arrastragarri guztien kopurua. Gaiaren ertz ikusgaiak ez badira nahikoak, ertz ikusezinak gehituko dira balio honekin bat etortzeko."
 
-#: data/org.gnome.mutter.gschema.xml.in:89
+#: data/org.gnome.mutter.gschema.xml.in:98
 msgid "Auto maximize nearly monitor sized windows"
 msgstr "Maximizatu automatikoki monitorearen tamainaren gertuko leihoak"
 
-#: data/org.gnome.mutter.gschema.xml.in:90
+#: data/org.gnome.mutter.gschema.xml.in:99
 msgid ""
 "If enabled, new windows that are initially the size of the monitor "
 "automatically get maximized."
 msgstr "Gaituta badago, ia monitorearen tamainara iristen diren leiho berriak automatikoki maximizatuko ditu."
 
-#: data/org.gnome.mutter.gschema.xml.in:98
+#: data/org.gnome.mutter.gschema.xml.in:107
 msgid "Place new windows in the center"
 msgstr "Jarri leiho berriak zentroan"
 
-#: data/org.gnome.mutter.gschema.xml.in:99
+#: data/org.gnome.mutter.gschema.xml.in:108
 msgid ""
 "When true, the new windows will always be put in the center of the active "
 "screen of the monitor."
 msgstr "TRUE (egia) denean, leiho berriak beti jarriko dira monitorearen pantaila aktiboaren zentroan."
 
-#: data/org.gnome.mutter.gschema.xml.in:107
+#: data/org.gnome.mutter.gschema.xml.in:117
 msgid "Enable experimental features"
 msgstr "Gaitu eginbide esperimentalak"
 
-#: data/org.gnome.mutter.gschema.xml.in:108
+#: data/org.gnome.mutter.gschema.xml.in:118
 msgid ""
 "To enable experimental features, add the feature keyword to the list. "
 "Whether the feature requires restarting the compositor depends on the given "
@@ -383,46 +379,48 @@ msgid ""
 "proof. Currently possible keywords: • “scale-monitor-framebuffer” — makes "
 "mutter default to layout logical monitors in a logical pixel coordinate "
 "space, while scaling monitor framebuffers instead of window content, to "
-"manage HiDPI monitors. Does not require a restart. • “rt-scheduler” — makes "
-"mutter request a low priority real-time scheduling. The executable or user "
-"must have CAP_SYS_NICE. Requires a restart. • “dma-buf-screen-sharing\" — "
-"enables DMA buffered screen sharing. This is already enabled by default when "
-"using the i915 driver, but disabled for everything else. Requires a restart. "
-"• “autoclose-xwayland” — automatically terminates Xwayland if all relevant "
-"X11 clients are gone. Does not require a restart."
-msgstr "Eginbide esperimentalak gaitzeko, gehitu eginbidearen gako-hitza zerrendari. Eginbideak konposatzailea berrabiaraztea behar duen edo ez, emandako eginbidearen araberakoa da. Ez da derrigorrezkoa edozein eginbide esperimental eskuragarri edo konfiguragarri egotea. Ez uste ezarpen honetan edozer gehitzeak etorkizunean funtzionatuko duenik. Uneko gako erabilgarriak: • “scale-monitor-framebuffer” — honek mutterrek monitore logikoak espazioaren koordenatuko pixel logikoetan diseina dezan eragiten du, leihoaren edukiaren ordez monitorearen framebufferra eskalatuta, HiDPI monitoreak kudeatzeko. Ez da sistema berrabiarazi behar. • “rt-scheduler” — muterrek lehentasun baxuko denbora errealeko programazioa eska dezan eragiten du. Exekutagarriak edo erabiltzaileak CAP_SYS_NICE izan behar du. Sistema berrabiarazi behar da. • “dma-buf-screen-sharing\" — DMA bidezko bufferra duen pantaila-partekatzea gaitzen du. Jadanik modu lehenetsian gaituta dago i915 kontrolagailua erabiltzen bada, baina desgaituta dago gainerako kasuetan. Sistema berrabiarazi behar da. • “autoclose-xwayland” — Xwayland automatikoki amaitzen du X11 bezero esanguratsu guztiak itxi badira. Ez da sistema berrabiarazi behar."
-
-#: data/org.gnome.mutter.gschema.xml.in:143
+"manage HiDPI monitors. Does not require a restart. • “kms-modifiers” — makes "
+"mutter always advertise valid buffer modifiers on Wayland. This is currently "
+"not the case when using the i915 driver. Does not require a restart. • “rt-"
+"scheduler” — makes mutter request a low priority real-time scheduling. "
+"Requires a restart. • “dma-buf-screen-sharing” — enables DMA buffered screen "
+"sharing. This is already enabled by default when using the i915 driver, but "
+"disabled for everything else. Requires a restart. • “autoclose-xwayland” — "
+"automatically terminates Xwayland if all relevant X11 clients are gone. Does "
+"not require a restart."
+msgstr "Eginbide esperimentalak gaitzeko, gehitu eginbidearen gako-hitza zerrendari. Eginbideak konposatzailea berrabiaraztea behar duen edo ez, emandako eginbidearen araberakoa da. Ez da derrigorrezkoa edozein eginbide esperimental eskuragarri edo konfiguragarri egotea. Ez uste ezarpen honetan edozer gehitzeak etorkizunean funtzionatuko duenik. Uneko gako erabilgarriak: • “scale-monitor-framebuffer” — honek mutterrek monitore logikoak espazioaren koordenatuko pixel logikoetan diseina dezan eragiten du, leihoaren edukiaren ordez monitorearen framebufferra eskalatuta, HiDPI monitoreak kudeatzeko. Ez da sistema berrabiarazi behar. • “rt-scheduler” — muterrek lehentasun baxuko denbora errealeko programazioa eska dezan eragiten du. Sistema berrabiarazi behar da. • “dma-buf-screen-sharing” — DMA bidezko bufferra duen pantaila-partekatzea gaitzen du. Jadanik modu lehenetsian gaituta dago i915 kontrolagailua erabiltzen bada, baina desgaituta dago gainerako kasuetan. Sistema berrabiarazi behar da. • “autoclose-xwayland” — Xwayland automatikoki amaitzen du X11 bezero esanguratsu guztiak itxi badira. Ez da sistema berrabiarazi behar."
+
+#: data/org.gnome.mutter.gschema.xml.in:156
 msgid "Modifier to use to locate the pointer"
 msgstr "Erakuslea kokatzeko erabiliko den aldatzailea"
 
-#: data/org.gnome.mutter.gschema.xml.in:144
+#: data/org.gnome.mutter.gschema.xml.in:157
 msgid "This key will initiate the “locate pointer” action."
 msgstr "Gako honek “kokatu erakuslea” ekintza abiarazten du."
 
-#: data/org.gnome.mutter.gschema.xml.in:151
+#: data/org.gnome.mutter.gschema.xml.in:164
 msgid "Timeout for check-alive ping"
 msgstr "Bizirik egotearen ping-aren denbora-muga"
 
-#: data/org.gnome.mutter.gschema.xml.in:152
+#: data/org.gnome.mutter.gschema.xml.in:165
 msgid ""
 "Number of milliseconds a client has to respond to a ping request in order to "
 "not be detected as frozen. Using 0 will disable the alive check completely."
 msgstr "Bezero batek ping eskari bati erantzuteko duen milisegundo kopurua, izoztutzat hartu baino lehen. Erabiltzen den balioa 0 bada, bizirik egotearen egiaztatzea erabat desgaituko da."
 
-#: data/org.gnome.mutter.gschema.xml.in:176
+#: data/org.gnome.mutter.gschema.xml.in:189
 msgid "Select window from tab popup"
 msgstr "Hautatu leihoa laster-fitxatik"
 
-#: data/org.gnome.mutter.gschema.xml.in:181
+#: data/org.gnome.mutter.gschema.xml.in:194
 msgid "Cancel tab popup"
 msgstr "Utzi laster-fitxa"
 
-#: data/org.gnome.mutter.gschema.xml.in:186
+#: data/org.gnome.mutter.gschema.xml.in:199
 msgid "Switch monitor configurations"
 msgstr "Aldatu monitorearen konfigurazioak"
 
-#: data/org.gnome.mutter.gschema.xml.in:191
+#: data/org.gnome.mutter.gschema.xml.in:204
 msgid "Rotates the built-in monitor configuration"
 msgstr "Biratu barneko monitorearen konfigurazioa"
 
@@ -525,26 +523,26 @@ msgid ""
 "needs to be restarted for this setting to take effect."
 msgstr "Aukera honek hautatutako X hedapenak desgaitzen ditu Xwayland aplikazioan, Xwayland X hedapen horien euskarriarekin eraiki bada. Aukera honek ez du eraginik Xwayland hautatutako hedapenen euskarririk gabe eraiki bada. Xwayland berrabiarazi behar da ezarpen hau indarrean sartzeko."
 
-#: src/backends/meta-monitor.c:235
+#: src/backends/meta-monitor.c:246
 msgid "Built-in display"
 msgstr "Bertako pantaila"
 
-#: src/backends/meta-monitor.c:264
+#: src/backends/meta-monitor.c:275
 msgid "Unknown"
 msgstr "Ezezaguna"
 
-#: src/backends/meta-monitor.c:266
+#: src/backends/meta-monitor.c:277
 msgid "Unknown Display"
 msgstr "Pantaila ezezaguna"
 
-#: src/backends/meta-monitor.c:274
+#: src/backends/meta-monitor.c:285
 #, c-format
 msgctxt ""
 "This is a monitor vendor name, followed by a size in inches, like 'Dell 15\"'"
 msgid "%s %s"
 msgstr "%s %s"
 
-#: src/backends/meta-monitor.c:282
+#: src/backends/meta-monitor.c:293
 #, c-format
 msgctxt ""
 "This is a monitor vendor name followed by product/model name where size in "
@@ -557,26 +555,9 @@ msgstr "%s %s"
 msgid "Compositor"
 msgstr "Konposatzailea"
 
-#: src/backends/x11/meta-clutter-backend-x11.c:237
-msgid "X display to use"
-msgstr "Erabiliko den X bistaratzea"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:243
-msgid "X screen to use"
-msgstr "Erabiliko den X pantaila"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:248
-#: src/core/meta-context-main.c:583
-msgid "Make X calls synchronous"
-msgstr "Bihurtu X dei sinkroniko"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:254
-msgid "Disable XInput support"
-msgstr "Desgaitu XInput euskarria"
-
 #. This probably means that a non-WM compositor like xcompmgr is running;
 #. * we have no way to get it to exit
-#: src/compositor/compositor.c:513
+#: src/compositor/compositor.c:504
 #, c-format
 msgid ""
 "Another compositing manager is already running on screen %i on display “%s”."
@@ -602,63 +583,67 @@ msgid ""
 "application to quit entirely."
 msgstr "Pixka bat itxoitearen edo aplikazioa irtetera derrigortzearen artean aukera dezakezu."
 
-#: src/core/meta-close-dialog-default.c:165
+#: src/core/meta-close-dialog-default.c:164
 msgid "_Force Quit"
 msgstr "_Behartu ixtera"
 
-#: src/core/meta-close-dialog-default.c:165
+#: src/core/meta-close-dialog-default.c:164
 msgid "_Wait"
 msgstr "_Itxaron"
 
-#: src/core/meta-context-main.c:553
+#: src/core/meta-context-main.c:555
 msgid "Replace the running window manager"
 msgstr "Ordeztu exekutatzen dagoen leiho-kudeatzailea"
 
-#: src/core/meta-context-main.c:559
+#: src/core/meta-context-main.c:561
 msgid "X Display to use"
 msgstr "X pantaila erabiltzeko"
 
-#: src/core/meta-context-main.c:565
+#: src/core/meta-context-main.c:567
 msgid "Disable connection to session manager"
 msgstr "Desgaitu saio-kudeatzailearen konexioa"
 
-#: src/core/meta-context-main.c:571
+#: src/core/meta-context-main.c:573
 msgid "Specify session management ID"
 msgstr "Zehaztu saio-kudeatzailearen IDa"
 
-#: src/core/meta-context-main.c:577
+#: src/core/meta-context-main.c:579
 msgid "Initialize session from savefile"
 msgstr "Hasieratu saioa babes-fitxategitik"
 
-#: src/core/meta-context-main.c:590
+#: src/core/meta-context-main.c:585
+msgid "Make X calls synchronous"
+msgstr "Bihurtu X dei sinkroniko"
+
+#: src/core/meta-context-main.c:592
 msgid "Run as a wayland compositor"
 msgstr "Exekutatu wayland konposatzaile gisa"
 
-#: src/core/meta-context-main.c:596
+#: src/core/meta-context-main.c:598
 msgid "Run as a nested compositor"
 msgstr "Exekutatu habiaratutako konposatzaile gisa"
 
-#: src/core/meta-context-main.c:602
+#: src/core/meta-context-main.c:604
 msgid "Run wayland compositor without starting Xwayland"
 msgstr "Exekutatu waylan konposatzailea Xwayland abiarazi gabe"
 
-#: src/core/meta-context-main.c:608
+#: src/core/meta-context-main.c:610
 msgid "Specify Wayland display name to use"
 msgstr "Zehaztu erabiliko den Wayland pantailaren izena"
 
-#: src/core/meta-context-main.c:616
+#: src/core/meta-context-main.c:618
 msgid "Run as a full display server, rather than nested"
 msgstr "Exekutatu pantaila-zerbitzari oso bezala, habiaratuta baino"
 
-#: src/core/meta-context-main.c:621
+#: src/core/meta-context-main.c:623
 msgid "Run as a headless display server"
 msgstr "Exekutatu bururik gabeko pantaila-zerbitzari gisa"
 
-#: src/core/meta-context-main.c:626
+#: src/core/meta-context-main.c:628
 msgid "Add persistent virtual monitor (WxH or WxH@R)"
 msgstr "Gehitu pantaila birtual iraunkorra (WxH edo WxH@R)"
 
-#: src/core/meta-context-main.c:632
+#: src/core/meta-context-main.c:639
 msgid "Run with X11 backend"
 msgstr "Exekutatu X11 motorra erabilita"
 
@@ -681,11 +666,11 @@ msgstr "Aldatu monitorea"
 msgid "Show on-screen help"
 msgstr "Erakutsi pantailako laguntzan"
 
-#: src/core/mutter.c:47
+#: src/core/mutter.c:74
 msgid "Print version"
 msgstr "Bistaratu bertsioa"
 
-#: src/core/mutter.c:53
+#: src/core/mutter.c:80
 msgid "Mutter plugin to use"
 msgstr "Mutter-en osagaia erabiltzeko"
 
@@ -694,7 +679,7 @@ msgstr "Mutter-en osagaia erabiltzeko"
 msgid "Workspace %d"
 msgstr "%d. laneko area"
 
-#: src/core/util.c:148
+#: src/core/util.c:141
 msgid "Mutter was compiled without support for verbose mode"
 msgstr "Mutter modu xehatuaren euskarririk gabe konpilatu da"
 
@@ -719,7 +704,7 @@ msgstr "Huts egin du GDK hasieratzeak"
 msgid "Failed to open X Window System display “%s”"
 msgstr "Huts egin du X Window sistemaren “%s“ pantaila irekitzean"
 
-#: src/x11/meta-x11-display.c:1175
+#: src/x11/meta-x11-display.c:1181
 #, c-format
 msgid "Screen %d on display “%s” is invalid"
 msgstr "%d pantaila, “%s” bistakoa, ez da baliozkoa"
@@ -729,7 +714,7 @@ msgstr "%d pantaila, “%s” bistakoa, ez da baliozkoa"
 msgid "Format %s not supported"
 msgstr "%s formatua ez da onartzen"
 
-#: src/x11/session.c:1845
+#: src/x11/session.c:1823
 msgid ""
 "These windows do not support “save current setup” and will have to be "
 "restarted manually next time you log in."
@@ -740,6 +725,18 @@ msgstr "Leiho hauek ez dute onartzen “gorde uneko konfigurazioa“; eta eskuz
 msgid "%s (on %s)"
 msgstr "%s (%s)"
 
+#~ msgid "Show the activities overview"
+#~ msgstr "Erakutsi jardueren aurkezpen orokorra"
+
+#~ msgid "X display to use"
+#~ msgstr "Erabiliko den X bistaratzea"
+
+#~ msgid "X screen to use"
+#~ msgstr "Erabiliko den X pantaila"
+
+#~ msgid "Disable XInput support"
+#~ msgstr "Desgaitu XInput euskarria"
+
 #~ msgid ""
 #~ "mutter %s\n"
 #~ "Copyright © 2001-%d Havoc Pennington, Red Hat, Inc., and others\n"
diff --git a/po/fur.po b/po/fur.po
index 0803ec0f2..85b5d6b37 100644
--- a/po/fur.po
+++ b/po/fur.po
@@ -7,8 +7,8 @@ msgid ""
 msgstr ""
 "Project-Id-Version: mutter master\n"
 "Report-Msgid-Bugs-To: https://gitlab.gnome.org/GNOME/mutter/issues\n"
-"POT-Creation-Date: 2021-07-19 15:55+0000\n"
-"PO-Revision-Date: 2021-07-24 10:16+0200\n"
+"POT-Creation-Date: 2021-11-17 09:03+0000\n"
+"PO-Revision-Date: 2021-11-22 08:45+0100\n"
 "Last-Translator: Fabio Tomat <f.t.public@gmail.com>\n"
 "Language-Team: Friulian <fur@li.org>\n"
 "Language: fur\n"
@@ -177,10 +177,6 @@ msgstr "Sisteme"
 msgid "Show the run command prompt"
 msgstr "Mostre la richieste “eseguìs comant”"
 
-#: data/50-mutter-system.xml:10
-msgid "Show the activities overview"
-msgstr "Mostre la panoramiche ativitâts"
-
 #: data/50-mutter-wayland.xml:8
 msgid "Restore the keyboard shortcuts"
 msgstr "Ripristine lis scurtis di tastiere"
@@ -249,11 +245,11 @@ msgstr "Slargje il barcon par verticâl"
 msgid "Maximize window horizontally"
 msgstr "Slargje il barcon par orizontâl"
 
-#: data/50-mutter-windows.xml:41 data/org.gnome.mutter.gschema.xml.in:166
+#: data/50-mutter-windows.xml:41 data/org.gnome.mutter.gschema.xml.in:179
 msgid "View split on left"
 msgstr "Slargje dividint ae çampe"
 
-#: data/50-mutter-windows.xml:45 data/org.gnome.mutter.gschema.xml.in:171
+#: data/50-mutter-windows.xml:45 data/org.gnome.mutter.gschema.xml.in:184
 msgid "View split on right"
 msgstr "Slargje dividint ae drete"
 
@@ -261,11 +257,11 @@ msgstr "Slargje dividint ae drete"
 msgid "Mutter"
 msgstr "Mutter"
 
-#: data/org.gnome.mutter.gschema.xml.in:7
+#: data/org.gnome.mutter.gschema.xml.in:16
 msgid "Modifier to use for extended window management operations"
 msgstr "Modificadôr di doprâ pes operazions estesis di gjestion barcons"
 
-#: data/org.gnome.mutter.gschema.xml.in:8
+#: data/org.gnome.mutter.gschema.xml.in:17
 msgid ""
 "This key will initiate the “overlay”, which is a combination window overview "
 "and application launching system. The default is intended to be the “Windows "
@@ -277,11 +273,11 @@ msgstr ""
 "predefinît al è pensât par jessi il “tast Windows” su hardware PC. Si spiete "
 "che cheste scurte e sedi il valôr predefinît o une stringhe vueide."
 
-#: data/org.gnome.mutter.gschema.xml.in:20
+#: data/org.gnome.mutter.gschema.xml.in:29
 msgid "Attach modal dialogs"
 msgstr "Dialics modâi tacâts"
 
-#: data/org.gnome.mutter.gschema.xml.in:21
+#: data/org.gnome.mutter.gschema.xml.in:30
 msgid ""
 "When true, instead of having independent titlebars, modal dialogs appear "
 "attached to the titlebar of the parent window and are moved together with "
@@ -290,12 +286,12 @@ msgstr ""
 "Se metût a VÊR, invezit di vê sbaris di titul indipendentis, i dialics modâi "
 "a semein tacâts ae sbare dal titul dal barcon gjenitôr e si spostin cun lui."
 
-#: data/org.gnome.mutter.gschema.xml.in:30
+#: data/org.gnome.mutter.gschema.xml.in:39
 msgid "Enable edge tiling when dropping windows on screen edges"
 msgstr ""
 "Abilite il piastrelâ tal ôr cuant che si strissine i barcons tal ôr dal visôr"
 
-#: data/org.gnome.mutter.gschema.xml.in:31
+#: data/org.gnome.mutter.gschema.xml.in:40
 msgid ""
 "If enabled, dropping windows on vertical screen edges maximizes them "
 "vertically and resizes them horizontally to cover half of the available "
@@ -306,11 +302,11 @@ msgstr ""
 "cuvierzi metât dal spazi disponibil. Strissinant sul ôr superiôr dal schermi "
 "al slargje i barcons dal dut."
 
-#: data/org.gnome.mutter.gschema.xml.in:40
+#: data/org.gnome.mutter.gschema.xml.in:49
 msgid "Workspaces are managed dynamically"
 msgstr "I spazis di vore a son ministrât in maniere dinamiche"
 
-#: data/org.gnome.mutter.gschema.xml.in:41
+#: data/org.gnome.mutter.gschema.xml.in:50
 msgid ""
 "Determines whether workspaces are managed dynamically or whether there’s a "
 "static number of workspaces (determined by the num-workspaces key in org."
@@ -320,11 +316,11 @@ msgstr ""
 "il lôr numar al è fis (determinât de clâf num-workspaces in org.gnome."
 "desktop.wm.preferences)."
 
-#: data/org.gnome.mutter.gschema.xml.in:50
+#: data/org.gnome.mutter.gschema.xml.in:59
 msgid "Workspaces only on primary"
 msgstr "Spazis di vore nome tal visôr primari"
 
-#: data/org.gnome.mutter.gschema.xml.in:51
+#: data/org.gnome.mutter.gschema.xml.in:60
 msgid ""
 "Determines whether workspace switching should happen for windows on all "
 "monitors or only for windows on the primary monitor."
@@ -332,11 +328,11 @@ msgstr ""
 "Determine se il cambi di spazi di lavôr al à di vignî pai barcons su ducj i "
 "visôrs o nome pai barcons sul visôr primari."
 
-#: data/org.gnome.mutter.gschema.xml.in:59
+#: data/org.gnome.mutter.gschema.xml.in:68
 msgid "No tab popup"
 msgstr "Nissun tab popup"
 
-#: data/org.gnome.mutter.gschema.xml.in:60
+#: data/org.gnome.mutter.gschema.xml.in:69
 msgid ""
 "Determines whether the use of popup and highlight frame should be disabled "
 "for window cycling."
@@ -344,11 +340,11 @@ msgstr ""
 "Determine se disabilitâ l'ûs di popup e di curnîs di evidenziadure tal passâ "
 "di un barcon a chel altri."
 
-#: data/org.gnome.mutter.gschema.xml.in:68
+#: data/org.gnome.mutter.gschema.xml.in:77
 msgid "Delay focus changes until the pointer stops moving"
 msgstr "Tarde il cambiament dal focus fintremai che il puntadôr si ferme"
 
-#: data/org.gnome.mutter.gschema.xml.in:69
+#: data/org.gnome.mutter.gschema.xml.in:78
 msgid ""
 "If set to true, and the focus mode is either “sloppy” or “mouse” then the "
 "focus will not be changed immediately when entering a window, but only after "
@@ -358,11 +354,11 @@ msgstr ""
 "alore il focus nol ven spostât subite cuant che si passe suntun barcon, ma "
 "nome cuant che il puntadôr si ferme."
 
-#: data/org.gnome.mutter.gschema.xml.in:79
+#: data/org.gnome.mutter.gschema.xml.in:88
 msgid "Draggable border width"
 msgstr "Largjece dal ôr che si pues strissinâ"
 
-#: data/org.gnome.mutter.gschema.xml.in:80
+#: data/org.gnome.mutter.gschema.xml.in:89
 msgid ""
 "The amount of total draggable borders. If the theme’s visible borders are "
 "not enough, invisible borders will be added to meet this value."
@@ -370,11 +366,11 @@ msgstr ""
 "Il spessôr totâl pai ôrs che si puedin strissinâ. Se i ôrs visibii dal teme "
 "no bastin, a vegnin zontâts dai ôrs invisibii par rivâ a chest valôr."
 
-#: data/org.gnome.mutter.gschema.xml.in:89
+#: data/org.gnome.mutter.gschema.xml.in:98
 msgid "Auto maximize nearly monitor sized windows"
 msgstr "Slargje in automatic i barcons grancj su par ju come il visôr"
 
-#: data/org.gnome.mutter.gschema.xml.in:90
+#: data/org.gnome.mutter.gschema.xml.in:99
 msgid ""
 "If enabled, new windows that are initially the size of the monitor "
 "automatically get maximized."
@@ -382,11 +378,11 @@ msgstr ""
 "Se abilitât, i gnûfs barcons che a an al inizi la stesse dimension dal visôr "
 "a vegnin slargjâts in automatic."
 
-#: data/org.gnome.mutter.gschema.xml.in:98
+#: data/org.gnome.mutter.gschema.xml.in:107
 msgid "Place new windows in the center"
 msgstr "Place i gnûfs barcons tal mieç"
 
-#: data/org.gnome.mutter.gschema.xml.in:99
+#: data/org.gnome.mutter.gschema.xml.in:108
 msgid ""
 "When true, the new windows will always be put in the center of the active "
 "screen of the monitor."
@@ -394,11 +390,11 @@ msgstr ""
 "Se metût a VÊR, i gnûfs barcons a vegnaran plaçâts simpri tal mieç dal "
 "schermi atîf dal visôr."
 
-#: data/org.gnome.mutter.gschema.xml.in:107
+#: data/org.gnome.mutter.gschema.xml.in:117
 msgid "Enable experimental features"
 msgstr "Abilite funzionalitâts sperimentâls"
 
-#: data/org.gnome.mutter.gschema.xml.in:108
+#: data/org.gnome.mutter.gschema.xml.in:118
 msgid ""
 "To enable experimental features, add the feature keyword to the list. "
 "Whether the feature requires restarting the compositor depends on the given "
@@ -407,13 +403,15 @@ msgid ""
 "proof. Currently possible keywords: • “scale-monitor-framebuffer” — makes "
 "mutter default to layout logical monitors in a logical pixel coordinate "
 "space, while scaling monitor framebuffers instead of window content, to "
-"manage HiDPI monitors. Does not require a restart. • “rt-scheduler” — makes "
-"mutter request a low priority real-time scheduling. The executable or user "
-"must have CAP_SYS_NICE. Requires a restart. • “dma-buf-screen-sharing\" — "
-"enables DMA buffered screen sharing. This is already enabled by default when "
-"using the i915 driver, but disabled for everything else. Requires a restart. "
-"• “autoclose-xwayland” — automatically terminates Xwayland if all relevant "
-"X11 clients are gone. Does not require a restart."
+"manage HiDPI monitors. Does not require a restart. • “kms-modifiers” — makes "
+"mutter always advertise valid buffer modifiers on Wayland. This is currently "
+"not the case when using the i915 driver. Does not require a restart. • “rt-"
+"scheduler” — makes mutter request a low priority real-time scheduling. "
+"Requires a restart. • “dma-buf-screen-sharing” — enables DMA buffered screen "
+"sharing. This is already enabled by default when using the i915 driver, but "
+"disabled for everything else. Requires a restart. • “autoclose-xwayland” — "
+"automatically terminates Xwayland if all relevant X11 clients are gone. Does "
+"not require a restart."
 msgstr ""
 "Par abilitâ lis funzionalitâts sperimentâls, zonte la peraule clâf de "
 "funzionalitât ae liste. Il fat che la funzionalitât e vedi bisugne di tornâ "
@@ -422,31 +420,33 @@ msgstr ""
 "spietâti di zontâ alc in cheste impostazion e pensâ che e duredi tal timp. "
 "Atualmentri lis peraulis clâf pussibilis a son: • “scale-monitor-"
 "framebuffer” — al rint come predefinît par mutter, la disposizion logjiche "
-"dai visôrs intun spazi logjic di coordenadis di pixel, in plui si fâs il "
-"scjalâ dai framebuffers dai visôrs invezit che il contignût dal barcon; dut "
-"chest par gjestî i visôrs HiDPI. Nol covente tornâ a inviâ. • “rt-scheduler” "
-"— al fâs in mût che mutter al domandi une programazion in timp reâl a "
-"prioritât basse. L'eseguibil o l'utent a scugnin vê CAP_SYS_NICE. Al covente "
-"tornâ a inviâ. • “dma-buf-screen-sharing\" — al abilite la condivision di "
-"schermis in memorie tampon cun acès diret de memorie (DMA). Chest al è za "
-"abilitât in maniere predefinide cuant che si dopre i driver i915, ma "
-"disabilitât in ducj chei altris câs. Al covente tornâ a inviâ. • “autoclose-"
-"xwayland” — al termine in automatic Xwayland se ducj i clients X11  a son "
-"lâts. Nol covente tornâ a inviâ."
-
-#: data/org.gnome.mutter.gschema.xml.in:143
+"dai visôrs intun spazi logjic di coordenadis di pixel, in plui a vegnin "
+"scjalâts i framebuffers dai visôrs invezit che il contignût dal barcon; dut "
+"chest par gjestî i visôrs HiDPI. Nol covente tornâ a inviâ. • “kms-"
+"modifiers” — al fâs in mût che mutter al publicizi simpri modificadôrs di "
+"memorie tampon valits su Wayland. Chest al moment nol è il câs cuant che si "
+"dopre il driver i915. Nol covente tornâ a inviâ. • “rt-scheduler” — al fâs "
+"in mût che mutter al domandi une programazion in timp reâl a prioritât "
+"basse. Al covente tornâ a inviâ. • “dma-buf-screen-sharing\" — al abilite la "
+"condivision di schermis in memorie tampon cun acès diret de memorie (DMA). "
+"Chest al è za abilitât in maniere predefinide cuant che al ven doprât il "
+"driver i915, ma disabilitât in ducj chei altris câs. Al covente tornâ a "
+"inviâ. • “autoclose-xwayland” — al termine in automatic Xwayland se ducj i "
+"clients X11 a son lâts. Nol covente tornâ a inviâ."
+
+#: data/org.gnome.mutter.gschema.xml.in:156
 msgid "Modifier to use to locate the pointer"
 msgstr "Modificadôr di doprâ par localizâ il pontadôr"
 
-#: data/org.gnome.mutter.gschema.xml.in:144
+#: data/org.gnome.mutter.gschema.xml.in:157
 msgid "This key will initiate the “locate pointer” action."
 msgstr "Cheste clâf e inizializerâ la azion “localize pontadôr”."
 
-#: data/org.gnome.mutter.gschema.xml.in:151
+#: data/org.gnome.mutter.gschema.xml.in:164
 msgid "Timeout for check-alive ping"
 msgstr "Timp scjadût pal control di sorevivence dal ping"
 
-#: data/org.gnome.mutter.gschema.xml.in:152
+#: data/org.gnome.mutter.gschema.xml.in:165
 msgid ""
 "Number of milliseconds a client has to respond to a ping request in order to "
 "not be detected as frozen. Using 0 will disable the alive check completely."
@@ -455,19 +455,19 @@ msgstr ""
 "richieste di ping, par fâ in mût che nol vegni identificât tant che "
 "inglaçât. Doprant 0 si disabilitarà dal dut il control di sorevivence."
 
-#: data/org.gnome.mutter.gschema.xml.in:176
+#: data/org.gnome.mutter.gschema.xml.in:189
 msgid "Select window from tab popup"
 msgstr "Selezione barcon dal tab popup"
 
-#: data/org.gnome.mutter.gschema.xml.in:181
+#: data/org.gnome.mutter.gschema.xml.in:194
 msgid "Cancel tab popup"
 msgstr "Anule tab popup"
 
-#: data/org.gnome.mutter.gschema.xml.in:186
+#: data/org.gnome.mutter.gschema.xml.in:199
 msgid "Switch monitor configurations"
 msgstr "Cambie configurazions visôr"
 
-#: data/org.gnome.mutter.gschema.xml.in:191
+#: data/org.gnome.mutter.gschema.xml.in:204
 msgid "Rotates the built-in monitor configuration"
 msgstr "Al volte la configurazion dal visôr integrât"
 
@@ -568,15 +568,15 @@ msgid ""
 "shortcuts”."
 msgstr ""
 "Liste di nons di risorsis o classis di risorsis di barcons X11 che a puedin "
-"o no puedin cjapâ i segnâi di tastiere X11 sot di Xwayland. Il non de "
-"risorse o la classe de risorse di un dât barcon X11 al pues jessi otignût "
+"o no puedin cjapâ i segnâi di tastiere X11 sot di Xwayland. Al è pussibil "
+"otignî il non de risorse o la classe de risorse di un ciert barcon X11, "
 "doprant il comant “xprop WM_CLASS”. I caratars “*” e “?” tai valôrs a son "
-"supuartâts. I valôrs che a tachin cun “!” a son dineâts, che a àn precedence "
-"sui valôrs permetûts, par revocâ lis aplicazions de liste di sisteme "
-"predefinide. La liste di sisteme predefinide e inclût lis aplicazions chi "
-"sot: “@XWAYLAND_GRAB_DEFAULT_ACCESS_RULES@” I utents a puedin interompi il "
-"control cjapât doprant la specifiche scurte di tastiere definide de clâf di "
-"associazion tast “restore-shortcuts”."
+"supuartâts. I valôrs che a tachin cun “!” a son dineâts, chescj a àn "
+"precedence sui valôrs permetûts, par revocâ lis aplicazions de liste di "
+"sisteme predefinide. La liste di sisteme predefinide e inclût lis "
+"aplicazions chi sot: “@XWAYLAND_GRAB_DEFAULT_ACCESS_RULES@” I utents a "
+"puedin interompi il control cjapât, doprant la specifiche scurte di tastiere "
+"definide de clâf di associazion tast “restore-shortcuts”."
 
 #: data/org.gnome.mutter.wayland.gschema.xml.in:116
 msgid "Disable selected X extensions in Xwayland"
@@ -595,26 +595,26 @@ msgstr ""
 "estensions selezionadis. Xwayland al scugne jessi tornât a inviâ par fâ in "
 "mût che lis impostazions a vegnin aplicadis."
 
-#: src/backends/meta-monitor.c:235
+#: src/backends/meta-monitor.c:246
 msgid "Built-in display"
 msgstr "Display integrât"
 
-#: src/backends/meta-monitor.c:264
+#: src/backends/meta-monitor.c:275
 msgid "Unknown"
 msgstr "No cognossût"
 
-#: src/backends/meta-monitor.c:266
+#: src/backends/meta-monitor.c:277
 msgid "Unknown Display"
 msgstr "Display no cognossût"
 
-#: src/backends/meta-monitor.c:274
+#: src/backends/meta-monitor.c:285
 #, c-format
 msgctxt ""
 "This is a monitor vendor name, followed by a size in inches, like 'Dell 15\"'"
 msgid "%s %s"
 msgstr "%s %s"
 
-#: src/backends/meta-monitor.c:282
+#: src/backends/meta-monitor.c:293
 #, c-format
 msgctxt ""
 "This is a monitor vendor name followed by product/model name where size in "
@@ -627,26 +627,9 @@ msgstr "%s %s"
 msgid "Compositor"
 msgstr "Composidôr"
 
-#: src/backends/x11/meta-clutter-backend-x11.c:237
-msgid "X display to use"
-msgstr "Display X di doprâ"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:243
-msgid "X screen to use"
-msgstr "Schermi X di doprâ"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:248
-#: src/core/meta-context-main.c:583
-msgid "Make X calls synchronous"
-msgstr "Fâs lis clamadis X sincronis"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:254
-msgid "Disable XInput support"
-msgstr "Disabilite il supuart XInput"
-
 #. This probably means that a non-WM compositor like xcompmgr is running;
 #. * we have no way to get it to exit
-#: src/compositor/compositor.c:513
+#: src/compositor/compositor.c:504
 #, c-format
 msgid ""
 "Another compositing manager is already running on screen %i on display “%s”."
@@ -684,55 +667,59 @@ msgstr "Sfuarce _Jessude"
 msgid "_Wait"
 msgstr "_Spiete"
 
-#: src/core/meta-context-main.c:553
+#: src/core/meta-context-main.c:555
 msgid "Replace the running window manager"
 msgstr "Rimplace il window manager in vore"
 
-#: src/core/meta-context-main.c:559
+#: src/core/meta-context-main.c:561
 msgid "X Display to use"
 msgstr "Display X di doprâ"
 
-#: src/core/meta-context-main.c:565
+#: src/core/meta-context-main.c:567
 msgid "Disable connection to session manager"
 msgstr "Disabilite la conession al gjestôr de session"
 
-#: src/core/meta-context-main.c:571
+#: src/core/meta-context-main.c:573
 msgid "Specify session management ID"
 msgstr "Specifiche il ID di gjestion session"
 
-#: src/core/meta-context-main.c:577
+#: src/core/meta-context-main.c:579
 msgid "Initialize session from savefile"
 msgstr "Inizialize session da file salvât"
 
-#: src/core/meta-context-main.c:590
+#: src/core/meta-context-main.c:585
+msgid "Make X calls synchronous"
+msgstr "Fâs lis clamadis X sincronis"
+
+#: src/core/meta-context-main.c:592
 msgid "Run as a wayland compositor"
 msgstr "Eseguìs come compositor wayland"
 
-#: src/core/meta-context-main.c:596
+#: src/core/meta-context-main.c:598
 msgid "Run as a nested compositor"
 msgstr "Eseguìs come compositor nidiât"
 
-#: src/core/meta-context-main.c:602
+#: src/core/meta-context-main.c:604
 msgid "Run wayland compositor without starting Xwayland"
 msgstr "Eseguìs il compositôr di wayland cence inviâ Xwayland"
 
-#: src/core/meta-context-main.c:608
+#: src/core/meta-context-main.c:610
 msgid "Specify Wayland display name to use"
 msgstr "Specifiche il non dal display Wayland di doprâ"
 
-#: src/core/meta-context-main.c:616
+#: src/core/meta-context-main.c:618
 msgid "Run as a full display server, rather than nested"
 msgstr "Eseguìs come servidôr display complet, invezit che nidiât"
 
-#: src/core/meta-context-main.c:621
+#: src/core/meta-context-main.c:623
 msgid "Run as a headless display server"
 msgstr "Eseguìs come servidôr di visualizazion cence visôr"
 
-#: src/core/meta-context-main.c:626
+#: src/core/meta-context-main.c:628
 msgid "Add persistent virtual monitor (WxH or WxH@R)"
 msgstr "Zonte monitor virtuâl persistent (LxA o LxA@I)"
 
-#: src/core/meta-context-main.c:632
+#: src/core/meta-context-main.c:639
 msgid "Run with X11 backend"
 msgstr "Eseguìs cul backend X11"
 
@@ -755,11 +742,11 @@ msgstr "Cambie visôr"
 msgid "Show on-screen help"
 msgstr "Mostre jutori a schermi"
 
-#: src/core/mutter.c:47
+#: src/core/mutter.c:74
 msgid "Print version"
 msgstr "Stampe version"
 
-#: src/core/mutter.c:53
+#: src/core/mutter.c:80
 msgid "Mutter plugin to use"
 msgstr "Plugin Mutter di doprâ"
 
@@ -768,7 +755,7 @@ msgstr "Plugin Mutter di doprâ"
 msgid "Workspace %d"
 msgstr "Spazi di lavôr %d"
 
-#: src/core/util.c:148
+#: src/core/util.c:149
 msgid "Mutter was compiled without support for verbose mode"
 msgstr "Mutter al è stât compilât cence supuart pal mût prolìs"
 
@@ -795,7 +782,7 @@ msgstr "No si è rivâts a inizializâ GDK"
 msgid "Failed to open X Window System display “%s”"
 msgstr "Impussibil vierzi il display “%s” di X Window System"
 
-#: src/x11/meta-x11-display.c:1175
+#: src/x11/meta-x11-display.c:1181
 #, c-format
 msgid "Screen %d on display “%s” is invalid"
 msgstr "Schermi %d su display “%s” no valit"
@@ -805,7 +792,7 @@ msgstr "Schermi %d su display “%s” no valit"
 msgid "Format %s not supported"
 msgstr "Il formât %s nol è supuartât"
 
-#: src/x11/session.c:1845
+#: src/x11/session.c:1823
 msgid ""
 "These windows do not support “save current setup” and will have to be "
 "restarted manually next time you log in."
@@ -818,6 +805,18 @@ msgstr ""
 msgid "%s (on %s)"
 msgstr "%s (su %s)"
 
+#~ msgid "Show the activities overview"
+#~ msgstr "Mostre la panoramiche ativitâts"
+
+#~ msgid "X display to use"
+#~ msgstr "Display X di doprâ"
+
+#~ msgid "X screen to use"
+#~ msgstr "Schermi X di doprâ"
+
+#~ msgid "Disable XInput support"
+#~ msgstr "Disabilite il supuart XInput"
+
 #~ msgid ""
 #~ "mutter %s\n"
 #~ "Copyright © 2001-%d Havoc Pennington, Red Hat, Inc., and others\n"
diff --git a/po/he.po b/po/he.po
index 0e453b198..11f5f55fa 100644
--- a/po/he.po
+++ b/po/he.po
@@ -10,8 +10,8 @@ msgid ""
 msgstr ""
 "Project-Id-Version: metacity.HEAD.he\n"
 "Report-Msgid-Bugs-To: https://gitlab.gnome.org/GNOME/mutter/issues\n"
-"POT-Creation-Date: 2021-07-27 14:35+0000\n"
-"PO-Revision-Date: 2021-08-07 19:58+0300\n"
+"POT-Creation-Date: 2021-11-04 20:03+0000\n"
+"PO-Revision-Date: 2021-11-12 00:34+0200\n"
 "Last-Translator: Yaron Shahrabani <sh.yaron@gmail.com>\n"
 "Language-Team: Hebrew <yoseforb@gmail.com>\n"
 "Language: he\n"
@@ -181,10 +181,6 @@ msgstr "מערכת"
 msgid "Show the run command prompt"
 msgstr "הצגת החלונית להרצת פקודה"
 
-#: data/50-mutter-system.xml:10
-msgid "Show the activities overview"
-msgstr "הצגת סקירת הפעילויות"
-
 #: data/50-mutter-wayland.xml:8
 msgid "Restore the keyboard shortcuts"
 msgstr "שחזור צירופי מקשים"
@@ -253,11 +249,11 @@ msgstr "הגדלת החלון אנכית"
 msgid "Maximize window horizontally"
 msgstr "הגדלת החלון אופקית"
 
-#: data/50-mutter-windows.xml:41 data/org.gnome.mutter.gschema.xml.in:166
+#: data/50-mutter-windows.xml:41 data/org.gnome.mutter.gschema.xml.in:179
 msgid "View split on left"
 msgstr "פיצול הצפייה משמאל"
 
-#: data/50-mutter-windows.xml:45 data/org.gnome.mutter.gschema.xml.in:171
+#: data/50-mutter-windows.xml:45 data/org.gnome.mutter.gschema.xml.in:184
 msgid "View split on right"
 msgstr "פיצול הצפייה מימין"
 
@@ -265,11 +261,11 @@ msgstr "פיצול הצפייה מימין"
 msgid "Mutter"
 msgstr "Mutter"
 
-#: data/org.gnome.mutter.gschema.xml.in:7
+#: data/org.gnome.mutter.gschema.xml.in:16
 msgid "Modifier to use for extended window management operations"
 msgstr "Modifier to use for extended window management operations"
 
-#: data/org.gnome.mutter.gschema.xml.in:8
+#: data/org.gnome.mutter.gschema.xml.in:17
 msgid ""
 "This key will initiate the “overlay”, which is a combination window overview "
 "and application launching system. The default is intended to be the “Windows "
@@ -281,11 +277,11 @@ msgstr ""
 "key” on PC hardware. It’s expected that this binding either the default or "
 "set to the empty string."
 
-#: data/org.gnome.mutter.gschema.xml.in:20
+#: data/org.gnome.mutter.gschema.xml.in:29
 msgid "Attach modal dialogs"
 msgstr "Attach modal dialogs"
 
-#: data/org.gnome.mutter.gschema.xml.in:21
+#: data/org.gnome.mutter.gschema.xml.in:30
 msgid ""
 "When true, instead of having independent titlebars, modal dialogs appear "
 "attached to the titlebar of the parent window and are moved together with "
@@ -295,11 +291,11 @@ msgstr ""
 "attached to the titlebar of the parent window and are moved together with "
 "the parent window."
 
-#: data/org.gnome.mutter.gschema.xml.in:30
+#: data/org.gnome.mutter.gschema.xml.in:39
 msgid "Enable edge tiling when dropping windows on screen edges"
 msgstr "Enable edge tiling when dropping windows on screen edges"
 
-#: data/org.gnome.mutter.gschema.xml.in:31
+#: data/org.gnome.mutter.gschema.xml.in:40
 msgid ""
 "If enabled, dropping windows on vertical screen edges maximizes them "
 "vertically and resizes them horizontally to cover half of the available "
@@ -309,11 +305,11 @@ msgstr ""
 "vertically and resizes them horizontally to cover half of the available "
 "area. Dropping windows on the top screen edge maximizes them completely."
 
-#: data/org.gnome.mutter.gschema.xml.in:40
+#: data/org.gnome.mutter.gschema.xml.in:49
 msgid "Workspaces are managed dynamically"
 msgstr "Workspaces are managed dynamically"
 
-#: data/org.gnome.mutter.gschema.xml.in:41
+#: data/org.gnome.mutter.gschema.xml.in:50
 msgid ""
 "Determines whether workspaces are managed dynamically or whether there’s a "
 "static number of workspaces (determined by the num-workspaces key in org."
@@ -323,11 +319,11 @@ msgstr ""
 "static number of workspaces (determined by the num-workspaces key in org."
 "gnome.desktop.wm.preferences)."
 
-#: data/org.gnome.mutter.gschema.xml.in:50
+#: data/org.gnome.mutter.gschema.xml.in:59
 msgid "Workspaces only on primary"
 msgstr "Workspaces only on primary"
 
-#: data/org.gnome.mutter.gschema.xml.in:51
+#: data/org.gnome.mutter.gschema.xml.in:60
 msgid ""
 "Determines whether workspace switching should happen for windows on all "
 "monitors or only for windows on the primary monitor."
@@ -335,11 +331,11 @@ msgstr ""
 "Determines whether workspace switching should happen for windows on all "
 "monitors or only for windows on the primary monitor."
 
-#: data/org.gnome.mutter.gschema.xml.in:59
+#: data/org.gnome.mutter.gschema.xml.in:68
 msgid "No tab popup"
 msgstr "No tab popup"
 
-#: data/org.gnome.mutter.gschema.xml.in:60
+#: data/org.gnome.mutter.gschema.xml.in:69
 msgid ""
 "Determines whether the use of popup and highlight frame should be disabled "
 "for window cycling."
@@ -347,11 +343,11 @@ msgstr ""
 "Determines whether the use of popup and highlight frame should be disabled "
 "for window cycling."
 
-#: data/org.gnome.mutter.gschema.xml.in:68
+#: data/org.gnome.mutter.gschema.xml.in:77
 msgid "Delay focus changes until the pointer stops moving"
 msgstr "Delay focus changes until the pointer stops moving"
 
-#: data/org.gnome.mutter.gschema.xml.in:69
+#: data/org.gnome.mutter.gschema.xml.in:78
 msgid ""
 "If set to true, and the focus mode is either “sloppy” or “mouse” then the "
 "focus will not be changed immediately when entering a window, but only after "
@@ -361,11 +357,11 @@ msgstr ""
 "focus will not be changed immediately when entering a window, but only after "
 "the pointer stops moving."
 
-#: data/org.gnome.mutter.gschema.xml.in:79
+#: data/org.gnome.mutter.gschema.xml.in:88
 msgid "Draggable border width"
 msgstr "Draggable border width"
 
-#: data/org.gnome.mutter.gschema.xml.in:80
+#: data/org.gnome.mutter.gschema.xml.in:89
 msgid ""
 "The amount of total draggable borders. If the theme’s visible borders are "
 "not enough, invisible borders will be added to meet this value."
@@ -373,11 +369,11 @@ msgstr ""
 "The amount of total draggable borders. If the theme’s visible borders are "
 "not enough, invisible borders will be added to meet this value."
 
-#: data/org.gnome.mutter.gschema.xml.in:89
+#: data/org.gnome.mutter.gschema.xml.in:98
 msgid "Auto maximize nearly monitor sized windows"
 msgstr "Auto maximize nearly monitor sized windows"
 
-#: data/org.gnome.mutter.gschema.xml.in:90
+#: data/org.gnome.mutter.gschema.xml.in:99
 msgid ""
 "If enabled, new windows that are initially the size of the monitor "
 "automatically get maximized."
@@ -385,11 +381,11 @@ msgstr ""
 "If enabled, new windows that are initially the size of the monitor "
 "automatically get maximized."
 
-#: data/org.gnome.mutter.gschema.xml.in:98
+#: data/org.gnome.mutter.gschema.xml.in:107
 msgid "Place new windows in the center"
 msgstr "Place new windows in the center"
 
-#: data/org.gnome.mutter.gschema.xml.in:99
+#: data/org.gnome.mutter.gschema.xml.in:108
 msgid ""
 "When true, the new windows will always be put in the center of the active "
 "screen of the monitor."
@@ -397,11 +393,27 @@ msgstr ""
 "When true, the new windows will always be put in the center of the active "
 "screen of the monitor."
 
-#: data/org.gnome.mutter.gschema.xml.in:107
+#: data/org.gnome.mutter.gschema.xml.in:117
 msgid "Enable experimental features"
 msgstr "Enable experimental features"
 
-#: data/org.gnome.mutter.gschema.xml.in:108
+#: data/org.gnome.mutter.gschema.xml.in:118
+#| msgid ""
+#| "To enable experimental features, add the feature keyword to the list. "
+#| "Whether the feature requires restarting the compositor depends on the "
+#| "given feature. Any experimental feature is not required to still be "
+#| "available, or configurable. Don’t expect adding anything in this setting "
+#| "to be future proof. Currently possible keywords: • “scale-monitor-"
+#| "framebuffer” — makes mutter default to layout logical monitors in a "
+#| "logical pixel coordinate space, while scaling monitor framebuffers "
+#| "instead of window content, to manage HiDPI monitors. Does not require a "
+#| "restart. • “rt-scheduler” — makes mutter request a low priority real-time "
+#| "scheduling. The executable or user must have CAP_SYS_NICE. Requires a "
+#| "restart. • “dma-buf-screen-sharing\" — enables DMA buffered screen "
+#| "sharing. This is already enabled by default when using the i915 driver, "
+#| "but disabled for everything else. Requires a restart. • “autoclose-"
+#| "xwayland” — automatically terminates Xwayland if all relevant X11 clients "
+#| "are gone. Does not require a restart."
 msgid ""
 "To enable experimental features, add the feature keyword to the list. "
 "Whether the feature requires restarting the compositor depends on the given "
@@ -410,13 +422,15 @@ msgid ""
 "proof. Currently possible keywords: • “scale-monitor-framebuffer” — makes "
 "mutter default to layout logical monitors in a logical pixel coordinate "
 "space, while scaling monitor framebuffers instead of window content, to "
-"manage HiDPI monitors. Does not require a restart. • “rt-scheduler” — makes "
-"mutter request a low priority real-time scheduling. The executable or user "
-"must have CAP_SYS_NICE. Requires a restart. • “dma-buf-screen-sharing\" — "
-"enables DMA buffered screen sharing. This is already enabled by default when "
-"using the i915 driver, but disabled for everything else. Requires a restart. "
-"• “autoclose-xwayland” — automatically terminates Xwayland if all relevant "
-"X11 clients are gone. Does not require a restart."
+"manage HiDPI monitors. Does not require a restart. • “kms-modifiers” — makes "
+"mutter always advertise valid buffer modifiers on Wayland. This is currently "
+"not the case when using the i915 driver. Does not require a restart. • “rt-"
+"scheduler” — makes mutter request a low priority real-time scheduling. "
+"Requires a restart. • “dma-buf-screen-sharing” — enables DMA buffered screen "
+"sharing. This is already enabled by default when using the i915 driver, but "
+"disabled for everything else. Requires a restart. • “autoclose-xwayland” — "
+"automatically terminates Xwayland if all relevant X11 clients are gone. Does "
+"not require a restart."
 msgstr ""
 "To enable experimental features, add the feature keyword to the list. "
 "Whether the feature requires restarting the compositor depends on the given "
@@ -425,27 +439,29 @@ msgstr ""
 "proof. Currently possible keywords: • “scale-monitor-framebuffer” — makes "
 "mutter default to layout logical monitors in a logical pixel coordinate "
 "space, while scaling monitor framebuffers instead of window content, to "
-"manage HiDPI monitors. Does not require a restart. • “rt-scheduler” — makes "
-"mutter request a low priority real-time scheduling. The executable or user "
-"must have CAP_SYS_NICE. Requires a restart. • “dma-buf-screen-sharing\" — "
-"enables DMA buffered screen sharing. This is already enabled by default when "
-"using the i915 driver, but disabled for everything else. Requires a restart. "
-"• “autoclose-xwayland” — automatically terminates Xwayland if all relevant "
-"X11 clients are gone. Does not require a restart."
-
-#: data/org.gnome.mutter.gschema.xml.in:143
+"manage HiDPI monitors. Does not require a restart. • “kms-modifiers” — makes "
+"mutter always advertise valid buffer modifiers on Wayland. This is currently "
+"not the case when using the i915 driver. Does not require a restart. • “rt-"
+"scheduler” — makes mutter request a low priority real-time scheduling. "
+"Requires a restart. • “dma-buf-screen-sharing” — enables DMA buffered screen "
+"sharing. This is already enabled by default when using the i915 driver, but "
+"disabled for everything else. Requires a restart. • “autoclose-xwayland” — "
+"automatically terminates Xwayland if all relevant X11 clients are gone. Does "
+"not require a restart."
+
+#: data/org.gnome.mutter.gschema.xml.in:156
 msgid "Modifier to use to locate the pointer"
 msgstr "Modifier to use to locate the pointer"
 
-#: data/org.gnome.mutter.gschema.xml.in:144
+#: data/org.gnome.mutter.gschema.xml.in:157
 msgid "This key will initiate the “locate pointer” action."
 msgstr "This key will initiate the “locate pointer” action."
 
-#: data/org.gnome.mutter.gschema.xml.in:151
+#: data/org.gnome.mutter.gschema.xml.in:164
 msgid "Timeout for check-alive ping"
 msgstr "Timeout for check-alive ping"
 
-#: data/org.gnome.mutter.gschema.xml.in:152
+#: data/org.gnome.mutter.gschema.xml.in:165
 msgid ""
 "Number of milliseconds a client has to respond to a ping request in order to "
 "not be detected as frozen. Using 0 will disable the alive check completely."
@@ -453,19 +469,19 @@ msgstr ""
 "Number of milliseconds a client has to respond to a ping request in order to "
 "not be detected as frozen. Using 0 will disable the alive check completely."
 
-#: data/org.gnome.mutter.gschema.xml.in:176
+#: data/org.gnome.mutter.gschema.xml.in:189
 msgid "Select window from tab popup"
 msgstr "Select window from tab popup"
 
-#: data/org.gnome.mutter.gschema.xml.in:181
+#: data/org.gnome.mutter.gschema.xml.in:194
 msgid "Cancel tab popup"
 msgstr "Cancel tab popup"
 
-#: data/org.gnome.mutter.gschema.xml.in:186
+#: data/org.gnome.mutter.gschema.xml.in:199
 msgid "Switch monitor configurations"
 msgstr "החלפה בין תצורות צגים"
 
-#: data/org.gnome.mutter.gschema.xml.in:191
+#: data/org.gnome.mutter.gschema.xml.in:204
 msgid "Rotates the built-in monitor configuration"
 msgstr "Rotates the built-in monitor configuration"
 
@@ -591,26 +607,26 @@ msgstr ""
 "Xwayland was built without support for the selected extensions. Xwayland "
 "needs to be restarted for this setting to take effect."
 
-#: src/backends/meta-monitor.c:235
+#: src/backends/meta-monitor.c:246
 msgid "Built-in display"
 msgstr "תצוגה מובנית"
 
-#: src/backends/meta-monitor.c:264
+#: src/backends/meta-monitor.c:275
 msgid "Unknown"
 msgstr "לא ידוע"
 
-#: src/backends/meta-monitor.c:266
+#: src/backends/meta-monitor.c:277
 msgid "Unknown Display"
 msgstr "תצוגה לא ידועה"
 
-#: src/backends/meta-monitor.c:274
+#: src/backends/meta-monitor.c:285
 #, c-format
 msgctxt ""
 "This is a monitor vendor name, followed by a size in inches, like 'Dell 15\"'"
 msgid "%s %s"
 msgstr "‏%s ‏%s"
 
-#: src/backends/meta-monitor.c:282
+#: src/backends/meta-monitor.c:293
 #, c-format
 msgctxt ""
 "This is a monitor vendor name followed by product/model name where size in "
@@ -623,26 +639,9 @@ msgstr "‏%s ‏%s"
 msgid "Compositor"
 msgstr "תצוגת חלונות"
 
-#: src/backends/x11/meta-clutter-backend-x11.c:237
-msgid "X display to use"
-msgstr "תצוגת X לשימוש"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:243
-msgid "X screen to use"
-msgstr "מסך X לשימוש"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:248
-#: src/core/meta-context-main.c:583
-msgid "Make X calls synchronous"
-msgstr "להפוך את הקריאות ל־X לסינכרוניות"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:254
-msgid "Disable XInput support"
-msgstr "השבתת תמיכה ב־XInput"
-
 #. This probably means that a non-WM compositor like xcompmgr is running;
 #. * we have no way to get it to exit
-#: src/compositor/compositor.c:513
+#: src/compositor/compositor.c:504
 #, c-format
 msgid ""
 "Another compositing manager is already running on screen %i on display “%s”."
@@ -677,55 +676,59 @@ msgstr "_אילוץ סגירה"
 msgid "_Wait"
 msgstr "ה_מתנה"
 
-#: src/core/meta-context-main.c:553
+#: src/core/meta-context-main.c:555
 msgid "Replace the running window manager"
 msgstr "החלפת מנהל החלונות הפעיל"
 
-#: src/core/meta-context-main.c:559
+#: src/core/meta-context-main.c:561
 msgid "X Display to use"
 msgstr "תצוגת X לשימוש"
 
-#: src/core/meta-context-main.c:565
+#: src/core/meta-context-main.c:567
 msgid "Disable connection to session manager"
 msgstr "השבתת החיבור למנהל ההפעלות"
 
-#: src/core/meta-context-main.c:571
+#: src/core/meta-context-main.c:573
 msgid "Specify session management ID"
 msgstr "Specify session management ID"
 
-#: src/core/meta-context-main.c:577
+#: src/core/meta-context-main.c:579
 msgid "Initialize session from savefile"
 msgstr "Initialize session from savefile"
 
-#: src/core/meta-context-main.c:590
+#: src/core/meta-context-main.c:585
+msgid "Make X calls synchronous"
+msgstr "להפוך את הקריאות ל־X לסינכרוניות"
+
+#: src/core/meta-context-main.c:592
 msgid "Run as a wayland compositor"
 msgstr "Run as a wayland compositor"
 
-#: src/core/meta-context-main.c:596
+#: src/core/meta-context-main.c:598
 msgid "Run as a nested compositor"
 msgstr "Run as a nested compositor"
 
-#: src/core/meta-context-main.c:602
+#: src/core/meta-context-main.c:604
 msgid "Run wayland compositor without starting Xwayland"
 msgstr "Run wayland compositor without starting Xwayland"
 
-#: src/core/meta-context-main.c:608
+#: src/core/meta-context-main.c:610
 msgid "Specify Wayland display name to use"
 msgstr "Specify Wayland display name to use"
 
-#: src/core/meta-context-main.c:616
+#: src/core/meta-context-main.c:618
 msgid "Run as a full display server, rather than nested"
 msgstr "Run as a full display server, rather than nested"
 
-#: src/core/meta-context-main.c:621
+#: src/core/meta-context-main.c:623
 msgid "Run as a headless display server"
 msgstr "Run as a headless display server"
 
-#: src/core/meta-context-main.c:626
+#: src/core/meta-context-main.c:628
 msgid "Add persistent virtual monitor (WxH or WxH@R)"
 msgstr "Add persistent virtual monitor (WxH or WxH@R)"
 
-#: src/core/meta-context-main.c:632
+#: src/core/meta-context-main.c:639
 msgid "Run with X11 backend"
 msgstr "הפעלה עם מנגנון X11"
 
@@ -748,11 +751,11 @@ msgstr "החלפה בין צגים"
 msgid "Show on-screen help"
 msgstr "הצגת עזרה על המסך"
 
-#: src/core/mutter.c:47
+#: src/core/mutter.c:74
 msgid "Print version"
 msgstr "הצגת הגרסה"
 
-#: src/core/mutter.c:53
+#: src/core/mutter.c:80
 msgid "Mutter plugin to use"
 msgstr "תוסף ה־mutter לשימוש"
 
@@ -761,7 +764,7 @@ msgstr "תוסף ה־mutter לשימוש"
 msgid "Workspace %d"
 msgstr "מרחב עבודה %d"
 
-#: src/core/util.c:148
+#: src/core/util.c:149
 msgid "Mutter was compiled without support for verbose mode"
 msgstr "Mutter was compiled without support for verbose mode"
 
@@ -788,7 +791,7 @@ msgstr "Failed to initialize GDK"
 msgid "Failed to open X Window System display “%s”"
 msgstr "Failed to open X Window System display “%s”"
 
-#: src/x11/meta-x11-display.c:1175
+#: src/x11/meta-x11-display.c:1181
 #, c-format
 msgid "Screen %d on display “%s” is invalid"
 msgstr "Screen %d on display “%s” is invalid"
@@ -798,7 +801,7 @@ msgstr "Screen %d on display “%s” is invalid"
 msgid "Format %s not supported"
 msgstr "Format %s not supported"
 
-#: src/x11/session.c:1845
+#: src/x11/session.c:1823
 msgid ""
 "These windows do not support “save current setup” and will have to be "
 "restarted manually next time you log in."
@@ -811,6 +814,18 @@ msgstr ""
 msgid "%s (on %s)"
 msgstr "%s (מעל %s)"
 
+#~ msgid "Show the activities overview"
+#~ msgstr "הצגת סקירת הפעילויות"
+
+#~ msgid "X display to use"
+#~ msgstr "תצוגת X לשימוש"
+
+#~ msgid "X screen to use"
+#~ msgstr "מסך X לשימוש"
+
+#~ msgid "Disable XInput support"
+#~ msgstr "השבתת תמיכה ב־XInput"
+
 #~ msgid ""
 #~ "mutter %s\n"
 #~ "Copyright © 2001-%d Havoc Pennington, Red Hat, Inc., and others\n"
diff --git a/po/hr.po b/po/hr.po
index 7eca48c4e..021a028e8 100644
--- a/po/hr.po
+++ b/po/hr.po
@@ -5,8 +5,8 @@ msgid ""
 msgstr ""
 "Project-Id-Version: metacity 0\n"
 "Report-Msgid-Bugs-To: https://gitlab.gnome.org/GNOME/mutter/issues\n"
-"POT-Creation-Date: 2021-09-05 21:03+0000\n"
-"PO-Revision-Date: 2021-09-10 19:03+0200\n"
+"POT-Creation-Date: 2021-11-04 20:03+0000\n"
+"PO-Revision-Date: 2021-11-11 11:00+0100\n"
 "Last-Translator: gogo <trebelnik2@gmail.com>\n"
 "Language-Team: Croatian <lokalizacija@linux.hr>\n"
 "Language: hr\n"
@@ -16,7 +16,7 @@ msgstr ""
 "Plural-Forms: nplurals=3; plural=n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
 "%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2;\n"
 "X-Launchpad-Export-Date: 2008-05-28 13:28+0000\n"
-"X-Generator: Poedit 3.0\n"
+"X-Generator: Poedit 2.3\n"
 
 #: data/50-mutter-navigation.xml:6
 msgid "Navigation"
@@ -246,11 +246,11 @@ msgstr "Uvećaj prozor okomito"
 msgid "Maximize window horizontally"
 msgstr "Uvećaj prozor vodoravno"
 
-#: data/50-mutter-windows.xml:41 data/org.gnome.mutter.gschema.xml.in:166
+#: data/50-mutter-windows.xml:41 data/org.gnome.mutter.gschema.xml.in:179
 msgid "View split on left"
 msgstr "Podijeli pogled ulijevo"
 
-#: data/50-mutter-windows.xml:45 data/org.gnome.mutter.gschema.xml.in:171
+#: data/50-mutter-windows.xml:45 data/org.gnome.mutter.gschema.xml.in:184
 msgid "View split on right"
 msgstr "Podijeli pogled udesno"
 
@@ -258,11 +258,11 @@ msgstr "Podijeli pogled udesno"
 msgid "Mutter"
 msgstr "Mutter"
 
-#: data/org.gnome.mutter.gschema.xml.in:7
+#: data/org.gnome.mutter.gschema.xml.in:16
 msgid "Modifier to use for extended window management operations"
 msgstr "Izmjenjivač za korištenje radnji proširenog upravljanja prozorom"
 
-#: data/org.gnome.mutter.gschema.xml.in:8
+#: data/org.gnome.mutter.gschema.xml.in:17
 msgid ""
 "This key will initiate the “overlay”, which is a combination window overview "
 "and application launching system. The default is intended to be the “Windows "
@@ -274,11 +274,11 @@ msgstr ""
 "tipkovnici. Očekivano je da je ova kombinacija zadana ili postavljena na "
 "prazan niz."
 
-#: data/org.gnome.mutter.gschema.xml.in:20
+#: data/org.gnome.mutter.gschema.xml.in:29
 msgid "Attach modal dialogs"
 msgstr "Pričvrsti prozore dijaloga"
 
-#: data/org.gnome.mutter.gschema.xml.in:21
+#: data/org.gnome.mutter.gschema.xml.in:30
 msgid ""
 "When true, instead of having independent titlebars, modal dialogs appear "
 "attached to the titlebar of the parent window and are moved together with "
@@ -288,11 +288,11 @@ msgstr ""
 "na naslovnu traku sadržajnog prozora i pomiču se zajedno sa sadržajnim "
 "prozorom."
 
-#: data/org.gnome.mutter.gschema.xml.in:30
+#: data/org.gnome.mutter.gschema.xml.in:39
 msgid "Enable edge tiling when dropping windows on screen edges"
 msgstr "Omogući rubno popločavanje pri ispuštanju prozora na rubovima zaslona"
 
-#: data/org.gnome.mutter.gschema.xml.in:31
+#: data/org.gnome.mutter.gschema.xml.in:40
 msgid ""
 "If enabled, dropping windows on vertical screen edges maximizes them "
 "vertically and resizes them horizontally to cover half of the available "
@@ -302,11 +302,11 @@ msgstr ""
 "okomito i prilagođava veličinu vodoravno da prekrije polovicu dostupnog "
 "područja. Ispuštanje prozora na gornji rub zaslona uvećava ih u potpunosti."
 
-#: data/org.gnome.mutter.gschema.xml.in:40
+#: data/org.gnome.mutter.gschema.xml.in:49
 msgid "Workspaces are managed dynamically"
 msgstr "Radni prostori su upravljani promjenjivo"
 
-#: data/org.gnome.mutter.gschema.xml.in:41
+#: data/org.gnome.mutter.gschema.xml.in:50
 msgid ""
 "Determines whether workspaces are managed dynamically or whether there’s a "
 "static number of workspaces (determined by the num-workspaces key in org."
@@ -316,11 +316,11 @@ msgstr ""
 "broj radnih prostora (određeno brojem ključa radnih prostora u org.gnome."
 "desktop.wm.preferences)."
 
-#: data/org.gnome.mutter.gschema.xml.in:50
+#: data/org.gnome.mutter.gschema.xml.in:59
 msgid "Workspaces only on primary"
 msgstr "Radni prostori samo na glavnom zaslonu"
 
-#: data/org.gnome.mutter.gschema.xml.in:51
+#: data/org.gnome.mutter.gschema.xml.in:60
 msgid ""
 "Determines whether workspace switching should happen for windows on all "
 "monitors or only for windows on the primary monitor."
@@ -328,11 +328,11 @@ msgstr ""
 "Određuje treba li se prebacivanje radnog prostora pokrenuti za prozore na "
 "svim zaslonima ili samo za prozore na glavnom zaslonu."
 
-#: data/org.gnome.mutter.gschema.xml.in:59
+#: data/org.gnome.mutter.gschema.xml.in:68
 msgid "No tab popup"
 msgstr "Bez skočnih prozora"
 
-#: data/org.gnome.mutter.gschema.xml.in:60
+#: data/org.gnome.mutter.gschema.xml.in:69
 msgid ""
 "Determines whether the use of popup and highlight frame should be disabled "
 "for window cycling."
@@ -340,11 +340,11 @@ msgstr ""
 "Određuje treba li onemogućiti korištenje skočnog prozora i naglašavanje "
 "okvira za kruženje prozora."
 
-#: data/org.gnome.mutter.gschema.xml.in:68
+#: data/org.gnome.mutter.gschema.xml.in:77
 msgid "Delay focus changes until the pointer stops moving"
 msgstr "Odgoda promjene fokusa dok se pokazivač prestane pomicati"
 
-#: data/org.gnome.mutter.gschema.xml.in:69
+#: data/org.gnome.mutter.gschema.xml.in:78
 msgid ""
 "If set to true, and the focus mode is either “sloppy” or “mouse” then the "
 "focus will not be changed immediately when entering a window, but only after "
@@ -354,11 +354,11 @@ msgstr ""
 "neće odmah promijeniti kada se prebaci na prozor, nego nakon što se "
 "pokazivač prestane pomicati."
 
-#: data/org.gnome.mutter.gschema.xml.in:79
+#: data/org.gnome.mutter.gschema.xml.in:88
 msgid "Draggable border width"
 msgstr "Širina granice povlačenja"
 
-#: data/org.gnome.mutter.gschema.xml.in:80
+#: data/org.gnome.mutter.gschema.xml.in:89
 msgid ""
 "The amount of total draggable borders. If the theme’s visible borders are "
 "not enough, invisible borders will be added to meet this value."
@@ -366,11 +366,11 @@ msgstr ""
 "Količina ukupne granice povlačenja. Ako vidljiva granica teme nije dovoljna, "
 "nevidljiva granica će biti dodana kako bi se zadovoljila ova vrijednost."
 
-#: data/org.gnome.mutter.gschema.xml.in:89
+#: data/org.gnome.mutter.gschema.xml.in:98
 msgid "Auto maximize nearly monitor sized windows"
 msgstr "Automatski uvećaj prozore veličine približne zaslonu"
 
-#: data/org.gnome.mutter.gschema.xml.in:90
+#: data/org.gnome.mutter.gschema.xml.in:99
 msgid ""
 "If enabled, new windows that are initially the size of the monitor "
 "automatically get maximized."
@@ -378,22 +378,22 @@ msgstr ""
 "Ako je odabrano novi prozori koju su približno veličine zaslona automatski "
 "se uvečavaju."
 
-#: data/org.gnome.mutter.gschema.xml.in:98
+#: data/org.gnome.mutter.gschema.xml.in:107
 msgid "Place new windows in the center"
 msgstr "Smjesti novi prozor u sredinu"
 
-#: data/org.gnome.mutter.gschema.xml.in:99
+#: data/org.gnome.mutter.gschema.xml.in:108
 msgid ""
 "When true, the new windows will always be put in the center of the active "
 "screen of the monitor."
 msgstr ""
 "Ako je odabrano, novi prozor će uvijek biti u sredini aktivnog zaslona."
 
-#: data/org.gnome.mutter.gschema.xml.in:107
+#: data/org.gnome.mutter.gschema.xml.in:117
 msgid "Enable experimental features"
 msgstr "Omogući eksperimentalne značajke"
 
-#: data/org.gnome.mutter.gschema.xml.in:108
+#: data/org.gnome.mutter.gschema.xml.in:118
 msgid ""
 "To enable experimental features, add the feature keyword to the list. "
 "Whether the feature requires restarting the compositor depends on the given "
@@ -402,13 +402,15 @@ msgid ""
 "proof. Currently possible keywords: • “scale-monitor-framebuffer” — makes "
 "mutter default to layout logical monitors in a logical pixel coordinate "
 "space, while scaling monitor framebuffers instead of window content, to "
-"manage HiDPI monitors. Does not require a restart. • “rt-scheduler” — makes "
-"mutter request a low priority real-time scheduling. The executable or user "
-"must have CAP_SYS_NICE. Requires a restart. • “dma-buf-screen-sharing\" — "
-"enables DMA buffered screen sharing. This is already enabled by default when "
-"using the i915 driver, but disabled for everything else. Requires a restart. "
-"• “autoclose-xwayland” — automatically terminates Xwayland if all relevant "
-"X11 clients are gone. Does not require a restart."
+"manage HiDPI monitors. Does not require a restart. • “kms-modifiers” — makes "
+"mutter always advertise valid buffer modifiers on Wayland. This is currently "
+"not the case when using the i915 driver. Does not require a restart. • “rt-"
+"scheduler” — makes mutter request a low priority real-time scheduling. "
+"Requires a restart. • “dma-buf-screen-sharing” — enables DMA buffered screen "
+"sharing. This is already enabled by default when using the i915 driver, but "
+"disabled for everything else. Requires a restart. • “autoclose-xwayland” — "
+"automatically terminates Xwayland if all relevant X11 clients are gone. Does "
+"not require a restart."
 msgstr ""
 "Za omogućavanje eksperimentalnih značajki, dodajte ključnu riječ značajke na "
 "popis. Zahtijeva li značajka ponovno pokretanje kompozitora ovisi o zadanoj "
@@ -418,28 +420,31 @@ msgstr ""
 "monitor-framebuffer” — čini mutter zadanim izlazu logičkih zaslona u "
 "logičnom koordinatnom prostoru piksela, dok međuspremnik okvira mijenja "
 "veličinu zaslona umjesto sadržaja prozora, kako bi upravljao (HiDPI) "
-"zaslonima visoke razlučivosti. Ne zahtijeva ponovno pokretanje. • “rt-"
-"scheduler” — čini zahtjeve muttera zakazanima u niskom prioritetu i stvarnom "
-"vremenu. Izvršitelj ili korisnik mora imati CAP_SYS_NICE. Zahtijeva ponovno "
-"pokretanje. • “dma-buf-screen-sharing\" — omogućuje DMA međuspremljeno "
-"dijeljenje zaslona. To je već omogućeno po zadanome ako se koristi i915 "
-"upravljački program, ali je onemogućene za sve ostalo. Zahtijeva ponovno "
-"pokretanje. • “autoclose-xwayland” — automatski zatvara Xwayland ako su svi "
-"relevantni X11 klijenti nestali. Ne zahtijeva ponovno pokretanje."
-
-#: data/org.gnome.mutter.gschema.xml.in:143
+"zaslonima visoke razlučivosti. Ne zahtijeva ponovno pokretanje. • “kms-"
+"modifiers” — čini da mutter uvijek objavljuje valjane izmjenjivače "
+"međuspremnika na Waylandu. To trenutno nije slučaj kada se koriste i915 "
+"upravljački programi. Ne zahtijeva ponovno pokretanje. • “rt-scheduler” — "
+"čini zahtjeve muttera zakazanima u niskom prioritetu i stvarnom vremenu. "
+"Zahtijeva ponovno pokretanje. • “dma-buf-screen-sharing\" — omogućuje DMA "
+"međuspremljeno dijeljenje zaslona. To je već omogućeno po zadanome ako se "
+"koristi i915 upravljački program, ali je onemogućene za sve ostalo. "
+"Zahtijeva ponovno pokretanje. • “autoclose-xwayland” — automatski zatvara "
+"Xwayland ako su svi relevantni X11 klijenti nestali. Ne zahtijeva ponovno "
+"pokretanje."
+
+#: data/org.gnome.mutter.gschema.xml.in:156
 msgid "Modifier to use to locate the pointer"
 msgstr "Izmjenjivač za korištenje lociranja pokazivača"
 
-#: data/org.gnome.mutter.gschema.xml.in:144
+#: data/org.gnome.mutter.gschema.xml.in:157
 msgid "This key will initiate the “locate pointer” action."
 msgstr "Ova tipka će pokrenuti “lociraj pokazivač” radnju."
 
-#: data/org.gnome.mutter.gschema.xml.in:151
+#: data/org.gnome.mutter.gschema.xml.in:164
 msgid "Timeout for check-alive ping"
 msgstr "Vrijeme isteka provjere odgovora pinga"
 
-#: data/org.gnome.mutter.gschema.xml.in:152
+#: data/org.gnome.mutter.gschema.xml.in:165
 msgid ""
 "Number of milliseconds a client has to respond to a ping request in order to "
 "not be detected as frozen. Using 0 will disable the alive check completely."
@@ -448,19 +453,19 @@ msgstr ""
 "bi bio otkriven kao smrznut. Korištenje 0 će u potpunosti onemogućiti "
 "provjeru odgovora pinga."
 
-#: data/org.gnome.mutter.gschema.xml.in:176
+#: data/org.gnome.mutter.gschema.xml.in:189
 msgid "Select window from tab popup"
 msgstr "Odaberi prozor iz skočnog prozora"
 
-#: data/org.gnome.mutter.gschema.xml.in:181
+#: data/org.gnome.mutter.gschema.xml.in:194
 msgid "Cancel tab popup"
 msgstr "Prekini skočni prozor"
 
-#: data/org.gnome.mutter.gschema.xml.in:186
+#: data/org.gnome.mutter.gschema.xml.in:199
 msgid "Switch monitor configurations"
 msgstr "Prebacivanje podešavanja zaslona"
 
-#: data/org.gnome.mutter.gschema.xml.in:191
+#: data/org.gnome.mutter.gschema.xml.in:204
 msgid "Rotates the built-in monitor configuration"
 msgstr "Rotiraj ugrađeno podešavanje zaslona"
 
@@ -618,26 +623,9 @@ msgstr "%s %s"
 msgid "Compositor"
 msgstr "Kompozitor"
 
-#: src/backends/x11/meta-clutter-backend-x11.c:237
-msgid "X display to use"
-msgstr "X Prikaz za korištenje"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:243
-msgid "X screen to use"
-msgstr "X zaslon za korištenje"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:248
-#: src/core/meta-context-main.c:585
-msgid "Make X calls synchronous"
-msgstr "Napravi X pozive usklađenim"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:254
-msgid "Disable XInput support"
-msgstr "Onemogući XInput podršku"
-
 #. This probably means that a non-WM compositor like xcompmgr is running;
 #. * we have no way to get it to exit
-#: src/compositor/compositor.c:513
+#: src/compositor/compositor.c:504
 #, c-format
 msgid ""
 "Another compositing manager is already running on screen %i on display “%s”."
@@ -694,6 +682,10 @@ msgstr "Odredite ID upravljanja sesijama"
 msgid "Initialize session from savefile"
 msgstr "Pokreni sesiju iz spremljene datoteke"
 
+#: src/core/meta-context-main.c:585
+msgid "Make X calls synchronous"
+msgstr "Napravi X pozive usklađenim"
+
 #: src/core/meta-context-main.c:592
 msgid "Run as a wayland compositor"
 msgstr "Pokreni wayland kompozitor"
@@ -745,11 +737,11 @@ msgstr "Prebaci zaslon"
 msgid "Show on-screen help"
 msgstr "Prikaži zaslonsku pomoć"
 
-#: src/core/mutter.c:47
+#: src/core/mutter.c:74
 msgid "Print version"
 msgstr "Inačica za ispis"
 
-#: src/core/mutter.c:53
+#: src/core/mutter.c:80
 msgid "Mutter plugin to use"
 msgstr "Mutter priključak koji se koristi"
 
@@ -758,7 +750,7 @@ msgstr "Mutter priključak koji se koristi"
 msgid "Workspace %d"
 msgstr "Radni prostor %d"
 
-#: src/core/util.c:148
+#: src/core/util.c:149
 msgid "Mutter was compiled without support for verbose mode"
 msgstr "Mutter je kompiliran bez podrške za opširan način rada"
 
@@ -785,7 +777,7 @@ msgstr "Neuspjelo GDK pokretanje"
 msgid "Failed to open X Window System display “%s”"
 msgstr "Neuspjelo otvaranje sustava prikaza X prozora \"%s\""
 
-#: src/x11/meta-x11-display.c:1175
+#: src/x11/meta-x11-display.c:1181
 #, c-format
 msgid "Screen %d on display “%s” is invalid"
 msgstr "Zaslon %d na prikazu '%s' je neispravan"
@@ -795,7 +787,7 @@ msgstr "Zaslon %d na prikazu '%s' je neispravan"
 msgid "Format %s not supported"
 msgstr "Format %s nije podržan"
 
-#: src/x11/session.c:1845
+#: src/x11/session.c:1823
 msgid ""
 "These windows do not support “save current setup” and will have to be "
 "restarted manually next time you log in."
@@ -808,6 +800,15 @@ msgstr ""
 msgid "%s (on %s)"
 msgstr "%s (na %s)"
 
+#~ msgid "X display to use"
+#~ msgstr "X Prikaz za korištenje"
+
+#~ msgid "X screen to use"
+#~ msgstr "X zaslon za korištenje"
+
+#~ msgid "Disable XInput support"
+#~ msgstr "Onemogući XInput podršku"
+
 #~ msgid "Show the activities overview"
 #~ msgstr "Prikaži pregled aktivnosti"
 
diff --git a/po/id.po b/po/id.po
index 8183e12b4..54a10b917 100644
--- a/po/id.po
+++ b/po/id.po
@@ -11,8 +11,8 @@ msgid ""
 msgstr ""
 "Project-Id-Version: mutter master\n"
 "Report-Msgid-Bugs-To: https://gitlab.gnome.org/GNOME/mutter/issues\n"
-"POT-Creation-Date: 2021-07-19 15:55+0000\n"
-"PO-Revision-Date: 2021-07-25 21:05+0700\n"
+"POT-Creation-Date: 2021-12-20 11:23+0000\n"
+"PO-Revision-Date: 2021-12-24 13:57+0700\n"
 "Last-Translator: Kukuh Syafaat <kukuhsyafaat@gnome.org>\n"
 "Language-Team: Indonesian <gnome-l10n-id@googlegroups.com>\n"
 "Language: id\n"
@@ -20,7 +20,7 @@ msgstr ""
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "X-Generator: Poedit 3.0\n"
-"Plural-Forms: nplurals=2; plural= n!=1;\n"
+"Plural-Forms: nplurals=1; plural=0;\n"
 
 #: data/50-mutter-navigation.xml:6
 msgid "Navigation"
@@ -182,10 +182,6 @@ msgstr "Sistem"
 msgid "Show the run command prompt"
 msgstr "Tampilkan sapaan jalankan perintah"
 
-#: data/50-mutter-system.xml:10
-msgid "Show the activities overview"
-msgstr "Tampilkan ringkasan aktivitas"
-
 #: data/50-mutter-wayland.xml:8
 msgid "Restore the keyboard shortcuts"
 msgstr "Pulihkan pintasan papan tik"
@@ -254,11 +250,11 @@ msgstr "Maksimalkan ukuran jendela secara vertikal"
 msgid "Maximize window horizontally"
 msgstr "Maksimalkan ukuran jendela secara horisontal"
 
-#: data/50-mutter-windows.xml:41 data/org.gnome.mutter.gschema.xml.in:166
+#: data/50-mutter-windows.xml:41 data/org.gnome.mutter.gschema.xml.in:179
 msgid "View split on left"
 msgstr "Tilik belah di kiri"
 
-#: data/50-mutter-windows.xml:45 data/org.gnome.mutter.gschema.xml.in:171
+#: data/50-mutter-windows.xml:45 data/org.gnome.mutter.gschema.xml.in:184
 msgid "View split on right"
 msgstr "Tilik belah di kanan"
 
@@ -266,11 +262,11 @@ msgstr "Tilik belah di kanan"
 msgid "Mutter"
 msgstr "Mutter"
 
-#: data/org.gnome.mutter.gschema.xml.in:7
+#: data/org.gnome.mutter.gschema.xml.in:16
 msgid "Modifier to use for extended window management operations"
 msgstr "Tombol yang digunakan untuk memperluas operasi manajemen jendela"
 
-#: data/org.gnome.mutter.gschema.xml.in:8
+#: data/org.gnome.mutter.gschema.xml.in:17
 msgid ""
 "This key will initiate the “overlay”, which is a combination window overview "
 "and application launching system. The default is intended to be the “Windows "
@@ -282,11 +278,11 @@ msgstr ""
 "\"tombol Windows\" pada perangkat keras PC. Diharapkan agar pengikatan ini "
 "berupa baku atau diisi dengan kalimat kosong."
 
-#: data/org.gnome.mutter.gschema.xml.in:20
+#: data/org.gnome.mutter.gschema.xml.in:29
 msgid "Attach modal dialogs"
 msgstr "Lampirkan dialog modal"
 
-#: data/org.gnome.mutter.gschema.xml.in:21
+#: data/org.gnome.mutter.gschema.xml.in:30
 msgid ""
 "When true, instead of having independent titlebars, modal dialogs appear "
 "attached to the titlebar of the parent window and are moved together with "
@@ -295,11 +291,11 @@ msgstr ""
 "Jika bernilai \"true\", maka dialog modal akan muncul menempel pada baris "
 "judul jendela utama dan bergerak seiring perpindahan jendela utama tersebut."
 
-#: data/org.gnome.mutter.gschema.xml.in:30
+#: data/org.gnome.mutter.gschema.xml.in:39
 msgid "Enable edge tiling when dropping windows on screen edges"
 msgstr "Fungsikan pengubinan tepi ketika menjatuhkan jendela ke tepi layar"
 
-#: data/org.gnome.mutter.gschema.xml.in:31
+#: data/org.gnome.mutter.gschema.xml.in:40
 msgid ""
 "If enabled, dropping windows on vertical screen edges maximizes them "
 "vertically and resizes them horizontally to cover half of the available "
@@ -310,11 +306,11 @@ msgstr ""
 "menutupi separuh dari area yang tersedia. Menjatuhkan jendela pada tepi atas "
 "layar akan memaksimalkan mereka sepenuhnya."
 
-#: data/org.gnome.mutter.gschema.xml.in:40
+#: data/org.gnome.mutter.gschema.xml.in:49
 msgid "Workspaces are managed dynamically"
 msgstr "Ruang kerja dikelola secara dinamis"
 
-#: data/org.gnome.mutter.gschema.xml.in:41
+#: data/org.gnome.mutter.gschema.xml.in:50
 msgid ""
 "Determines whether workspaces are managed dynamically or whether there’s a "
 "static number of workspaces (determined by the num-workspaces key in org."
@@ -324,11 +320,11 @@ msgstr ""
 "sejumlah tetap ruang kerja (ditentukan oleh kunci num-workspaces dalam org."
 "gnome.desktop.wm.preferences)."
 
-#: data/org.gnome.mutter.gschema.xml.in:50
+#: data/org.gnome.mutter.gschema.xml.in:59
 msgid "Workspaces only on primary"
 msgstr "Ruang kerja hanya pada primer"
 
-#: data/org.gnome.mutter.gschema.xml.in:51
+#: data/org.gnome.mutter.gschema.xml.in:60
 msgid ""
 "Determines whether workspace switching should happen for windows on all "
 "monitors or only for windows on the primary monitor."
@@ -336,11 +332,11 @@ msgstr ""
 "Menentukan apakah perpindahan area kerja hanya terjadi pada jendela aplikasi "
 "di semua monitor atau hanya untuk jendela pada monitor utama."
 
-#: data/org.gnome.mutter.gschema.xml.in:59
+#: data/org.gnome.mutter.gschema.xml.in:68
 msgid "No tab popup"
 msgstr "Tak ada popup tab"
 
-#: data/org.gnome.mutter.gschema.xml.in:60
+#: data/org.gnome.mutter.gschema.xml.in:69
 msgid ""
 "Determines whether the use of popup and highlight frame should be disabled "
 "for window cycling."
@@ -348,11 +344,11 @@ msgstr ""
 "Menentukan apakah penggunaan popup dan rangka penyorot mesti dimatikan bagi "
 "perputaran jendela."
 
-#: data/org.gnome.mutter.gschema.xml.in:68
+#: data/org.gnome.mutter.gschema.xml.in:77
 msgid "Delay focus changes until the pointer stops moving"
 msgstr "Tunda perubahan fokus sampai penunjuk berhenti bergerak"
 
-#: data/org.gnome.mutter.gschema.xml.in:69
+#: data/org.gnome.mutter.gschema.xml.in:78
 msgid ""
 "If set to true, and the focus mode is either “sloppy” or “mouse” then the "
 "focus will not be changed immediately when entering a window, but only after "
@@ -362,11 +358,11 @@ msgstr ""
 "fokus tak akan berubah seketika saat memasuki suatu jendela, tapi hanya "
 "setelah penunjuk berhenti bergerak."
 
-#: data/org.gnome.mutter.gschema.xml.in:79
+#: data/org.gnome.mutter.gschema.xml.in:88
 msgid "Draggable border width"
 msgstr "Lebar batas yang dapat diseret"
 
-#: data/org.gnome.mutter.gschema.xml.in:80
+#: data/org.gnome.mutter.gschema.xml.in:89
 msgid ""
 "The amount of total draggable borders. If the theme’s visible borders are "
 "not enough, invisible borders will be added to meet this value."
@@ -374,11 +370,11 @@ msgstr ""
 "Total banyaknya tepi yang dapat diseret. Bila tepi tema yang nampak tak "
 "cukup, tepi tak nampak akan ditambahkan untuk memenuhi nilai ini."
 
-#: data/org.gnome.mutter.gschema.xml.in:89
+#: data/org.gnome.mutter.gschema.xml.in:98
 msgid "Auto maximize nearly monitor sized windows"
 msgstr "Memaksimalkan otomatis hampir memantau jendela yang ditata ukurannya"
 
-#: data/org.gnome.mutter.gschema.xml.in:90
+#: data/org.gnome.mutter.gschema.xml.in:99
 msgid ""
 "If enabled, new windows that are initially the size of the monitor "
 "automatically get maximized."
@@ -386,11 +382,11 @@ msgstr ""
 "Bila difungsikan, jendela baru yang awalnya seukuran monitor secara otomatis "
 "dimaksimalkan."
 
-#: data/org.gnome.mutter.gschema.xml.in:98
+#: data/org.gnome.mutter.gschema.xml.in:107
 msgid "Place new windows in the center"
 msgstr "Tempatkan jendela baru di tengah"
 
-#: data/org.gnome.mutter.gschema.xml.in:99
+#: data/org.gnome.mutter.gschema.xml.in:108
 msgid ""
 "When true, the new windows will always be put in the center of the active "
 "screen of the monitor."
@@ -398,11 +394,11 @@ msgstr ""
 "Ketika berisi true, jendela baru akan selalu diletakkan di tengah dari layar "
 "aktif dari monitor."
 
-#: data/org.gnome.mutter.gschema.xml.in:107
+#: data/org.gnome.mutter.gschema.xml.in:117
 msgid "Enable experimental features"
 msgstr "Aktifkan fitur eksperimental"
 
-#: data/org.gnome.mutter.gschema.xml.in:108
+#: data/org.gnome.mutter.gschema.xml.in:118
 msgid ""
 "To enable experimental features, add the feature keyword to the list. "
 "Whether the feature requires restarting the compositor depends on the given "
@@ -411,44 +407,48 @@ msgid ""
 "proof. Currently possible keywords: • “scale-monitor-framebuffer” — makes "
 "mutter default to layout logical monitors in a logical pixel coordinate "
 "space, while scaling monitor framebuffers instead of window content, to "
-"manage HiDPI monitors. Does not require a restart. • “rt-scheduler” — makes "
-"mutter request a low priority real-time scheduling. The executable or user "
-"must have CAP_SYS_NICE. Requires a restart. • “dma-buf-screen-sharing\" — "
-"enables DMA buffered screen sharing. This is already enabled by default when "
-"using the i915 driver, but disabled for everything else. Requires a restart. "
-"• “autoclose-xwayland” — automatically terminates Xwayland if all relevant "
-"X11 clients are gone. Does not require a restart."
+"manage HiDPI monitors. Does not require a restart. • “kms-modifiers” — makes "
+"mutter always advertise valid buffer modifiers on Wayland. This is currently "
+"not the case when using the i915 driver. Does not require a restart. • “rt-"
+"scheduler” — makes mutter request a low priority real-time scheduling. "
+"Requires a restart. • “dma-buf-screen-sharing” — enables DMA buffered screen "
+"sharing. This is already enabled by default when using the i915 driver, but "
+"disabled for everything else. Requires a restart. • “autoclose-xwayland” — "
+"automatically terminates Xwayland if all relevant X11 clients are gone. Does "
+"not require a restart."
 msgstr ""
 "Untuk mengaktifkan fitur eksperimental, tambahkan kata kunci fitur ke "
-"daftar. Apakah fitur memerlukan restart kompositor tergantung pada fitur "
-"yang diberikan. Fitur eksperimental apa pun tidak diperlukan untuk tetap "
-"tersedia, atau dapat dikonfigurasi. Jangan berharap menambahkan apa pun "
-"dalam pengaturan ini untuk menjadi bukti masa depan. Kata kunci yang saat "
-"ini mungkin: • \"scale-monitor-framebuffer\" - membuat bergumam default ke "
-"monitor logika tata letak dalam ruang koordinat piksel logis, sementara "
-"penskalaan framebuffer monitor alih-alih konten jendela, untuk mengelola "
-"monitor HiDPI. Tidak memerlukan mulai ulang. • \"rt-scheduler\" - membuat "
-"permintaan bergumam menjadi penjadwalan real-time prioritas rendah. Berkas "
-"bisa-eksekusi atau pengguna harus CAP_SYS_NICE. Memerlukan restart. • \"dma-"
-"buf-screen-sharing\" - memungkinkan berbagi layar buffering DMA. Ini sudah "
-"diaktifkan secara default saat menggunakan driver i915, tetapi dinonaktifkan "
-"untuk yang lainnya. Memerlukan restart. • \"autoclose-xwayland\" - secara "
-"otomatis mengakhiri Xwayland jika semua klien X11 yang relevan hilang. Tidak "
-"memerlukan mulai ulang."
-
-#: data/org.gnome.mutter.gschema.xml.in:143
+"daftar. Apakah fitur tersebut memerlukan mulai ulang kompositor tergantung "
+"pada fitur yang diberikan. Setiap fitur eksperimental tidak diperlukan untuk "
+"tetap tersedia, atau dapat dikonfigurasi. Jangan berharap menambahkan apa "
+"pun dalam pengaturan ini sebagai bukti di masa mendatang. Kata kunci yang "
+"mungkin saat ini: • “scale-monitor-framebuffer” — menjadikan mutter bawaan "
+"untuk mengatur monitor logis dalam ruang koordinat piksel logis, sementara "
+"menskalakan framebuffer monitor alih-alih konten jendela, untuk mengelola "
+"monitor HiDPI. Tidak memerlukan mulai ulang. • “kms-modifiers” — membuat "
+"mutter selalu mengiklankan pengubah buffer yang valid di Wayland. Saat ini "
+"tidak demikian halnya saat menggunakan penggerak i915. Tidak memerlukan "
+"mulai ulang. • \"rt-scheduler\" — menjadikan permintaan mutter sebagai "
+"penjadwalan waktu nyata dengan prioritas rendah. Membutuhkan mulai ulang. • "
+"“dma-buf-screen-sharing” — memungkinkan berbagi layar buffered DMA. Ini "
+"sudah diaktifkan secara bawaan saat menggunakan penggerak i915, tetapi "
+"dinonaktifkan untuk yang lainnya. Membutuhkan mulai ulang. • “autoclose-"
+"xwayland” — secara otomatis menghentikan Xwayland jika semua klien X11 yang "
+"relevan hilang. Tidak memerlukan mulai ulang."
+
+#: data/org.gnome.mutter.gschema.xml.in:156
 msgid "Modifier to use to locate the pointer"
 msgstr "Pengubah yang digunakan untuk menemukan penunjuk"
 
-#: data/org.gnome.mutter.gschema.xml.in:144
+#: data/org.gnome.mutter.gschema.xml.in:157
 msgid "This key will initiate the “locate pointer” action."
 msgstr "Kunci ini akan memulai aksi \"penunjuk lokasi\"."
 
-#: data/org.gnome.mutter.gschema.xml.in:151
+#: data/org.gnome.mutter.gschema.xml.in:164
 msgid "Timeout for check-alive ping"
 msgstr "Batas waktu untuk ping pemeriksaan hidup"
 
-#: data/org.gnome.mutter.gschema.xml.in:152
+#: data/org.gnome.mutter.gschema.xml.in:165
 msgid ""
 "Number of milliseconds a client has to respond to a ping request in order to "
 "not be detected as frozen. Using 0 will disable the alive check completely."
@@ -457,19 +457,19 @@ msgstr ""
 "agar tidak terdeteksi sebagai beku. Menggunakan 0 akan menonaktifkan "
 "pemeriksaan hidup sepenuhnya."
 
-#: data/org.gnome.mutter.gschema.xml.in:176
+#: data/org.gnome.mutter.gschema.xml.in:189
 msgid "Select window from tab popup"
 msgstr "Pilih jendela dari popup tab"
 
-#: data/org.gnome.mutter.gschema.xml.in:181
+#: data/org.gnome.mutter.gschema.xml.in:194
 msgid "Cancel tab popup"
 msgstr "Batalkan popup tab"
 
-#: data/org.gnome.mutter.gschema.xml.in:186
+#: data/org.gnome.mutter.gschema.xml.in:199
 msgid "Switch monitor configurations"
 msgstr "Tukar konfigurasi monitor bawaan"
 
-#: data/org.gnome.mutter.gschema.xml.in:191
+#: data/org.gnome.mutter.gschema.xml.in:204
 msgid "Rotates the built-in monitor configuration"
 msgstr "Memutar konfigurasi monitor bawaan"
 
@@ -598,26 +598,26 @@ msgstr ""
 "berpengaruh jika Xwayland dibangun tanpa dukungan untuk ekstensi yang "
 "dipilih. Xwayland perlu dimulai ulang untuk pengaturan ini berlaku."
 
-#: src/backends/meta-monitor.c:235
+#: src/backends/meta-monitor.c:246
 msgid "Built-in display"
 msgstr "Tampilan bawaan"
 
-#: src/backends/meta-monitor.c:264
+#: src/backends/meta-monitor.c:275
 msgid "Unknown"
 msgstr "Tak Dikenal"
 
-#: src/backends/meta-monitor.c:266
+#: src/backends/meta-monitor.c:277
 msgid "Unknown Display"
 msgstr "Tampilan Tak Dikenal"
 
-#: src/backends/meta-monitor.c:274
+#: src/backends/meta-monitor.c:285
 #, c-format
 msgctxt ""
 "This is a monitor vendor name, followed by a size in inches, like 'Dell 15\"'"
 msgid "%s %s"
 msgstr "%s %s"
 
-#: src/backends/meta-monitor.c:282
+#: src/backends/meta-monitor.c:293
 #, c-format
 msgctxt ""
 "This is a monitor vendor name followed by product/model name where size in "
@@ -630,26 +630,9 @@ msgstr "%s %s"
 msgid "Compositor"
 msgstr "Kompositor"
 
-#: src/backends/x11/meta-clutter-backend-x11.c:237
-msgid "X display to use"
-msgstr "Tampilan X yang akan dipakai"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:243
-msgid "X screen to use"
-msgstr "Layar X yang akan dipakai"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:248
-#: src/core/meta-context-main.c:583
-msgid "Make X calls synchronous"
-msgstr "Buat panggilan X selaras"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:254
-msgid "Disable XInput support"
-msgstr "Nonaktifkan dukungan XInput"
-
 #. This probably means that a non-WM compositor like xcompmgr is running;
 #. * we have no way to get it to exit
-#: src/compositor/compositor.c:513
+#: src/compositor/compositor.c:504
 #, c-format
 msgid ""
 "Another compositing manager is already running on screen %i on display “%s”."
@@ -677,63 +660,67 @@ msgid ""
 msgstr ""
 "Anda bisa memilih untuk menunggu sebentar atau memaksa aplikasi keluar."
 
-#: src/core/meta-close-dialog-default.c:165
+#: src/core/meta-close-dialog-default.c:164
 msgid "_Force Quit"
 msgstr "_Matikan Paksa"
 
-#: src/core/meta-close-dialog-default.c:165
+#: src/core/meta-close-dialog-default.c:164
 msgid "_Wait"
 msgstr "_Tunggu"
 
-#: src/core/meta-context-main.c:553
+#: src/core/meta-context-main.c:555
 msgid "Replace the running window manager"
 msgstr "Mengganti manajer jendela yang tengah berjalan"
 
-#: src/core/meta-context-main.c:559
+#: src/core/meta-context-main.c:561
 msgid "X Display to use"
 msgstr "Tampilan X yang digunakna"
 
-#: src/core/meta-context-main.c:565
+#: src/core/meta-context-main.c:567
 msgid "Disable connection to session manager"
 msgstr "Menonaktifkan koneksi ke manajer sesi"
 
-#: src/core/meta-context-main.c:571
+#: src/core/meta-context-main.c:573
 msgid "Specify session management ID"
 msgstr "Tentukan kode pengaturan sesi"
 
-#: src/core/meta-context-main.c:577
+#: src/core/meta-context-main.c:579
 msgid "Initialize session from savefile"
 msgstr "Aktifkan sesi dari berkas simpanan"
 
-#: src/core/meta-context-main.c:590
+#: src/core/meta-context-main.c:585
+msgid "Make X calls synchronous"
+msgstr "Buat panggilan X selaras"
+
+#: src/core/meta-context-main.c:592
 msgid "Run as a wayland compositor"
 msgstr "Jalankan sebagai kompositor wayland"
 
-#: src/core/meta-context-main.c:596
+#: src/core/meta-context-main.c:598
 msgid "Run as a nested compositor"
 msgstr "Jalankan sebagai kompositor bersarang"
 
-#: src/core/meta-context-main.c:602
+#: src/core/meta-context-main.c:604
 msgid "Run wayland compositor without starting Xwayland"
 msgstr "Jalankan kompositor wayland tanpa memmulai Xwayland"
 
-#: src/core/meta-context-main.c:608
+#: src/core/meta-context-main.c:610
 msgid "Specify Wayland display name to use"
 msgstr "Tentukan nama tampilan Wayland yang akan digunakan"
 
-#: src/core/meta-context-main.c:616
+#: src/core/meta-context-main.c:618
 msgid "Run as a full display server, rather than nested"
 msgstr "Jalankan sebagai server tampilan penuh, ketimbang tampilan bersarang"
 
-#: src/core/meta-context-main.c:621
+#: src/core/meta-context-main.c:623
 msgid "Run as a headless display server"
 msgstr "Jalankan sebagai peladen tampilan tanpa kepala (headless)"
 
-#: src/core/meta-context-main.c:626
+#: src/core/meta-context-main.c:628
 msgid "Add persistent virtual monitor (WxH or WxH@R)"
 msgstr "Tambah monitor virtual persisten (WxH atau WxH@R)"
 
-#: src/core/meta-context-main.c:632
+#: src/core/meta-context-main.c:639
 msgid "Run with X11 backend"
 msgstr "Jalankan dengan backend X11"
 
@@ -756,11 +743,11 @@ msgstr "Berpindah monitor"
 msgid "Show on-screen help"
 msgstr "Tampilkan bantuan pada layar"
 
-#: src/core/mutter.c:47
+#: src/core/mutter.c:74
 msgid "Print version"
 msgstr "Cetak versi"
 
-#: src/core/mutter.c:53
+#: src/core/mutter.c:80
 msgid "Mutter plugin to use"
 msgstr "Pengaya Mutter yang dipakai"
 
@@ -769,7 +756,7 @@ msgstr "Pengaya Mutter yang dipakai"
 msgid "Workspace %d"
 msgstr "Area kerja %d"
 
-#: src/core/util.c:148
+#: src/core/util.c:141
 msgid "Mutter was compiled without support for verbose mode"
 msgstr "Muter dikompilasi tanpa dukungan mode riuh"
 
@@ -796,7 +783,7 @@ msgstr "Gagal menginisialisasi GDK"
 msgid "Failed to open X Window System display “%s”"
 msgstr "Gagal membuka tampilan X Window System \"%s\""
 
-#: src/x11/meta-x11-display.c:1175
+#: src/x11/meta-x11-display.c:1181
 #, c-format
 msgid "Screen %d on display “%s” is invalid"
 msgstr "Layar %d pada tampilan \"%s\" tidak valid"
@@ -806,7 +793,7 @@ msgstr "Layar %d pada tampilan \"%s\" tidak valid"
 msgid "Format %s not supported"
 msgstr "Format %s tidak didukung"
 
-#: src/x11/session.c:1845
+#: src/x11/session.c:1823
 msgid ""
 "These windows do not support “save current setup” and will have to be "
 "restarted manually next time you log in."
@@ -819,6 +806,18 @@ msgstr ""
 msgid "%s (on %s)"
 msgstr "%s (pada %s)"
 
+#~ msgid "Show the activities overview"
+#~ msgstr "Tampilkan ringkasan aktivitas"
+
+#~ msgid "X display to use"
+#~ msgstr "Tampilan X yang akan dipakai"
+
+#~ msgid "X screen to use"
+#~ msgstr "Layar X yang akan dipakai"
+
+#~ msgid "Disable XInput support"
+#~ msgstr "Nonaktifkan dukungan XInput"
+
 #~ msgid ""
 #~ "mutter %s\n"
 #~ "Copyright © 2001-%d Havoc Pennington, Red Hat, Inc., and others\n"
diff --git a/po/is.po b/po/is.po
index 7f0d5cfcc..1e2b2c04b 100644
--- a/po/is.po
+++ b/po/is.po
@@ -2,14 +2,13 @@
 # This file is distributed under the same license as the PACKAGE package.
 #
 # FIRST AUTHOR  Samúel Jón Gunnarsson <sammi@techattack.nu>, 2003.
-# Sveinn í Felli <sv1@fellsnet.is>, 2017.
+# Sveinn í Felli <sv1@fellsnet.is>, 2017, 2021.
 msgid ""
 msgstr ""
 "Project-Id-Version: metacity\n"
-"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?"
-"product=mutter&keywords=I18N+L10N&component=general\n"
-"POT-Creation-Date: 2016-10-29 18:34+0000\n"
-"PO-Revision-Date: 2017-03-02 11:35+0000\n"
+"Report-Msgid-Bugs-To: https://gitlab.gnome.org/GNOME/mutter/issues\n"
+"POT-Creation-Date: 2021-10-26 16:56+0000\n"
+"PO-Revision-Date: 2021-12-16 17:39+0000\n"
 "Last-Translator: Sveinn í Felli <sv1@fellsnet.is>\n"
 "Language-Team: Icelandic <translation-team-is@lists.sourceforge.org>\n"
 "Language: is\n"
@@ -17,7 +16,7 @@ msgstr ""
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "Plural-Forms: nplurals=2; plural=n != 1;\n"
-"X-Generator: Lokalize 1.5\n"
+"X-Generator: Lokalize 19.12.3\n"
 
 #: data/50-mutter-navigation.xml:6
 msgid "Navigation"
@@ -40,7 +39,6 @@ msgid "Move window to workspace 4"
 msgstr "Flytja glugga yfir á vinnusvæði 4"
 
 #: data/50-mutter-navigation.xml:21
-#| msgid "Move window to workspace 1"
 msgid "Move window to last workspace"
 msgstr "Flytja glugga yfir á síðasta vinnusvæði"
 
@@ -52,132 +50,129 @@ msgstr "Flytja glugga til vinstri um eitt vinnusvæði"
 msgid "Move window one workspace to the right"
 msgstr "Flytja glugga til hægri um eitt vinnusvæði"
 
-#: data/50-mutter-navigation.xml:30
+#: data/50-mutter-navigation.xml:31
 msgid "Move window one workspace up"
 msgstr "Flytja glugga upp um eitt vinnusvæði"
 
-#: data/50-mutter-navigation.xml:33
+#: data/50-mutter-navigation.xml:35
 msgid "Move window one workspace down"
 msgstr "Flytja glugga niður um eitt vinnusvæði"
 
-#: data/50-mutter-navigation.xml:36
-#| msgid "Move window one workspace to the left"
+#: data/50-mutter-navigation.xml:38
 msgid "Move window one monitor to the left"
 msgstr "Flytja glugga á skjá til vinstri"
 
-#: data/50-mutter-navigation.xml:39
-#| msgid "Move window one workspace to the right"
+#: data/50-mutter-navigation.xml:41
 msgid "Move window one monitor to the right"
 msgstr "Flytja glugga á skjá til hægri"
 
-#: data/50-mutter-navigation.xml:42
-#| msgid "Move window one workspace up"
+#: data/50-mutter-navigation.xml:44
 msgid "Move window one monitor up"
 msgstr "Flytja glugga á skjá fyrir ofan"
 
-#: data/50-mutter-navigation.xml:45
-#| msgid "Move window one workspace down"
+#: data/50-mutter-navigation.xml:47
 msgid "Move window one monitor down"
 msgstr "Flytja glugga á skjá fyrir neðan"
 
-#: data/50-mutter-navigation.xml:49
+#: data/50-mutter-navigation.xml:51
 msgid "Switch applications"
 msgstr "Skipta á milli forrita"
 
-#: data/50-mutter-navigation.xml:54
+#: data/50-mutter-navigation.xml:56
 msgid "Switch to previous application"
 msgstr "Skipta í fyrra forrit"
 
-#: data/50-mutter-navigation.xml:58
+#: data/50-mutter-navigation.xml:60
 msgid "Switch windows"
 msgstr "Skipta á milli glugga"
 
-#: data/50-mutter-navigation.xml:63
+#: data/50-mutter-navigation.xml:65
 msgid "Switch to previous window"
 msgstr "Skipta yfir í fyrri glugga"
 
-#: data/50-mutter-navigation.xml:67
+#: data/50-mutter-navigation.xml:69
 msgid "Switch windows of an application"
 msgstr "Skipta um forritsglugga"
 
-#: data/50-mutter-navigation.xml:72
+#: data/50-mutter-navigation.xml:74
 msgid "Switch to previous window of an application"
 msgstr "Skipta í fyrri glugga forrits"
 
-#: data/50-mutter-navigation.xml:76
+#: data/50-mutter-navigation.xml:78
 msgid "Switch system controls"
 msgstr ""
 
-#: data/50-mutter-navigation.xml:81
+#: data/50-mutter-navigation.xml:83
 msgid "Switch to previous system control"
 msgstr ""
 
-#: data/50-mutter-navigation.xml:85
+#: data/50-mutter-navigation.xml:87
 msgid "Switch windows directly"
 msgstr "Skipta beint á milli glugga"
 
-#: data/50-mutter-navigation.xml:90
+#: data/50-mutter-navigation.xml:92
 msgid "Switch directly to previous window"
 msgstr "Skipta beint yfir í fyrri glugga"
 
-#: data/50-mutter-navigation.xml:94
+#: data/50-mutter-navigation.xml:96
 msgid "Switch windows of an app directly"
 msgstr ""
 
-#: data/50-mutter-navigation.xml:99
+#: data/50-mutter-navigation.xml:101
 msgid "Switch directly to previous window of an app"
 msgstr ""
 
-#: data/50-mutter-navigation.xml:103
+#: data/50-mutter-navigation.xml:105
 msgid "Switch system controls directly"
 msgstr ""
 
-#: data/50-mutter-navigation.xml:108
+#: data/50-mutter-navigation.xml:110
 msgid "Switch directly to previous system control"
 msgstr ""
 
-#: data/50-mutter-navigation.xml:111
+#: data/50-mutter-navigation.xml:113
 msgid "Hide all normal windows"
 msgstr "Fela alla venjulega glugga"
 
-#: data/50-mutter-navigation.xml:114
+#: data/50-mutter-navigation.xml:116
 msgid "Switch to workspace 1"
 msgstr "Skipta yfir á vinnusvæði 1"
 
-#: data/50-mutter-navigation.xml:117
+#: data/50-mutter-navigation.xml:119
 msgid "Switch to workspace 2"
 msgstr "Skipta yfir á vinnusvæði 2"
 
-#: data/50-mutter-navigation.xml:120
+#: data/50-mutter-navigation.xml:122
 msgid "Switch to workspace 3"
 msgstr "Skipta yfir á vinnusvæði 3"
 
-#: data/50-mutter-navigation.xml:123
+#: data/50-mutter-navigation.xml:125
 msgid "Switch to workspace 4"
 msgstr "Skipta yfir á vinnusvæði 4"
 
-#: data/50-mutter-navigation.xml:126
-#| msgid "Switch to workspace 1"
+#: data/50-mutter-navigation.xml:128
 msgid "Switch to last workspace"
 msgstr "Skipta yfir á síðasta vinnusvæði"
 
-#: data/50-mutter-navigation.xml:129
-msgid "Move to workspace left"
+#: data/50-mutter-navigation.xml:131
+#| msgid "Move to workspace left"
+msgid "Move to workspace on the left"
 msgstr "Flytja á vinnusvæðið til vinstri"
 
-#: data/50-mutter-navigation.xml:132
-msgid "Move to workspace right"
+#: data/50-mutter-navigation.xml:134
+#| msgid "Move to workspace right"
+msgid "Move to workspace on the right"
 msgstr "Flytja á vinnusvæðið til hægri"
 
-#: data/50-mutter-navigation.xml:135
+#: data/50-mutter-navigation.xml:138
 msgid "Move to workspace above"
 msgstr "Flytja á vinnusvæðið fyrir ofan"
 
-#: data/50-mutter-navigation.xml:138
+#: data/50-mutter-navigation.xml:142
 msgid "Move to workspace below"
 msgstr "Flytja á vinnusvæðið fyrir neðan"
 
-#: data/50-mutter-system.xml:6
+#: data/50-mutter-system.xml:6 data/50-mutter-wayland.xml:6
 msgid "System"
 msgstr "Kerfið"
 
@@ -185,16 +180,15 @@ msgstr "Kerfið"
 msgid "Show the run command prompt"
 msgstr "Birta skipanalínuna"
 
-#: data/50-mutter-system.xml:10
-msgid "Show the activities overview"
-msgstr "Birta virkniyfirlit"
+#: data/50-mutter-wayland.xml:8
+msgid "Restore the keyboard shortcuts"
+msgstr ""
 
 #: data/50-mutter-windows.xml:6
 msgid "Windows"
 msgstr "Gluggar"
 
 #: data/50-mutter-windows.xml:8
-#| msgid "Activate window menu"
 msgid "Activate the window menu"
 msgstr "Virkja gluggavalmynd"
 
@@ -215,57 +209,51 @@ msgid "Restore window"
 msgstr "Endurheimta glugga"
 
 #: data/50-mutter-windows.xml:18
-msgid "Toggle shaded state"
-msgstr "Víxla skyggingarstöðu af/á"
-
-#: data/50-mutter-windows.xml:20
 msgid "Close window"
 msgstr "Loka glugga"
 
-#: data/50-mutter-windows.xml:22
+#: data/50-mutter-windows.xml:20
 msgid "Hide window"
 msgstr "Fela glugga"
 
-#: data/50-mutter-windows.xml:24
+#: data/50-mutter-windows.xml:22
 msgid "Move window"
 msgstr "Flytja glugga"
 
-#: data/50-mutter-windows.xml:26
+#: data/50-mutter-windows.xml:24
 msgid "Resize window"
 msgstr "Breyta stærð glugga"
 
-#: data/50-mutter-windows.xml:29
-#| msgid "Move window one workspace down"
+#: data/50-mutter-windows.xml:27
 msgid "Toggle window on all workspaces or one"
 msgstr ""
 "Skipta á milli þess hvort glugginn sé á öllum vinnusvæðum eða bara einu"
 
-#: data/50-mutter-windows.xml:31
-#| msgid "Raise window above other windows"
+#: data/50-mutter-windows.xml:29
 msgid "Raise window if covered, otherwise lower it"
 msgstr "Hækka glugga ef annar gluggi hylur hann, annars skal lækka hann"
 
-#: data/50-mutter-windows.xml:33
+#: data/50-mutter-windows.xml:31
 msgid "Raise window above other windows"
 msgstr "Hækka glugga upp fyrir aðra glugga"
 
-#: data/50-mutter-windows.xml:35
+#: data/50-mutter-windows.xml:33
 msgid "Lower window below other windows"
 msgstr "Lækka glugga niður fyrir aðra glugga"
 
-#: data/50-mutter-windows.xml:37
+#: data/50-mutter-windows.xml:35
 msgid "Maximize window vertically"
 msgstr "Hámarka glugga lóðrétt"
 
-#: data/50-mutter-windows.xml:39
+#: data/50-mutter-windows.xml:37
 msgid "Maximize window horizontally"
 msgstr "Hámarka glugga lárétt"
 
-#: data/50-mutter-windows.xml:43
+#: data/50-mutter-windows.xml:41 data/org.gnome.mutter.gschema.xml.in:179
 msgid "View split on left"
 msgstr "Kljúfa sýn til vinstri"
 
-#: data/50-mutter-windows.xml:47
+#: data/50-mutter-windows.xml:45 data/org.gnome.mutter.gschema.xml.in:184
 msgid "View split on right"
 msgstr "Kljúfa sýn til hægri"
 
@@ -273,236 +261,332 @@ msgstr "Kljúfa sýn til hægri"
 msgid "Mutter"
 msgstr "Mutter"
 
-#: data/org.gnome.mutter.gschema.xml.in:7
+#: data/org.gnome.mutter.gschema.xml.in:16
 msgid "Modifier to use for extended window management operations"
 msgstr ""
 
-#: data/org.gnome.mutter.gschema.xml.in:8
+#: data/org.gnome.mutter.gschema.xml.in:17
 msgid ""
-"This key will initiate the \"overlay\", which is a combination window "
-"overview and application launching system. The default is intended to be the "
-"\"Windows key\" on PC hardware. It's expected that this binding either the "
-"default or set to the empty string."
+"This key will initiate the “overlay”, which is a combination window overview "
+"and application launching system. The default is intended to be the “Windows "
+"key” on PC hardware. It’s expected that this binding either the default or "
+"set to the empty string."
 msgstr ""
 
-#: data/org.gnome.mutter.gschema.xml.in:20
+#: data/org.gnome.mutter.gschema.xml.in:29
 msgid "Attach modal dialogs"
 msgstr "Tengja kvaðningarglugga"
 
-#: data/org.gnome.mutter.gschema.xml.in:21
+#: data/org.gnome.mutter.gschema.xml.in:30
 msgid ""
 "When true, instead of having independent titlebars, modal dialogs appear "
 "attached to the titlebar of the parent window and are moved together with "
 "the parent window."
 msgstr ""
 
-#: data/org.gnome.mutter.gschema.xml.in:30
+#: data/org.gnome.mutter.gschema.xml.in:39
 msgid "Enable edge tiling when dropping windows on screen edges"
 msgstr "Virkja flísalögn við jaðra þegar gluggum er sleppt á skjájaðra"
 
-#: data/org.gnome.mutter.gschema.xml.in:31
+#: data/org.gnome.mutter.gschema.xml.in:40
 msgid ""
 "If enabled, dropping windows on vertical screen edges maximizes them "
 "vertically and resizes them horizontally to cover half of the available "
 "area. Dropping windows on the top screen edge maximizes them completely."
 msgstr ""
 
-#: data/org.gnome.mutter.gschema.xml.in:40
+#: data/org.gnome.mutter.gschema.xml.in:49
 msgid "Workspaces are managed dynamically"
 msgstr "Vinnusvæðum er stýrt eftir þörfum"
 
-#: data/org.gnome.mutter.gschema.xml.in:41
+#: data/org.gnome.mutter.gschema.xml.in:50
 msgid ""
-"Determines whether workspaces are managed dynamically or whether there's a "
+"Determines whether workspaces are managed dynamically or whether there’s a "
 "static number of workspaces (determined by the num-workspaces key in org."
 "gnome.desktop.wm.preferences)."
 msgstr ""
 
-#: data/org.gnome.mutter.gschema.xml.in:50
+#: data/org.gnome.mutter.gschema.xml.in:59
 msgid "Workspaces only on primary"
 msgstr "Vinnusvæði einungis á aðalskjá"
 
-#: data/org.gnome.mutter.gschema.xml.in:51
+#: data/org.gnome.mutter.gschema.xml.in:60
 msgid ""
 "Determines whether workspace switching should happen for windows on all "
 "monitors or only for windows on the primary monitor."
 msgstr ""
 
-#: data/org.gnome.mutter.gschema.xml.in:59
+#: data/org.gnome.mutter.gschema.xml.in:68
 msgid "No tab popup"
 msgstr ""
 
-#: data/org.gnome.mutter.gschema.xml.in:60
+#: data/org.gnome.mutter.gschema.xml.in:69
 msgid ""
 "Determines whether the use of popup and highlight frame should be disabled "
 "for window cycling."
 msgstr ""
 
-#: data/org.gnome.mutter.gschema.xml.in:68
+#: data/org.gnome.mutter.gschema.xml.in:77
 msgid "Delay focus changes until the pointer stops moving"
 msgstr ""
 
-#: data/org.gnome.mutter.gschema.xml.in:69
+#: data/org.gnome.mutter.gschema.xml.in:78
 msgid ""
-"If set to true, and the focus mode is either \"sloppy\" or \"mouse\" then "
-"the focus will not be changed immediately when entering a window, but only "
-"after the pointer stops moving."
+"If set to true, and the focus mode is either “sloppy” or “mouse” then the "
+"focus will not be changed immediately when entering a window, but only after "
+"the pointer stops moving."
 msgstr ""
 
-#: data/org.gnome.mutter.gschema.xml.in:79
+#: data/org.gnome.mutter.gschema.xml.in:88
 msgid "Draggable border width"
 msgstr ""
 
-#: data/org.gnome.mutter.gschema.xml.in:80
+#: data/org.gnome.mutter.gschema.xml.in:89
 msgid ""
-"The amount of total draggable borders. If the theme's visible borders are "
+"The amount of total draggable borders. If the theme’s visible borders are "
 "not enough, invisible borders will be added to meet this value."
 msgstr ""
 
-#: data/org.gnome.mutter.gschema.xml.in:89
+#: data/org.gnome.mutter.gschema.xml.in:98
 msgid "Auto maximize nearly monitor sized windows"
 msgstr ""
 
-#: data/org.gnome.mutter.gschema.xml.in:90
+#: data/org.gnome.mutter.gschema.xml.in:99
 msgid ""
 "If enabled, new windows that are initially the size of the monitor "
 "automatically get maximized."
 msgstr ""
 
-#: data/org.gnome.mutter.gschema.xml.in:98
+#: data/org.gnome.mutter.gschema.xml.in:107
 msgid "Place new windows in the center"
 msgstr "Setja nýja glugga á miðjuna"
 
-#: data/org.gnome.mutter.gschema.xml.in:99
+#: data/org.gnome.mutter.gschema.xml.in:108
 msgid ""
 "When true, the new windows will always be put in the center of the active "
 "screen of the monitor."
 msgstr ""
 
-#: data/org.gnome.mutter.gschema.xml.in:120
+#: data/org.gnome.mutter.gschema.xml.in:117
+msgid "Enable experimental features"
+msgstr ""
+
+#: data/org.gnome.mutter.gschema.xml.in:118
+msgid ""
+"To enable experimental features, add the feature keyword to the list. "
+"Whether the feature requires restarting the compositor depends on the given "
+"feature. Any experimental feature is not required to still be available, or "
+"configurable. Don’t expect adding anything in this setting to be future "
+"proof. Currently possible keywords: • “scale-monitor-framebuffer” — makes "
+"mutter default to layout logical monitors in a logical pixel coordinate "
+"space, while scaling monitor framebuffers instead of window content, to "
+"manage HiDPI monitors. Does not require a restart. • “kms-modifiers” — makes "
+"mutter always advertise valid buffer modifiers on Wayland. This is currently "
+"not the case when using the i915 driver. Does not require a restart. • “rt-"
+"scheduler” — makes mutter request a low priority real-time scheduling. "
+"Requires a restart. • “dma-buf-screen-sharing” — enables DMA buffered screen "
+"sharing. This is already enabled by default when using the i915 driver, but "
+"disabled for everything else. Requires a restart. • “autoclose-xwayland” — "
+"automatically terminates Xwayland if all relevant X11 clients are gone. Does "
+"not require a restart."
+msgstr ""
+
+#: data/org.gnome.mutter.gschema.xml.in:156
+msgid "Modifier to use to locate the pointer"
+msgstr ""
+
+#: data/org.gnome.mutter.gschema.xml.in:157
+msgid "This key will initiate the “locate pointer” action."
+msgstr ""
+
+#: data/org.gnome.mutter.gschema.xml.in:164
+msgid "Timeout for check-alive ping"
+msgstr ""
+
+#: data/org.gnome.mutter.gschema.xml.in:165
+msgid ""
+"Number of milliseconds a client has to respond to a ping request in order to "
+"not be detected as frozen. Using 0 will disable the alive check completely."
+msgstr ""
+
+#: data/org.gnome.mutter.gschema.xml.in:189
 msgid "Select window from tab popup"
 msgstr ""
 
-#: data/org.gnome.mutter.gschema.xml.in:125
+#: data/org.gnome.mutter.gschema.xml.in:194
 msgid "Cancel tab popup"
 msgstr ""
 
-#: data/org.gnome.mutter.wayland.gschema.xml.in:6
-#| msgid "Switch to workspace 1"
+#: data/org.gnome.mutter.gschema.xml.in:199
+#| msgid "Switch monitor"
+msgid "Switch monitor configurations"
+msgstr "Skipta um skjáuppsetningu"
+
+#: data/org.gnome.mutter.gschema.xml.in:204
+msgid "Rotates the built-in monitor configuration"
+msgstr ""
+
+#: data/org.gnome.mutter.wayland.gschema.xml.in:12
 msgid "Switch to VT 1"
 msgstr "Skipta yfir á vinnusvæði 1"
 
-#: data/org.gnome.mutter.wayland.gschema.xml.in:10
-#| msgid "Switch to workspace 2"
+#: data/org.gnome.mutter.wayland.gschema.xml.in:16
 msgid "Switch to VT 2"
 msgstr "Skipta yfir á vinnusvæði 2"
 
-#: data/org.gnome.mutter.wayland.gschema.xml.in:14
-#| msgid "Switch to workspace 3"
+#: data/org.gnome.mutter.wayland.gschema.xml.in:20
 msgid "Switch to VT 3"
 msgstr "Skipta yfir á vinnusvæði 3"
 
-#: data/org.gnome.mutter.wayland.gschema.xml.in:18
-#| msgid "Switch to workspace 4"
+#: data/org.gnome.mutter.wayland.gschema.xml.in:24
 msgid "Switch to VT 4"
 msgstr "Skipta yfir á vinnusvæði 4"
 
-#: data/org.gnome.mutter.wayland.gschema.xml.in:22
-#| msgid "Switch to workspace 5"
+#: data/org.gnome.mutter.wayland.gschema.xml.in:28
 msgid "Switch to VT 5"
 msgstr "Skipta yfir á vinnusvæði 5"
 
-#: data/org.gnome.mutter.wayland.gschema.xml.in:26
-#| msgid "Switch to workspace 6"
+#: data/org.gnome.mutter.wayland.gschema.xml.in:32
 msgid "Switch to VT 6"
 msgstr "Skipta yfir á vinnusvæði 6"
 
-#: data/org.gnome.mutter.wayland.gschema.xml.in:30
-#| msgid "Switch to workspace 7"
+#: data/org.gnome.mutter.wayland.gschema.xml.in:36
 msgid "Switch to VT 7"
 msgstr "Skipta yfir á vinnusvæði 7"
 
-#: data/org.gnome.mutter.wayland.gschema.xml.in:34
-#| msgid "Switch to workspace 8"
+#: data/org.gnome.mutter.wayland.gschema.xml.in:40
 msgid "Switch to VT 8"
 msgstr "Skipta yfir á vinnusvæði 8"
 
-#: data/org.gnome.mutter.wayland.gschema.xml.in:38
-#| msgid "Switch to workspace 9"
+#: data/org.gnome.mutter.wayland.gschema.xml.in:44
 msgid "Switch to VT 9"
 msgstr "Skipta yfir á vinnusvæði 9"
 
-#: data/org.gnome.mutter.wayland.gschema.xml.in:42
-#| msgid "Switch to workspace 10"
+#: data/org.gnome.mutter.wayland.gschema.xml.in:48
 msgid "Switch to VT 10"
 msgstr "Skipta yfir á vinnusvæði 10"
 
-#: data/org.gnome.mutter.wayland.gschema.xml.in:46
-#| msgid "Switch to workspace 11"
+#: data/org.gnome.mutter.wayland.gschema.xml.in:52
 msgid "Switch to VT 11"
 msgstr "Skipta yfir á vinnusvæði 11"
 
-#: data/org.gnome.mutter.wayland.gschema.xml.in:50
-#| msgid "Switch to workspace 12"
+#: data/org.gnome.mutter.wayland.gschema.xml.in:56
 msgid "Switch to VT 12"
 msgstr "Skipta yfir á vinnusvæði 12"
 
-#. TRANSLATORS: This string refers to an action, cycles drawing tablets'
-#. * mapping through the available outputs.
-#.
-#: src/backends/meta-input-settings.c:1847
-msgid "Switch monitor"
-msgstr "Skipta um skjá"
+#: data/org.gnome.mutter.wayland.gschema.xml.in:60
+msgid "Re-enable shortcuts"
+msgstr ""
 
-#: src/backends/meta-input-settings.c:1849
-msgid "Show on-screen help"
-msgstr "Birta upplýsingar á skjá"
+#: data/org.gnome.mutter.wayland.gschema.xml.in:70
+msgid "Allow X11 grabs to lock keyboard focus with Xwayland"
+msgstr ""
+
+#: data/org.gnome.mutter.wayland.gschema.xml.in:71
+msgid ""
+"Allow all keyboard events to be routed to X11 “override redirect” windows "
+"with a grab when running in Xwayland. This option is to support X11 clients "
+"which map an “override redirect” window (which do not receive keyboard "
+"focus) and issue a keyboard grab to force all keyboard events to that "
+"window. This option is seldom used and has no effect on regular X11 windows "
+"which can receive keyboard focus under normal circumstances. For a X11 grab "
+"to be taken into account under Wayland, the client must also either send a "
+"specific X11 ClientMessage to the root window or be among the applications "
+"allowed in key “xwayland-grab-access-rules”."
+msgstr ""
 
-#: src/backends/meta-monitor-manager.c:514
+#: data/org.gnome.mutter.wayland.gschema.xml.in:90
+msgid "Xwayland applications allowed to issue keyboard grabs"
+msgstr ""
+
+#: data/org.gnome.mutter.wayland.gschema.xml.in:91
+msgid ""
+"List the resource names or resource class of X11 windows either allowed or "
+"not allowed to issue X11 keyboard grabs under Xwayland. The resource name or "
+"resource class of a given X11 window can be obtained using the command "
+"“xprop WM_CLASS”. Wildcards “*” and jokers “?” in the values are supported. "
+"Values starting with “!” are denied, which has precedence over the list of "
+"values allowed, to revoke applications from the default system list. The "
+"default system list includes the following applications: "
+"“@XWAYLAND_GRAB_DEFAULT_ACCESS_RULES@” Users can break an existing grab by "
+"using the specific keyboard shortcut defined by the keybinding key “restore-"
+"shortcuts”."
+msgstr ""
+
+#: data/org.gnome.mutter.wayland.gschema.xml.in:116
+msgid "Disable selected X extensions in Xwayland"
+msgstr ""
+
+#: data/org.gnome.mutter.wayland.gschema.xml.in:117
+msgid ""
+"This option disables the selected X extensions in Xwayland if Xwayland was "
+"built with support for those X extensions. This option has no effect if "
+"Xwayland was built without support for the selected extensions. Xwayland "
+"needs to be restarted for this setting to take effect."
+msgstr ""
+
+#: src/backends/meta-monitor.c:246
 msgid "Built-in display"
 msgstr "Innbyggður skjár"
 
-#: src/backends/meta-monitor-manager.c:537
+#: src/backends/meta-monitor.c:275
 msgid "Unknown"
 msgstr "Óþekkt"
 
-#: src/backends/meta-monitor-manager.c:539
+#: src/backends/meta-monitor.c:277
 msgid "Unknown Display"
 msgstr "Óþekktur skjár"
 
-#. TRANSLATORS: this is a monitor vendor name, followed by a
-#. * size in inches, like 'Dell 15"'
-#.
-#: src/backends/meta-monitor-manager.c:547
+#: src/backends/meta-monitor.c:285
+#, c-format
+#| msgid "%s %s"
+msgctxt ""
+"This is a monitor vendor name, followed by a size in inches, like 'Dell 15\"'"
+msgid "%s %s"
+msgstr "%s %s"
+
+#: src/backends/meta-monitor.c:293
 #, c-format
+#| msgid "%s %s"
+msgctxt ""
+"This is a monitor vendor name followed by product/model name where size in "
+"inches could not be calculated, e.g. Dell U2414H"
 msgid "%s %s"
 msgstr "%s %s"
 
+#. Translators: this string will appear in Sysprof
+#: src/backends/meta-profiler.c:79
+msgid "Compositor"
+msgstr "Skjásamsetning"
+
 #. This probably means that a non-WM compositor like xcompmgr is running;
 #. * we have no way to get it to exit
-#: src/compositor/compositor.c:463
+#: src/compositor/compositor.c:504
 #, c-format
+#| msgid ""
+#| "Another compositing manager is already running on screen %i on display "
+#| "\"%s\"."
 msgid ""
-"Another compositing manager is already running on screen %i on display \"%s"
-"\"."
+"Another compositing manager is already running on screen %i on display “%s”."
 msgstr ""
-"Annar skjásamsetningarstjóri er þegar í keyrslu í sýndarskjá %i á skjánum "
-"\"%s\"."
+"Annar skjásamsetningarstjóri er þegar í keyrslu í sýndarskjá %i á skjánum \""
+"%s\"."
 
-#: src/core/bell.c:194
+#: src/core/bell.c:192
 msgid "Bell event"
 msgstr "Hljóðatburður"
 
-#: src/core/delete.c:127
+#. Translators: %s is a window title
+#: src/core/meta-close-dialog-default.c:151
 #, c-format
 msgid "“%s” is not responding."
 msgstr "“%s” svarar ekki."
 
-#: src/core/delete.c:129
+#: src/core/meta-close-dialog-default.c:153
 msgid "Application is not responding."
 msgstr "Forritið svarar ekki."
 
-#: src/core/delete.c:134
+#: src/core/meta-close-dialog-default.c:158
 msgid ""
 "You may choose to wait a short while for it to continue or force the "
 "application to quit entirely."
@@ -510,120 +594,150 @@ msgstr ""
 "Þú getur annað hvort hinkrað augnablik og leyft forritinu að halda áfram eða "
 "þú getur þvingað forritið til að slökkva algjörlega á sér."
 
-#: src/core/delete.c:141
+#: src/core/meta-close-dialog-default.c:165
+msgid "_Force Quit"
+msgstr "_Þvinga til að hætta"
+
+#: src/core/meta-close-dialog-default.c:165
 msgid "_Wait"
 msgstr "_Bíða"
 
-#: src/core/delete.c:141
-msgid "_Force Quit"
-msgstr "_Þvinga til að hætta"
+#: src/core/meta-context-main.c:555
+msgid "Replace the running window manager"
+msgstr "Skipta út gluggastjóranum sem er í notkun"
 
-#: src/core/display.c:590
-#, c-format
-msgid "Failed to open X Window System display '%s'\n"
-msgstr "Mistókst að opna X-gluggakerfis-skjá ‚%s‘\n"
+#: src/core/meta-context-main.c:561
+msgid "X Display to use"
+msgstr "X-skjár sem á að nota"
 
-#: src/core/main.c:182
+#: src/core/meta-context-main.c:567
 msgid "Disable connection to session manager"
 msgstr "Slökkva á tengingu við setustjóra"
 
-#: src/core/main.c:188
-#| msgid "Bug in window manager: "
-msgid "Replace the running window manager"
-msgstr "Skipta út gluggastjóranum sem er í notkun"
-
-#: src/core/main.c:194
+#: src/core/meta-context-main.c:573
 msgid "Specify session management ID"
 msgstr "Tilgreindu auðkenni (ID) setustjórnunar"
 
-#: src/core/main.c:199
-msgid "X Display to use"
-msgstr "X-skjár sem á að nota"
-
-#: src/core/main.c:205
+#: src/core/meta-context-main.c:579
 msgid "Initialize session from savefile"
 msgstr "Frumstilla setu frá vistaðri skrá"
 
-#: src/core/main.c:211
+#: src/core/meta-context-main.c:585
 msgid "Make X calls synchronous"
 msgstr "Gera X köllin samhæfð"
 
-#: src/core/main.c:218
+#: src/core/meta-context-main.c:592
 msgid "Run as a wayland compositor"
 msgstr "Keyra sem wayland-skjásamsetningu"
 
-#: src/core/main.c:224
+#: src/core/meta-context-main.c:598
 msgid "Run as a nested compositor"
+msgstr "Keyra sem faldaða (nested) skjásamsetningu"
+
+#: src/core/meta-context-main.c:604
+msgid "Run wayland compositor without starting Xwayland"
+msgstr "Keyra wayland-skjásamsetningu án þess að ræsa Xwayland"
+
+#: src/core/meta-context-main.c:610
+msgid "Specify Wayland display name to use"
 msgstr ""
 
-#: src/core/main.c:232
+#: src/core/meta-context-main.c:618
 msgid "Run as a full display server, rather than nested"
 msgstr ""
 
-#: src/core/mutter.c:39
+#: src/core/meta-context-main.c:623
+msgid "Run as a headless display server"
+msgstr ""
+
+#: src/core/meta-context-main.c:628
+msgid "Add persistent virtual monitor (WxH or WxH@R)"
+msgstr ""
+
+#: src/core/meta-context-main.c:639
+msgid "Run with X11 backend"
+msgstr "Keyra með X11-bakenda"
+
+#. TRANSLATORS: This string refers to a button that switches between
+#. * different modes.
+#.
+#: src/core/meta-pad-action-mapper.c:782
 #, c-format
-#| msgid ""
-#| "metacity %s\n"
-#| "Copyright (C) 2001-2002 Havoc Pennington, Red Hat, Inc., and others\n"
-#| "This is free software; see the source for copying conditions.\n"
-#| "There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A "
-#| "PARTICULAR PURPOSE.\n"
-msgid ""
-"mutter %s\n"
-"Copyright (C) 2001-%d Havoc Pennington, Red Hat, Inc., and others\n"
-"This is free software; see the source for copying conditions.\n"
-"There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A "
-"PARTICULAR PURPOSE.\n"
-msgstr ""
-"mutter %s\n"
-"Höfundarréttur (C) 2001-%d Havoc Pennington, Red Hat, Inc., og fleiri\n"
-"Þetta er frjáls hugbúnaður; skoðaðu grunnkóða til að sjá afritunarskilyrði.\n"
-"Hugbúnaðnum er dreift í þeirri von að hann geti verið gagnlegur, en ÁN "
-"ALLRAR ÁBYRGÐAR; einnig án þeirrar ábyrgðar sem gefin er í skyn með "
-"SELJANLEIKA eða EGINLEIKUM TIL TILTEKINNA NOTA. Sjá almenna GNU GPL "
-"notkunarleyfið fyrir nánari upplýsingar.\n"
-
-#: src/core/mutter.c:53
+#| msgid "Mode Switch: Mode %d"
+msgid "Mode Switch (Group %d)"
+msgstr "Hamskipti (hópur %d)"
+
+#. TRANSLATORS: This string refers to an action, cycles drawing tablets'
+#. * mapping through the available outputs.
+#.
+#: src/core/meta-pad-action-mapper.c:805
+msgid "Switch monitor"
+msgstr "Skipta um skjá"
+
+#: src/core/meta-pad-action-mapper.c:807
+msgid "Show on-screen help"
+msgstr "Birta upplýsingar á skjá"
+
+#: src/core/mutter.c:48
 msgid "Print version"
 msgstr "Prenta útgáfunúmer"
 
-#: src/core/mutter.c:59
+#: src/core/mutter.c:54
 msgid "Mutter plugin to use"
 msgstr ""
 
-#: src/core/prefs.c:1997
+#: src/core/prefs.c:1913
 #, c-format
 msgid "Workspace %d"
 msgstr "Vinnusvæði %d"
 
-#: src/core/screen.c:521
+#: src/core/util.c:149
+#| msgid "Mutter was compiled without support for verbose mode\n"
+msgid "Mutter was compiled without support for verbose mode"
+msgstr "Mutter var vistþýtt án stuðnings við aukinn villuleitarham (verbose)"
+
+#: src/wayland/meta-wayland-tablet-pad.c:519
 #, c-format
+msgid "Mode Switch: Mode %d"
+msgstr "Hamskipti:  %d hamur"
+
+#: src/x11/meta-x11-display.c:673
+#, c-format
+#| msgid ""
+#| "Display \"%s\" already has a window manager; try using the --replace "
+#| "option to replace the current window manager."
 msgid ""
-"Display \"%s\" already has a window manager; try using the --replace option "
-"to replace the current window manager."
+"Display “%s” already has a window manager; try using the --replace option to "
+"replace the current window manager."
 msgstr ""
-"Skjárinn \"%s\" er þegar með gluggastjóra; reyndu að nota --replace rofann "
-"til að skipta út núverandi gluggastjóra."
+"Skjárinn \"%s\" er þegar með gluggastjóra; reyndu að nota --replace rofann"
+" til að skipta út núverandi gluggastjóra."
+
+#: src/x11/meta-x11-display.c:1067
+msgid "Failed to initialize GDK"
+msgstr "Mistókst að frumstilla GDK"
 
-#: src/core/screen.c:606
+#: src/x11/meta-x11-display.c:1091
 #, c-format
-msgid "Screen %d on display '%s' is invalid\n"
-msgstr "Sýndarskjár %d á skjánum '%s‛ er ógildur\n"
+#| msgid "Failed to open X Window System display '%s'\n"
+msgid "Failed to open X Window System display “%s”"
+msgstr "Mistókst að opna X-gluggakerfis-skjá \"%s\""
 
-#: src/core/util.c:120
-#| msgid "Metacity was compiled without support for verbose mode\n"
-msgid "Mutter was compiled without support for verbose mode\n"
-msgstr "Mutter var vistþýtt án stuðnings við aukinn villuleitarham\n"
+#: src/x11/meta-x11-display.c:1181
+#, c-format
+#| msgid "Screen %d on display '%s' is invalid\n"
+msgid "Screen %d on display “%s” is invalid"
+msgstr "Sýndarskjár %d á skjánum '%s‛ er ógildur"
 
-#: src/wayland/meta-wayland-tablet-pad.c:595
+#: src/x11/meta-x11-selection-input-stream.c:460
 #, c-format
-msgid "Mode Switch: Mode %d"
-msgstr "Hamskipti:  %d hamur"
+msgid "Format %s not supported"
+msgstr "Sniðið %s er ekki stutt"
 
-#: src/x11/session.c:1815
+#: src/x11/session.c:1823
 msgid ""
-"These windows do not support &quot;save current setup&quot; and will have to "
-"be restarted manually next time you log in."
+"These windows do not support “save current setup” and will have to be "
+"restarted manually next time you log in."
 msgstr ""
 
 #: src/x11/window-props.c:548
@@ -631,6 +745,34 @@ msgstr ""
 msgid "%s (on %s)"
 msgstr "%s (á %s)"
 
+#~ msgid "Show the activities overview"
+#~ msgstr "Birta virkniyfirlit"
+
+#~ msgid "Toggle shaded state"
+#~ msgstr "Víxla skyggingarstöðu af/á"
+
+#~| msgid ""
+#~| "metacity %s\n"
+#~| "Copyright (C) 2001-2002 Havoc Pennington, Red Hat, Inc., and others\n"
+#~| "This is free software; see the source for copying conditions.\n"
+#~| "There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A "
+#~| "PARTICULAR PURPOSE.\n"
+#~ msgid ""
+#~ "mutter %s\n"
+#~ "Copyright (C) 2001-%d Havoc Pennington, Red Hat, Inc., and others\n"
+#~ "This is free software; see the source for copying conditions.\n"
+#~ "There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A "
+#~ "PARTICULAR PURPOSE.\n"
+#~ msgstr ""
+#~ "mutter %s\n"
+#~ "Höfundarréttur (C) 2001-%d Havoc Pennington, Red Hat, Inc., og fleiri\n"
+#~ "Þetta er frjáls hugbúnaður; skoðaðu grunnkóða til að sjá "
+#~ "afritunarskilyrði.\n"
+#~ "Hugbúnaðnum er dreift í þeirri von að hann geti verið gagnlegur, en ÁN "
+#~ "ALLRAR ÁBYRGÐAR; einnig án þeirrar ábyrgðar sem gefin er í skyn með "
+#~ "SELJANLEIKA eða EGINLEIKUM TIL TILTEKINNA NOTA. Sjá almenna GNU GPL "
+#~ "notkunarleyfið fyrir nánari upplýsingar.\n"
+
 #~ msgid "Usage: %s\n"
 #~ msgstr "Notkun: %s\n"
 
diff --git a/po/it.po b/po/it.po
index 02f27ac52..d7249642a 100644
--- a/po/it.po
+++ b/po/it.po
@@ -12,8 +12,8 @@ msgid ""
 msgstr ""
 "Project-Id-Version: mutter\n"
 "Report-Msgid-Bugs-To: https://gitlab.gnome.org/GNOME/mutter/issues\n"
-"POT-Creation-Date: 2021-11-04 18:01+0000\n"
-"PO-Revision-Date: 2021-11-10 09:20+0100\n"
+"POT-Creation-Date: 2021-11-04 10:29+0000\n"
+"PO-Revision-Date: 2021-11-09 10:35+0100\n"
 "Last-Translator: Milo Casagrande <milo@milo.name>\n"
 "Language-Team: Italian <tp@lists.linux.it>\n"
 "Language: it\n"
@@ -254,11 +254,11 @@ msgstr "Massimizza orizzontalmente la finestra"
 # scorciatoia per mettere la finestra a mezzo schermo intero sulla sinistra
 #
 # traduzione infedele, ma "frazionamento della vista a sn/ds" mi pare peggio
-#: data/50-mutter-windows.xml:41 data/org.gnome.mutter.gschema.xml.in:166
+#: data/50-mutter-windows.xml:41 data/org.gnome.mutter.gschema.xml.in:179
 msgid "View split on left"
 msgstr "Massimizza a sinistra"
 
-#: data/50-mutter-windows.xml:45 data/org.gnome.mutter.gschema.xml.in:171
+#: data/50-mutter-windows.xml:45 data/org.gnome.mutter.gschema.xml.in:184
 msgid "View split on right"
 msgstr "Massimizza a destra"
 
@@ -266,11 +266,11 @@ msgstr "Massimizza a destra"
 msgid "Mutter"
 msgstr "Mutter"
 
-#: data/org.gnome.mutter.gschema.xml.in:7
+#: data/org.gnome.mutter.gschema.xml.in:16
 msgid "Modifier to use for extended window management operations"
 msgstr "Modificatore da utilizzare per le azioni di gestione finestre estese"
 
-#: data/org.gnome.mutter.gschema.xml.in:8
+#: data/org.gnome.mutter.gschema.xml.in:17
 msgid ""
 "This key will initiate the “overlay”, which is a combination window overview "
 "and application launching system. The default is intended to be the “Windows "
@@ -283,11 +283,11 @@ msgstr ""
 "questa scorciatoia sia o il valore predefinito oppure che sia impostata alla "
 "stringa vuota."
 
-#: data/org.gnome.mutter.gschema.xml.in:20
+#: data/org.gnome.mutter.gschema.xml.in:29
 msgid "Attach modal dialogs"
 msgstr "Dialoghi modali attaccati"
 
-#: data/org.gnome.mutter.gschema.xml.in:21
+#: data/org.gnome.mutter.gschema.xml.in:30
 msgid ""
 "When true, instead of having independent titlebars, modal dialogs appear "
 "attached to the titlebar of the parent window and are moved together with "
@@ -297,13 +297,13 @@ msgstr ""
 "dialoghi modali appaiono attaccati alla barra del titolo della finestra "
 "genitore, muovendosi assieme ad essa."
 
-#: data/org.gnome.mutter.gschema.xml.in:30
+#: data/org.gnome.mutter.gschema.xml.in:39
 msgid "Enable edge tiling when dropping windows on screen edges"
 msgstr ""
 "Abilita il tiling di bordo quando si trascinano le finestre sui bordi dello "
 "schermo"
 
-#: data/org.gnome.mutter.gschema.xml.in:31
+#: data/org.gnome.mutter.gschema.xml.in:40
 msgid ""
 "If enabled, dropping windows on vertical screen edges maximizes them "
 "vertically and resizes them horizontally to cover half of the available "
@@ -314,11 +314,11 @@ msgstr ""
 "in modo da coprire metà dell'area disponibile. Trascinandole sul bordo "
 "superiore dello schermo le massimizza completamente."
 
-#: data/org.gnome.mutter.gschema.xml.in:40
+#: data/org.gnome.mutter.gschema.xml.in:49
 msgid "Workspaces are managed dynamically"
 msgstr "Spazi di lavoro gestiti dinamicamente"
 
-#: data/org.gnome.mutter.gschema.xml.in:41
+#: data/org.gnome.mutter.gschema.xml.in:50
 msgid ""
 "Determines whether workspaces are managed dynamically or whether there’s a "
 "static number of workspaces (determined by the num-workspaces key in org."
@@ -328,12 +328,12 @@ msgstr ""
 "loro numero è fisso (determinato dalla chiave num-workspaces in org.gnome."
 "desktop.wm.preferences)."
 
-#: data/org.gnome.mutter.gschema.xml.in:50
+#: data/org.gnome.mutter.gschema.xml.in:59
 msgid "Workspaces only on primary"
 msgstr "Spazi di lavoro solo sul primario"
 
 # mica ho capito cosa fa...
-#: data/org.gnome.mutter.gschema.xml.in:51
+#: data/org.gnome.mutter.gschema.xml.in:60
 msgid ""
 "Determines whether workspace switching should happen for windows on all "
 "monitors or only for windows on the primary monitor."
@@ -342,11 +342,11 @@ msgstr ""
 "tutti i monitor oppure solo per le finestre sul monitor primario."
 
 # mah... sarebbe "popup quando si fa alt-tab", credo
-#: data/org.gnome.mutter.gschema.xml.in:59
+#: data/org.gnome.mutter.gschema.xml.in:68
 msgid "No tab popup"
 msgstr "Nessun tab popup"
 
-#: data/org.gnome.mutter.gschema.xml.in:60
+#: data/org.gnome.mutter.gschema.xml.in:69
 msgid ""
 "Determines whether the use of popup and highlight frame should be disabled "
 "for window cycling."
@@ -354,11 +354,11 @@ msgstr ""
 "Determina se disabilitare l'uso di popup e cornici di evidenziatura nel "
 "passare da una finestra all'altra."
 
-#: data/org.gnome.mutter.gschema.xml.in:68
+#: data/org.gnome.mutter.gschema.xml.in:77
 msgid "Delay focus changes until the pointer stops moving"
 msgstr "Ritarda il cambio del focus fino a quando il puntatore si ferma"
 
-#: data/org.gnome.mutter.gschema.xml.in:69
+#: data/org.gnome.mutter.gschema.xml.in:78
 msgid ""
 "If set to true, and the focus mode is either “sloppy” or “mouse” then the "
 "focus will not be changed immediately when entering a window, but only after "
@@ -368,11 +368,11 @@ msgstr ""
 "\"mouse\", il focus non viene spostato immediatamente quando si passa su una "
 "finestra, ma solo quando il puntatore si ferma."
 
-#: data/org.gnome.mutter.gschema.xml.in:79
+#: data/org.gnome.mutter.gschema.xml.in:88
 msgid "Draggable border width"
 msgstr "Larghezza bordo trascinabile"
 
-#: data/org.gnome.mutter.gschema.xml.in:80
+#: data/org.gnome.mutter.gschema.xml.in:89
 msgid ""
 "The amount of total draggable borders. If the theme’s visible borders are "
 "not enough, invisible borders will be added to meet this value."
@@ -381,11 +381,11 @@ msgstr ""
 "del tema non sono sufficienti, vengono aggiunti dei bordi invisibili per "
 "raggiungere questo valore."
 
-#: data/org.gnome.mutter.gschema.xml.in:89
+#: data/org.gnome.mutter.gschema.xml.in:98
 msgid "Auto maximize nearly monitor sized windows"
 msgstr "Massimizza automaticamente finestre grandi quasi quanto lo schermo"
 
-#: data/org.gnome.mutter.gschema.xml.in:90
+#: data/org.gnome.mutter.gschema.xml.in:99
 msgid ""
 "If enabled, new windows that are initially the size of the monitor "
 "automatically get maximized."
@@ -393,11 +393,11 @@ msgstr ""
 "Se abilitato, le nuove finestre che hanno inizialmente la stessa dimensione "
 "del monitor vengono massimizzate automaticamente."
 
-#: data/org.gnome.mutter.gschema.xml.in:98
+#: data/org.gnome.mutter.gschema.xml.in:107
 msgid "Place new windows in the center"
 msgstr "Posiziona le nuove finestre al centro"
 
-#: data/org.gnome.mutter.gschema.xml.in:99
+#: data/org.gnome.mutter.gschema.xml.in:108
 msgid ""
 "When true, the new windows will always be put in the center of the active "
 "screen of the monitor."
@@ -405,11 +405,11 @@ msgstr ""
 "Se impostata a VERO, le nuove finestre verranno sempre posizionate al centro "
 "dello schermo attivo."
 
-#: data/org.gnome.mutter.gschema.xml.in:107
+#: data/org.gnome.mutter.gschema.xml.in:117
 msgid "Enable experimental features"
 msgstr "Abilita funzionalità sperimentali"
 
-#: data/org.gnome.mutter.gschema.xml.in:108
+#: data/org.gnome.mutter.gschema.xml.in:118
 msgid ""
 "To enable experimental features, add the feature keyword to the list. "
 "Whether the feature requires restarting the compositor depends on the given "
@@ -418,13 +418,15 @@ msgid ""
 "proof. Currently possible keywords: • “scale-monitor-framebuffer” — makes "
 "mutter default to layout logical monitors in a logical pixel coordinate "
 "space, while scaling monitor framebuffers instead of window content, to "
-"manage HiDPI monitors. Does not require a restart. • “rt-scheduler” — makes "
-"mutter request a low priority real-time scheduling. The executable or user "
-"must have CAP_SYS_NICE. Requires a restart. • “dma-buf-screen-sharing\" — "
-"enables DMA buffered screen sharing. This is already enabled by default when "
-"using the i915 driver, but disabled for everything else. Requires a restart. "
-"• “autoclose-xwayland” — automatically terminates Xwayland if all relevant "
-"X11 clients are gone. Does not require a restart."
+"manage HiDPI monitors. Does not require a restart. • “kms-modifiers” — makes "
+"mutter always advertise valid buffer modifiers on Wayland. This is currently "
+"not the case when using the i915 driver. Does not require a restart. • “rt-"
+"scheduler” — makes mutter request a low priority real-time scheduling. "
+"Requires a restart. • “dma-buf-screen-sharing” — enables DMA buffered screen "
+"sharing. This is already enabled by default when using the i915 driver, but "
+"disabled for everything else. Requires a restart. • “autoclose-xwayland” — "
+"automatically terminates Xwayland if all relevant X11 clients are gone. Does "
+"not require a restart."
 msgstr ""
 "Per abilitare le funzionalità sperimentali, aggiungere la parola chiave di "
 "tale funzionalità nella lista. Se la funzionalità desiderata richiede il "
@@ -435,27 +437,29 @@ msgstr ""
 "modo che mutter disponga gli schermi logici secondo uno spazio logico di "
 "coordinate pixel, applicando il ridimensionamento ai framebuffer invece che "
 "al contenuto della finestra, per gestire schermi HiDPI (non richiede il "
-"riavvio). • “rt-scheduler” — Richiede uno scheduling real-time a bassa "
-"priorità. L'eseguibile o l'utente deve avere la proprietà CAP_SYS_NICE "
-"(richiede il riavvio). • “dma-buf-screen-sharing” — Abilita la condivisione "
-"schermo DMA con buffer; già abilitato quando si usa il driver i915, ma "
-"disabilitato per tutto il resto (richiede il riavvio). • “autoclose-"
-"xwayland” — Termina automaticamente Xwayland se non ci sono più client X11 "
-"(non richiede il riavvio)."
-
-#: data/org.gnome.mutter.gschema.xml.in:143
+"riavvio). • \"kms-modifiers\" — Fa in modo che mutter pubblicizzi "
+"modificatori buffer validi su Wayland; ciò non avviene quando si usa il "
+"driver i915 (non richiede il riavvio). • “rt-scheduler” — Richiede uno "
+"scheduling real-time a bassa priorità. L'eseguibile o l'utente deve avere la "
+"proprietà CAP_SYS_NICE (richiede il riavvio). • “dma-buf-screen-sharing” — "
+"Abilita la condivisione schermo DMA con buffer; già abilitato quando si usa "
+"il driver i915, ma disabilitato per tutto il resto (richiede il riavvio). • "
+"“autoclose-xwayland” — Termina automaticamente Xwayland se non ci sono più "
+"client X11 (non richiede il riavvio)."
+
+#: data/org.gnome.mutter.gschema.xml.in:156
 msgid "Modifier to use to locate the pointer"
 msgstr "Modificatore da usare per trovare il puntatore"
 
-#: data/org.gnome.mutter.gschema.xml.in:144
+#: data/org.gnome.mutter.gschema.xml.in:157
 msgid "This key will initiate the “locate pointer” action."
 msgstr "Questa chiave avvia l'azione di localizzazione del puntatore."
 
-#: data/org.gnome.mutter.gschema.xml.in:151
+#: data/org.gnome.mutter.gschema.xml.in:164
 msgid "Timeout for check-alive ping"
 msgstr "Timeout per il ping di controllo"
 
-#: data/org.gnome.mutter.gschema.xml.in:152
+#: data/org.gnome.mutter.gschema.xml.in:165
 msgid ""
 "Number of milliseconds a client has to respond to a ping request in order to "
 "not be detected as frozen. Using 0 will disable the alive check completely."
@@ -464,19 +468,19 @@ msgstr ""
 "di ping per non essere rilevato come bloccato. Utilizzando 0 si disattiva "
 "completamente il controllo."
 
-#: data/org.gnome.mutter.gschema.xml.in:176
+#: data/org.gnome.mutter.gschema.xml.in:189
 msgid "Select window from tab popup"
 msgstr "Seleziona finestra dal tab popup"
 
-#: data/org.gnome.mutter.gschema.xml.in:181
+#: data/org.gnome.mutter.gschema.xml.in:194
 msgid "Cancel tab popup"
 msgstr "Annulla tab popup"
 
-#: data/org.gnome.mutter.gschema.xml.in:186
+#: data/org.gnome.mutter.gschema.xml.in:199
 msgid "Switch monitor configurations"
 msgstr "Cambia le configurazioni del monitor"
 
-#: data/org.gnome.mutter.gschema.xml.in:191
+#: data/org.gnome.mutter.gschema.xml.in:204
 msgid "Rotates the built-in monitor configuration"
 msgstr "Passa da una configurazione integrata all'altra del monitor"
 
@@ -639,26 +643,9 @@ msgstr "%s %s"
 msgid "Compositor"
 msgstr "Compositor"
 
-#: src/backends/x11/meta-clutter-backend-x11.c:237
-msgid "X display to use"
-msgstr "Display X da usare"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:243
-msgid "X screen to use"
-msgstr "Schermo X da usare"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:248
-#: src/core/meta-context-main.c:585
-msgid "Make X calls synchronous"
-msgstr "Rende le chiamate X sincrone"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:254
-msgid "Disable XInput support"
-msgstr "Disabilita supporto XInput"
-
 #. This probably means that a non-WM compositor like xcompmgr is running;
 #. * we have no way to get it to exit
-#: src/compositor/compositor.c:513
+#: src/compositor/compositor.c:504
 #, c-format
 msgid ""
 "Another compositing manager is already running on screen %i on display “%s”."
@@ -716,6 +703,10 @@ msgstr "Specifica l'ID di gestione sessione"
 msgid "Initialize session from savefile"
 msgstr "Inizializza la sessione da file salvato"
 
+#: src/core/meta-context-main.c:585
+msgid "Make X calls synchronous"
+msgstr "Rende le chiamate X sincrone"
+
 #: src/core/meta-context-main.c:592
 msgid "Run as a wayland compositor"
 msgstr "Esegui come compositor Wayland"
@@ -767,11 +758,11 @@ msgstr "Cambia monitor"
 msgid "Show on-screen help"
 msgstr "Mostra aiuto sullo schermo"
 
-#: src/core/mutter.c:48
+#: src/core/mutter.c:74
 msgid "Print version"
 msgstr "Stampa la versione"
 
-#: src/core/mutter.c:54
+#: src/core/mutter.c:80
 msgid "Mutter plugin to use"
 msgstr "Plugin Mutter da usare"
 
@@ -780,7 +771,7 @@ msgstr "Plugin Mutter da usare"
 msgid "Workspace %d"
 msgstr "Spazio di lavoro %d"
 
-#: src/core/util.c:148
+#: src/core/util.c:149
 msgid "Mutter was compiled without support for verbose mode"
 msgstr ""
 "Mutter è stato compilato escludendo il supporto per la modalità prolissa"
@@ -808,7 +799,7 @@ msgstr "Inizializzazione GDK non riuscita"
 msgid "Failed to open X Window System display “%s”"
 msgstr "Apertura del display «%s» di X Window System non riuscita"
 
-#: src/x11/meta-x11-display.c:1175
+#: src/x11/meta-x11-display.c:1181
 #, c-format
 msgid "Screen %d on display “%s” is invalid"
 msgstr "Lo schermo %d sul display «%s» non è valido"
@@ -818,7 +809,7 @@ msgstr "Lo schermo %d sul display «%s» non è valido"
 msgid "Format %s not supported"
 msgstr "Formato %s non supportato"
 
-#: src/x11/session.c:1845
+#: src/x11/session.c:1823
 msgid ""
 "These windows do not support “save current setup” and will have to be "
 "restarted manually next time you log in."
diff --git a/po/ja.po b/po/ja.po
index 7281bc43b..fab3a8a0e 100644
--- a/po/ja.po
+++ b/po/ja.po
@@ -1,5 +1,5 @@
 # mutter ja.po.
-# Copyright (C) 2002-2020, 2022 Free Software Foundation, Inc.
+# Copyright (C) 2002-2020 Free Software Foundation, Inc.
 # Akira TAGOH <tagoh@gnome.gr.jp>, 2002.
 # KAMAGASAKO Masatoshi <emerald@gnome.gr.jp>, 2003.
 # Yukihiro Nakai <nakai@gnome.gr.jp>, 2003.
@@ -8,15 +8,15 @@
 # Noriko Mizumoto <noriko@fedoraproject.org>, 2012.
 # Jiro Matsuzawa <jmatsuzawa@gnome.org>, 2012, 2013.
 # sujiniku <sujinikusityuu@gmail.com>, 2016.
-# sicklylife <translation@sicklylife.jp>, 2019-2020, 2022.
+# sicklylife <translation@sicklylife.jp>, 2019-2020.
 # Masanori Kamayama <>, 2020.
 #
 msgid ""
 msgstr ""
 "Project-Id-Version: mutter master\n"
 "Report-Msgid-Bugs-To: https://gitlab.gnome.org/GNOME/mutter/issues\n"
-"POT-Creation-Date: 2021-10-14 16:28+0000\n"
-"PO-Revision-Date: 2022-01-30 21:00+0900\n"
+"POT-Creation-Date: 2020-02-23 17:41+0000\n"
+"PO-Revision-Date: 2020-03-01 00:25+0900\n"
 "Last-Translator: sicklylife <translation@sicklylife.jp>\n"
 "Language-Team: Japanese <gnome-translation@gnome.gr.jp>\n"
 "Language: ja\n"
@@ -50,132 +50,116 @@ msgid "Move window to last workspace"
 msgstr "ウィンドウを最後のワークスペースへ移動する"
 
 #: data/50-mutter-navigation.xml:24
-msgid "Move window one workspace to the left"
-msgstr "ウィンドウを左側のワークスペースへ移動する"
-
-#: data/50-mutter-navigation.xml:27
-msgid "Move window one workspace to the right"
-msgstr "ウィンドウを右側のワークスペースへ移動する"
-
-#: data/50-mutter-navigation.xml:31
 msgid "Move window one workspace up"
 msgstr "ウィンドウを上側のワークスペースへ移動する"
 
-#: data/50-mutter-navigation.xml:35
+#: data/50-mutter-navigation.xml:27
 msgid "Move window one workspace down"
 msgstr "ウィンドウを下側のワークスペースへ移動する"
 
-#: data/50-mutter-navigation.xml:38
+#: data/50-mutter-navigation.xml:30
 msgid "Move window one monitor to the left"
 msgstr "ウィンドウを左側のモニターへ移動する"
 
-#: data/50-mutter-navigation.xml:41
+#: data/50-mutter-navigation.xml:33
 msgid "Move window one monitor to the right"
 msgstr "ウィンドウを右側のモニターへ移動する"
 
-#: data/50-mutter-navigation.xml:44
+#: data/50-mutter-navigation.xml:36
 msgid "Move window one monitor up"
 msgstr "ウィンドウを上側のモニターへ移動する"
 
-#: data/50-mutter-navigation.xml:47
+#: data/50-mutter-navigation.xml:39
 msgid "Move window one monitor down"
 msgstr "ウィンドウを下側のモニターへ移動する"
 
-#: data/50-mutter-navigation.xml:51
+#: data/50-mutter-navigation.xml:43
 msgid "Switch applications"
 msgstr "アプリケーションを切り替える"
 
-#: data/50-mutter-navigation.xml:56
+#: data/50-mutter-navigation.xml:48
 msgid "Switch to previous application"
 msgstr "前のアプリケーションに切り替える"
 
-#: data/50-mutter-navigation.xml:60
+#: data/50-mutter-navigation.xml:52
 msgid "Switch windows"
 msgstr "ウィンドウを切り替える"
 
-#: data/50-mutter-navigation.xml:65
+#: data/50-mutter-navigation.xml:57
 msgid "Switch to previous window"
 msgstr "前のウィンドウに切り替える"
 
-#: data/50-mutter-navigation.xml:69
+#: data/50-mutter-navigation.xml:61
 msgid "Switch windows of an application"
 msgstr "一つのアプリケーション内のウィンドウを切り替える"
 
-#: data/50-mutter-navigation.xml:74
+#: data/50-mutter-navigation.xml:66
 msgid "Switch to previous window of an application"
 msgstr "一つのアプリケーション内の前のウィンドウに切り替える"
 
-#: data/50-mutter-navigation.xml:78
+#: data/50-mutter-navigation.xml:70
 msgid "Switch system controls"
 msgstr "システムコントロールを切り替える"
 
-#: data/50-mutter-navigation.xml:83
+#: data/50-mutter-navigation.xml:75
 msgid "Switch to previous system control"
 msgstr "前のシステムコントロールに切り替える"
 
-#: data/50-mutter-navigation.xml:87
+#: data/50-mutter-navigation.xml:79
 msgid "Switch windows directly"
 msgstr "ウィンドウを直接切り替える"
 
-#: data/50-mutter-navigation.xml:92
+#: data/50-mutter-navigation.xml:84
 msgid "Switch directly to previous window"
 msgstr "前のウィンドウに直接切り替える"
 
-#: data/50-mutter-navigation.xml:96
+#: data/50-mutter-navigation.xml:88
 msgid "Switch windows of an app directly"
 msgstr "一つのアプリケーション内のウィンドウを直接切り替える"
 
-#: data/50-mutter-navigation.xml:101
+#: data/50-mutter-navigation.xml:93
 msgid "Switch directly to previous window of an app"
 msgstr "一つのアプリケーション内の前のウィンドウに直接切り替える"
 
-#: data/50-mutter-navigation.xml:105
+#: data/50-mutter-navigation.xml:97
 msgid "Switch system controls directly"
 msgstr "システムコントロールを直接切り替える"
 
-#: data/50-mutter-navigation.xml:110
+#: data/50-mutter-navigation.xml:102
 msgid "Switch directly to previous system control"
 msgstr "前のシステムコントロールに直接切り替える"
 
-#: data/50-mutter-navigation.xml:113
+#: data/50-mutter-navigation.xml:105
 msgid "Hide all normal windows"
 msgstr "すべての通常のウィンドウを隠す"
 
 # ｢キーボードショートカット｣のアプレット (gnome-control-center) で表示するメッセージ
-#: data/50-mutter-navigation.xml:116
+#: data/50-mutter-navigation.xml:108
 msgid "Switch to workspace 1"
 msgstr "ワークスペース 1 へ切り替える"
 
-#: data/50-mutter-navigation.xml:119
+#: data/50-mutter-navigation.xml:111
 msgid "Switch to workspace 2"
 msgstr "ワークスペース 2 へ切り替える"
 
-#: data/50-mutter-navigation.xml:122
+#: data/50-mutter-navigation.xml:114
 msgid "Switch to workspace 3"
 msgstr "ワークスペース 3 へ切り替える"
 
-#: data/50-mutter-navigation.xml:125
+#: data/50-mutter-navigation.xml:117
 msgid "Switch to workspace 4"
 msgstr "ワークスペース 4 へ切り替える"
 
 # ｢キーボードショートカット｣のアプレット (gnome-control-center) で表示するメッセージ
-#: data/50-mutter-navigation.xml:128
+#: data/50-mutter-navigation.xml:120
 msgid "Switch to last workspace"
 msgstr "最後のワークスペースへ切り替える"
 
-#: data/50-mutter-navigation.xml:131
-msgid "Move to workspace on the left"
-msgstr "左側のワークスペースへ移動する"
-
-#: data/50-mutter-navigation.xml:134
-msgid "Move to workspace on the right"
-msgstr "右側のワークスペースへ移動する"
-
-#: data/50-mutter-navigation.xml:138
+#: data/50-mutter-navigation.xml:123
 msgid "Move to workspace above"
 msgstr "上側のワークスペースへ移動する"
 
-#: data/50-mutter-navigation.xml:142
+#: data/50-mutter-navigation.xml:126
 msgid "Move to workspace below"
 msgstr "下側のワークスペースへ移動する"
 
@@ -187,6 +171,10 @@ msgstr "システム"
 msgid "Show the run command prompt"
 msgstr "コマンド実行プロンプトを表示する"
 
+#: data/50-mutter-system.xml:10
+msgid "Show the activities overview"
+msgstr "アクティビティ画面を表示する"
+
 #: data/50-mutter-wayland.xml:8
 msgid "Restore the keyboard shortcuts"
 msgstr "キーボードショートカットを復元する"
@@ -255,11 +243,11 @@ msgstr "ウィンドウを垂直方向に最大化する"
 msgid "Maximize window horizontally"
 msgstr "ウィンドウを水平方向に最大化する"
 
-#: data/50-mutter-windows.xml:41 data/org.gnome.mutter.gschema.xml.in:166
+#: data/50-mutter-windows.xml:41
 msgid "View split on left"
 msgstr "画面左半分に表示する"
 
-#: data/50-mutter-windows.xml:45 data/org.gnome.mutter.gschema.xml.in:171
+#: data/50-mutter-windows.xml:45
 msgid "View split on right"
 msgstr "画面右半分に表示する"
 
@@ -400,104 +388,101 @@ msgid ""
 "space, while scaling monitor framebuffers instead of window content, to "
 "manage HiDPI monitors. Does not require a restart. • “rt-scheduler” — makes "
 "mutter request a low priority real-time scheduling. The executable or user "
-"must have CAP_SYS_NICE. Requires a restart. • “dma-buf-screen-sharing\" — "
-"enables DMA buffered screen sharing. This is already enabled by default when "
-"using the i915 driver, but disabled for everything else. Requires a restart. "
-"• “autoclose-xwayland” — automatically terminates Xwayland if all relevant "
-"X11 clients are gone. Does not require a restart."
+"must have CAP_SYS_NICE. Requires a restart. • “autostart-xwayland” — "
+"initializes Xwayland lazily if there are X11 clients. Requires restart."
 msgstr ""
 
-#: data/org.gnome.mutter.gschema.xml.in:143
+#: data/org.gnome.mutter.gschema.xml.in:134
 msgid "Modifier to use to locate the pointer"
 msgstr ""
 
-#: data/org.gnome.mutter.gschema.xml.in:144
+#: data/org.gnome.mutter.gschema.xml.in:135
 msgid "This key will initiate the “locate pointer” action."
 msgstr ""
 
-#: data/org.gnome.mutter.gschema.xml.in:151
+#: data/org.gnome.mutter.gschema.xml.in:142
 msgid "Timeout for check-alive ping"
 msgstr ""
 
-#: data/org.gnome.mutter.gschema.xml.in:152
+#: data/org.gnome.mutter.gschema.xml.in:143
 msgid ""
 "Number of milliseconds a client has to respond to a ping request in order to "
 "not be detected as frozen. Using 0 will disable the alive check completely."
 msgstr ""
 
-#: data/org.gnome.mutter.gschema.xml.in:176
+#: data/org.gnome.mutter.gschema.xml.in:165
 msgid "Select window from tab popup"
 msgstr "タブのポップアップでウィンドウを選択します"
 
-#: data/org.gnome.mutter.gschema.xml.in:181
+#: data/org.gnome.mutter.gschema.xml.in:170
 msgid "Cancel tab popup"
 msgstr ""
 
-#: data/org.gnome.mutter.gschema.xml.in:186
+#: data/org.gnome.mutter.gschema.xml.in:175
 msgid "Switch monitor configurations"
 msgstr ""
 
-#: data/org.gnome.mutter.gschema.xml.in:191
+#: data/org.gnome.mutter.gschema.xml.in:180
 msgid "Rotates the built-in monitor configuration"
 msgstr ""
 
-#: data/org.gnome.mutter.wayland.gschema.xml.in:12
+#: data/org.gnome.mutter.wayland.gschema.xml.in:6
 msgid "Switch to VT 1"
 msgstr "VT 1 へ切り替える"
 
-#: data/org.gnome.mutter.wayland.gschema.xml.in:16
+#: data/org.gnome.mutter.wayland.gschema.xml.in:10
 msgid "Switch to VT 2"
 msgstr "VT 2 へ切り替える"
 
-#: data/org.gnome.mutter.wayland.gschema.xml.in:20
+#: data/org.gnome.mutter.wayland.gschema.xml.in:14
 msgid "Switch to VT 3"
 msgstr "VT 3 へ切り替える"
 
-#: data/org.gnome.mutter.wayland.gschema.xml.in:24
+#: data/org.gnome.mutter.wayland.gschema.xml.in:18
 msgid "Switch to VT 4"
 msgstr "VT 4 へ切り替える"
 
-#: data/org.gnome.mutter.wayland.gschema.xml.in:28
+#: data/org.gnome.mutter.wayland.gschema.xml.in:22
 msgid "Switch to VT 5"
 msgstr "VT 5 へ切り替える"
 
-#: data/org.gnome.mutter.wayland.gschema.xml.in:32
+#: data/org.gnome.mutter.wayland.gschema.xml.in:26
 msgid "Switch to VT 6"
 msgstr "VT 6 へ切り替える"
 
-#: data/org.gnome.mutter.wayland.gschema.xml.in:36
+#: data/org.gnome.mutter.wayland.gschema.xml.in:30
 msgid "Switch to VT 7"
 msgstr "VT 7 へ切り替える"
 
-#: data/org.gnome.mutter.wayland.gschema.xml.in:40
+#: data/org.gnome.mutter.wayland.gschema.xml.in:34
 msgid "Switch to VT 8"
 msgstr "VT 8 へ切り替える"
 
-#: data/org.gnome.mutter.wayland.gschema.xml.in:44
+#: data/org.gnome.mutter.wayland.gschema.xml.in:38
 msgid "Switch to VT 9"
 msgstr "VT 9 へ切り替える"
 
-#: data/org.gnome.mutter.wayland.gschema.xml.in:48
+#: data/org.gnome.mutter.wayland.gschema.xml.in:42
 msgid "Switch to VT 10"
 msgstr "VT 10 へ切り替える"
 
-#: data/org.gnome.mutter.wayland.gschema.xml.in:52
+#: data/org.gnome.mutter.wayland.gschema.xml.in:46
 msgid "Switch to VT 11"
 msgstr "VT 11 へ切り替える"
 
-#: data/org.gnome.mutter.wayland.gschema.xml.in:56
+#: data/org.gnome.mutter.wayland.gschema.xml.in:50
 msgid "Switch to VT 12"
 msgstr "VT 12 へ切り替える"
 
-#: data/org.gnome.mutter.wayland.gschema.xml.in:60
+#: data/org.gnome.mutter.wayland.gschema.xml.in:54
 msgid "Re-enable shortcuts"
 msgstr ""
 
-#: data/org.gnome.mutter.wayland.gschema.xml.in:70
+#: data/org.gnome.mutter.wayland.gschema.xml.in:64
 msgid "Allow X11 grabs to lock keyboard focus with Xwayland"
 msgstr ""
 
-#: data/org.gnome.mutter.wayland.gschema.xml.in:71
+#: data/org.gnome.mutter.wayland.gschema.xml.in:65
 msgid ""
 "Allow all keyboard events to be routed to X11 “override redirect” windows "
 "with a grab when running in Xwayland. This option is to support X11 clients "
@@ -507,59 +492,66 @@ msgid ""
 "which can receive keyboard focus under normal circumstances. For a X11 grab "
 "to be taken into account under Wayland, the client must also either send a "
 "specific X11 ClientMessage to the root window or be among the applications "
-"allowed in key “xwayland-grab-access-rules”."
+"white-listed in key “xwayland-grab-access-rules”."
 msgstr ""
 
-#: data/org.gnome.mutter.wayland.gschema.xml.in:90
+#: data/org.gnome.mutter.wayland.gschema.xml.in:84
 msgid "Xwayland applications allowed to issue keyboard grabs"
 msgstr ""
 
-#: data/org.gnome.mutter.wayland.gschema.xml.in:91
+#: data/org.gnome.mutter.wayland.gschema.xml.in:85
 msgid ""
 "List the resource names or resource class of X11 windows either allowed or "
 "not allowed to issue X11 keyboard grabs under Xwayland. The resource name or "
 "resource class of a given X11 window can be obtained using the command "
 "“xprop WM_CLASS”. Wildcards “*” and jokers “?” in the values are supported. "
-"Values starting with “!” are denied, which has precedence over the list of "
-"values allowed, to revoke applications from the default system list. The "
-"default system list includes the following applications: "
+"Values starting with “!” are blacklisted, which has precedence over the "
+"whitelist, to revoke applications from the default system list. The default "
+"system list includes the following applications: "
 "“@XWAYLAND_GRAB_DEFAULT_ACCESS_RULES@” Users can break an existing grab by "
 "using the specific keyboard shortcut defined by the keybinding key “restore-"
 "shortcuts”."
 msgstr ""
 
-#: data/org.gnome.mutter.wayland.gschema.xml.in:116
-msgid "Disable selected X extensions in Xwayland"
-msgstr ""
+#. TRANSLATORS: This string refers to a button that switches between
+#. * different modes.
+#.
+#: src/backends/meta-input-settings.c:2567
+#, c-format
+msgid "Mode Switch (Group %d)"
+msgstr "モードを切り替え (グループ %d)"
 
-#: data/org.gnome.mutter.wayland.gschema.xml.in:117
-msgid ""
-"This option disables the selected X extensions in Xwayland if Xwayland was "
-"built with support for those X extensions. This option has no effect if "
-"Xwayland was built without support for the selected extensions. Xwayland "
-"needs to be restarted for this setting to take effect."
-msgstr ""
+#. TRANSLATORS: This string refers to an action, cycles drawing tablets'
+#. * mapping through the available outputs.
+#.
+#: src/backends/meta-input-settings.c:2590
+msgid "Switch monitor"
+msgstr "モニターを切り替え"
+
+#: src/backends/meta-input-settings.c:2592
+msgid "Show on-screen help"
+msgstr "オンスクリーンヘルプを表示"
 
-#: src/backends/meta-monitor.c:246
+#: src/backends/meta-monitor.c:223
 msgid "Built-in display"
 msgstr "ビルトインディスプレイ"
 
-#: src/backends/meta-monitor.c:275
+#: src/backends/meta-monitor.c:252
 msgid "Unknown"
 msgstr "不明"
 
-#: src/backends/meta-monitor.c:277
+#: src/backends/meta-monitor.c:254
 msgid "Unknown Display"
 msgstr "不明なディスプレイ"
 
-#: src/backends/meta-monitor.c:285
+#: src/backends/meta-monitor.c:262
 #, c-format
 msgctxt ""
 "This is a monitor vendor name, followed by a size in inches, like 'Dell 15\"'"
 msgid "%s %s"
 msgstr "%s %s"
 
-#: src/backends/meta-monitor.c:293
+#: src/backends/meta-monitor.c:270
 #, c-format
 msgctxt ""
 "This is a monitor vendor name followed by product/model name where size in "
@@ -572,31 +564,9 @@ msgstr "%s %s"
 msgid "Compositor"
 msgstr ""
 
-#: src/backends/x11/meta-clutter-backend-x11.c:237
-#, fuzzy
-#| msgid "X Display to use"
-msgid "X display to use"
-msgstr "使用する X ディスプレイを指定する"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:243
-#, fuzzy
-#| msgid "X Display to use"
-msgid "X screen to use"
-msgstr "使用する X ディスプレイを指定する"
-
-# 'X' という１文字は固有名詞のため大文字にする
-#: src/backends/x11/meta-clutter-backend-x11.c:248
-#: src/core/meta-context-main.c:585
-msgid "Make X calls synchronous"
-msgstr "X の呼び出しを同期する"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:254
-msgid "Disable XInput support"
-msgstr ""
-
 #. This probably means that a non-WM compositor like xcompmgr is running;
 #. * we have no way to get it to exit
-#: src/compositor/compositor.c:513
+#: src/compositor/compositor.c:533
 #, c-format
 msgid ""
 "Another compositing manager is already running on screen %i on display “%s”."
@@ -608,126 +578,115 @@ msgstr ""
 msgid "Bell event"
 msgstr "ベルイベント"
 
-#. Translators: %s is a window title
-#: src/core/meta-close-dialog-default.c:151
-#, c-format
-msgid "“%s” is not responding."
-msgstr "“%s”から応答がありません"
-
-#: src/core/meta-close-dialog-default.c:153
-msgid "Application is not responding."
-msgstr "アプリケーションから応答がありません"
-
-#: src/core/meta-close-dialog-default.c:158
-msgid ""
-"You may choose to wait a short while for it to continue or force the "
-"application to quit entirely."
-msgstr ""
-"応答があるまで少し待つか、または強制的にアプリケーションを終了するか選択して"
-"ください。"
-
-#: src/core/meta-close-dialog-default.c:165
-msgid "_Force Quit"
-msgstr "強制終了する(_F)"
-
-#: src/core/meta-close-dialog-default.c:165
-msgid "_Wait"
-msgstr "待機する(_W)"
+#: src/core/main.c:190
+msgid "Disable connection to session manager"
+msgstr "セッションマネージャーに接続しない"
 
-#: src/core/meta-context-main.c:555
+#: src/core/main.c:196
 msgid "Replace the running window manager"
 msgstr "実行中のウィンドウマネージャーを置き換える"
 
-#: src/core/meta-context-main.c:561
-msgid "X Display to use"
-msgstr "使用する X ディスプレイを指定する"
-
-#: src/core/meta-context-main.c:567
-msgid "Disable connection to session manager"
-msgstr "セッションマネージャーに接続しない"
-
-#: src/core/meta-context-main.c:573
+#: src/core/main.c:202
 msgid "Specify session management ID"
 msgstr "セッション管理 ID を指定する"
 
-#: src/core/meta-context-main.c:579
+#: src/core/main.c:207
+msgid "X Display to use"
+msgstr "使用する X ディスプレイを指定する"
+
+#: src/core/main.c:213
 msgid "Initialize session from savefile"
 msgstr "保存ファイルからセッションを初期化する"
 
-#: src/core/meta-context-main.c:592
+# 'X' という１文字は固有名詞のため大文字にする
+#: src/core/main.c:219
+msgid "Make X calls synchronous"
+msgstr "X の呼び出しを同期する"
+
+#: src/core/main.c:226
 msgid "Run as a wayland compositor"
 msgstr "Wayland のコンポジターとして実行する"
 
-#: src/core/meta-context-main.c:598
+#: src/core/main.c:232
 msgid "Run as a nested compositor"
 msgstr ""
 
-#: src/core/meta-context-main.c:604
+#: src/core/main.c:238
 msgid "Run wayland compositor without starting Xwayland"
 msgstr ""
 
-#: src/core/meta-context-main.c:610
-msgid "Specify Wayland display name to use"
-msgstr ""
-
-#: src/core/meta-context-main.c:618
+#: src/core/main.c:246
 msgid "Run as a full display server, rather than nested"
 msgstr ""
 
-#: src/core/meta-context-main.c:623
-msgid "Run as a headless display server"
+#: src/core/main.c:252
+msgid "Run with X11 backend"
 msgstr ""
 
-#: src/core/meta-context-main.c:628
-msgid "Add persistent virtual monitor (WxH or WxH@R)"
-msgstr ""
+#. Translators: %s is a window title
+#: src/core/meta-close-dialog-default.c:151
+#, c-format
+msgid "“%s” is not responding."
+msgstr "“%s”から応答がありません"
 
-#: src/core/meta-context-main.c:639
-msgid "Run with X11 backend"
+#: src/core/meta-close-dialog-default.c:153
+msgid "Application is not responding."
+msgstr "アプリケーションから応答がありません"
+
+#: src/core/meta-close-dialog-default.c:158
+msgid ""
+"You may choose to wait a short while for it to continue or force the "
+"application to quit entirely."
 msgstr ""
+"応答があるまで少し待つか、または強制的にアプリケーションを終了するか選択して"
+"ください。"
 
-#. TRANSLATORS: This string refers to a button that switches between
-#. * different modes.
-#.
-#: src/core/meta-pad-action-mapper.c:782
-#, c-format
-msgid "Mode Switch (Group %d)"
-msgstr "モードを切り替え (グループ %d)"
+#: src/core/meta-close-dialog-default.c:165
+msgid "_Force Quit"
+msgstr "強制終了する(_F)"
 
-#. TRANSLATORS: This string refers to an action, cycles drawing tablets'
-#. * mapping through the available outputs.
-#.
-#: src/core/meta-pad-action-mapper.c:805
-msgid "Switch monitor"
-msgstr "モニターを切り替え"
+#: src/core/meta-close-dialog-default.c:165
+msgid "_Wait"
+msgstr "待機する(_W)"
 
-#: src/core/meta-pad-action-mapper.c:807
-msgid "Show on-screen help"
-msgstr "オンスクリーンヘルプを表示"
+#: src/core/mutter.c:38
+#, c-format
+msgid ""
+"mutter %s\n"
+"Copyright © 2001-%d Havoc Pennington, Red Hat, Inc., and others\n"
+"This is free software; see the source for copying conditions.\n"
+"There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A "
+"PARTICULAR PURPOSE.\n"
+msgstr ""
+"mutter %s\n"
+"Copyright © 2001-%d Havoc Pennington, Red Hat, Inc., and others\n"
+"This is free software; see the source for copying conditions.\n"
+"There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A "
+"PARTICULAR PURPOSE.\n"
 
-#: src/core/mutter.c:48
+#: src/core/mutter.c:52
 msgid "Print version"
 msgstr "バージョンを表示する"
 
-#: src/core/mutter.c:54
+#: src/core/mutter.c:58
 msgid "Mutter plugin to use"
 msgstr "使用する Mutter のプラグイン"
 
-#: src/core/prefs.c:1913
+#: src/core/prefs.c:1911
 #, c-format
 msgid "Workspace %d"
 msgstr "ワークスペース %d"
 
-#: src/core/util.c:148
-msgid "Mutter was compiled without support for verbose mode"
-msgstr "この Mutter は詳細ログモードをサポートしていません"
+#: src/core/util.c:122
+msgid "Mutter was compiled without support for verbose mode\n"
+msgstr "この mutter は詳細ログモードをサポートしていません\n"
 
-#: src/wayland/meta-wayland-tablet-pad.c:519
+#: src/wayland/meta-wayland-tablet-pad.c:568
 #, c-format
 msgid "Mode Switch: Mode %d"
 msgstr "モード切り替え: モード %d"
 
-#: src/x11/meta-x11-display.c:673
+#: src/x11/meta-x11-display.c:676
 #, c-format
 msgid ""
 "Display “%s” already has a window manager; try using the --replace option to "
@@ -736,26 +695,26 @@ msgstr ""
 "ディスプレイ“%s”はすでにウィンドウマネージャーを持っています。現在のウィンド"
 "ウマネージャーを上書きするために --replace オプションの使用を試してください。"
 
-#: src/x11/meta-x11-display.c:1067
-msgid "Failed to initialize GDK"
-msgstr "GDK の初期化に失敗しました"
+#: src/x11/meta-x11-display.c:1089
+msgid "Failed to initialize GDK\n"
+msgstr "GDK の初期化に失敗しました\n"
 
-#: src/x11/meta-x11-display.c:1091
+#: src/x11/meta-x11-display.c:1113
 #, c-format
-msgid "Failed to open X Window System display “%s”"
-msgstr "X Window System のディスプレイ“%s”のオープンに失敗しました"
+msgid "Failed to open X Window System display “%s”\n"
+msgstr "X Window System のディスプレイ“%s”のオープンに失敗しました\n"
 
-#: src/x11/meta-x11-display.c:1175
+#: src/x11/meta-x11-display.c:1196
 #, c-format
-msgid "Screen %d on display “%s” is invalid"
-msgstr "ディスプレイ“%2$s”上のスクリーン %1$d は無効です"
+msgid "Screen %d on display “%s” is invalid\n"
+msgstr "ディスプレイ“%2$s”上のスクリーン %1$d は無効です\n"
 
 #: src/x11/meta-x11-selection-input-stream.c:460
 #, c-format
 msgid "Format %s not supported"
 msgstr "フォーマット %s はサポートしていません"
 
-#: src/x11/session.c:1845
+#: src/x11/session.c:1821
 msgid ""
 "These windows do not support “save current setup” and will have to be "
 "restarted manually next time you log in."
@@ -763,26 +722,22 @@ msgstr ""
 "これらのウィンドウは“現在の設定を保存する”機能をサポートしません。次回ログイ"
 "ンする時に手動で再起動してください。"
 
-#: src/x11/window-props.c:548
+#: src/x11/window-props.c:569
 #, c-format
 msgid "%s (on %s)"
 msgstr "%s (%s)"
 
-#~ msgid "Show the activities overview"
-#~ msgstr "アクティビティ画面を表示する"
+#~ msgid "Move window one workspace to the left"
+#~ msgstr "ウィンドウを左側のワークスペースへ移動する"
 
-#~ msgid ""
-#~ "mutter %s\n"
-#~ "Copyright © 2001-%d Havoc Pennington, Red Hat, Inc., and others\n"
-#~ "This is free software; see the source for copying conditions.\n"
-#~ "There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A "
-#~ "PARTICULAR PURPOSE.\n"
-#~ msgstr ""
-#~ "mutter %s\n"
-#~ "Copyright © 2001-%d Havoc Pennington, Red Hat, Inc., and others\n"
-#~ "This is free software; see the source for copying conditions.\n"
-#~ "There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A "
-#~ "PARTICULAR PURPOSE.\n"
+#~ msgid "Move window one workspace to the right"
+#~ msgstr "ウィンドウを右側のワークスペースへ移動する"
+
+#~ msgid "Move to workspace left"
+#~ msgstr "左側のワークスペースへ移動する"
+
+#~ msgid "Move to workspace right"
+#~ msgstr "右側のワークスペースへ移動する"
 
 #~ msgid "Toggle shaded state"
 #~ msgstr "シェードの状態を切り替える"
diff --git a/po/lt.po b/po/lt.po
index 94f496301..1147ffd11 100644
--- a/po/lt.po
+++ b/po/lt.po
@@ -12,8 +12,8 @@ msgid ""
 msgstr ""
 "Project-Id-Version: lt\n"
 "Report-Msgid-Bugs-To: https://gitlab.gnome.org/GNOME/mutter/issues\n"
-"POT-Creation-Date: 2021-08-30 22:01+0000\n"
-"PO-Revision-Date: 2021-09-02 15:58+0300\n"
+"POT-Creation-Date: 2021-12-13 10:24+0000\n"
+"PO-Revision-Date: 2021-12-14 13:55+0200\n"
 "Last-Translator: Aurimas Černius <aurisc4@gmail.com>\n"
 "Language-Team: Lietuvių <gnome-lt@lists.akl.lt>\n"
 "Language: lt\n"
@@ -253,11 +253,11 @@ msgstr "Išdidinti langą vertikaliai"
 msgid "Maximize window horizontally"
 msgstr "Išdidinti langą horizontaliai"
 
-#: data/50-mutter-windows.xml:41 data/org.gnome.mutter.gschema.xml.in:166
+#: data/50-mutter-windows.xml:41 data/org.gnome.mutter.gschema.xml.in:179
 msgid "View split on left"
 msgstr "Rodyti skyrimą kairėje"
 
-#: data/50-mutter-windows.xml:45 data/org.gnome.mutter.gschema.xml.in:171
+#: data/50-mutter-windows.xml:45 data/org.gnome.mutter.gschema.xml.in:184
 msgid "View split on right"
 msgstr "Rodyti skyrimą dešinėje"
 
@@ -265,11 +265,11 @@ msgstr "Rodyti skyrimą dešinėje"
 msgid "Mutter"
 msgstr "Mutter"
 
-#: data/org.gnome.mutter.gschema.xml.in:7
+#: data/org.gnome.mutter.gschema.xml.in:16
 msgid "Modifier to use for extended window management operations"
 msgstr "Klavišas, naudojamas kartu su specialiomis lango tvarkymo operacijomis"
 
-#: data/org.gnome.mutter.gschema.xml.in:8
+#: data/org.gnome.mutter.gschema.xml.in:17
 msgid ""
 "This key will initiate the “overlay”, which is a combination window overview "
 "and application launching system. The default is intended to be the “Windows "
@@ -280,11 +280,11 @@ msgstr ""
 "paleidimo sistemos kombinacija. Numatytasis nustatymas – „Windows klavišas“. "
 "Tikimasi, kad šis susiejimas bus arba numatytasis, arba nustatytas į tuščią."
 
-#: data/org.gnome.mutter.gschema.xml.in:20
+#: data/org.gnome.mutter.gschema.xml.in:29
 msgid "Attach modal dialogs"
 msgstr "Prikabinti modalinius dialogus"
 
-#: data/org.gnome.mutter.gschema.xml.in:21
+#: data/org.gnome.mutter.gschema.xml.in:30
 msgid ""
 "When true, instead of having independent titlebars, modal dialogs appear "
 "attached to the titlebar of the parent window and are moved together with "
@@ -294,11 +294,11 @@ msgstr ""
 "pasirodys prikabinti prie tėvinio lango antraštės ir yra perkialiami kartu "
 "su tėviniu langu."
 
-#: data/org.gnome.mutter.gschema.xml.in:30
+#: data/org.gnome.mutter.gschema.xml.in:39
 msgid "Enable edge tiling when dropping windows on screen edges"
 msgstr "Įjungti kraštų uždengimą numetant langus ekrano kraštuose"
 
-#: data/org.gnome.mutter.gschema.xml.in:31
+#: data/org.gnome.mutter.gschema.xml.in:40
 msgid ""
 "If enabled, dropping windows on vertical screen edges maximizes them "
 "vertically and resizes them horizontally to cover half of the available "
@@ -308,11 +308,11 @@ msgstr ""
 "vertikaliai ir pakeičia dydį horizontaliai taip, kad užimtų pusę esamos "
 "vietos. Langų numetimas ekrano viršuje juos visiškai išdidina."
 
-#: data/org.gnome.mutter.gschema.xml.in:40
+#: data/org.gnome.mutter.gschema.xml.in:49
 msgid "Workspaces are managed dynamically"
 msgstr "Darbo sritys tvarkomos dinamiškai"
 
-#: data/org.gnome.mutter.gschema.xml.in:41
+#: data/org.gnome.mutter.gschema.xml.in:50
 msgid ""
 "Determines whether workspaces are managed dynamically or whether there’s a "
 "static number of workspaces (determined by the num-workspaces key in org."
@@ -322,11 +322,11 @@ msgstr ""
 "sričių skaičius (nusakomas raktu num-workspaces schemoje org.gnome.desktop."
 "wm.preferences)."
 
-#: data/org.gnome.mutter.gschema.xml.in:50
+#: data/org.gnome.mutter.gschema.xml.in:59
 msgid "Workspaces only on primary"
 msgstr "Darbo sritys tik pagrindiniame"
 
-#: data/org.gnome.mutter.gschema.xml.in:51
+#: data/org.gnome.mutter.gschema.xml.in:60
 msgid ""
 "Determines whether workspace switching should happen for windows on all "
 "monitors or only for windows on the primary monitor."
@@ -334,11 +334,11 @@ msgstr ""
 "Nusako, ar darbo sričių perjungimas turi įvykti langams visuose "
 "monitoriuose, ar tik langams pagrindiniame monitoriuje."
 
-#: data/org.gnome.mutter.gschema.xml.in:59
+#: data/org.gnome.mutter.gschema.xml.in:68
 msgid "No tab popup"
 msgstr "Nėra tab iššokimo"
 
-#: data/org.gnome.mutter.gschema.xml.in:60
+#: data/org.gnome.mutter.gschema.xml.in:69
 msgid ""
 "Determines whether the use of popup and highlight frame should be disabled "
 "for window cycling."
@@ -346,11 +346,11 @@ msgstr ""
 "Nusako, ar iššokančio lango ir rėmelio paryškinimo naudojimas turėtų būti "
 "išjungtas langų perėjime."
 
-#: data/org.gnome.mutter.gschema.xml.in:68
+#: data/org.gnome.mutter.gschema.xml.in:77
 msgid "Delay focus changes until the pointer stops moving"
 msgstr "Atidėti aktyvavimo pakeitimus iki žymiklis nustaja judėti"
 
-#: data/org.gnome.mutter.gschema.xml.in:69
+#: data/org.gnome.mutter.gschema.xml.in:78
 msgid ""
 "If set to true, and the focus mode is either “sloppy” or “mouse” then the "
 "focus will not be changed immediately when entering a window, but only after "
@@ -360,11 +360,11 @@ msgstr ""
 "tuomet aktyvavimas nebus pakeistas nedelsiant įėjus į langą, bet tik pelės "
 "žymikliui nustojus judėti."
 
-#: data/org.gnome.mutter.gschema.xml.in:79
+#: data/org.gnome.mutter.gschema.xml.in:88
 msgid "Draggable border width"
 msgstr "Tempiamos paraštės prolis"
 
-#: data/org.gnome.mutter.gschema.xml.in:80
+#: data/org.gnome.mutter.gschema.xml.in:89
 msgid ""
 "The amount of total draggable borders. If the theme’s visible borders are "
 "not enough, invisible borders will be added to meet this value."
@@ -372,11 +372,11 @@ msgstr ""
 "Bendros tempiamos paraštės dydis. Jei temos matomos paraštės yra "
 "nepakankamos, bus pridėtos nematomos paraštės."
 
-#: data/org.gnome.mutter.gschema.xml.in:89
+#: data/org.gnome.mutter.gschema.xml.in:98
 msgid "Auto maximize nearly monitor sized windows"
 msgstr "Automatiškai išdidinti beveik monitoriaus dydžio langus"
 
-#: data/org.gnome.mutter.gschema.xml.in:90
+#: data/org.gnome.mutter.gschema.xml.in:99
 msgid ""
 "If enabled, new windows that are initially the size of the monitor "
 "automatically get maximized."
@@ -384,11 +384,11 @@ msgstr ""
 "Jei įjungta, nauji langai, kurių pradinis dydis yra monitoriaus dydžio yra "
 "automatiškai išdidinami."
 
-#: data/org.gnome.mutter.gschema.xml.in:98
+#: data/org.gnome.mutter.gschema.xml.in:107
 msgid "Place new windows in the center"
 msgstr "Patalpinti naujus langus centre"
 
-#: data/org.gnome.mutter.gschema.xml.in:99
+#: data/org.gnome.mutter.gschema.xml.in:108
 msgid ""
 "When true, the new windows will always be put in the center of the active "
 "screen of the monitor."
@@ -396,11 +396,27 @@ msgstr ""
 "Kai teigiama, nauji langai bus visada patalpinti aktyvaus monitoriaus ekrano "
 "viduryje."
 
-#: data/org.gnome.mutter.gschema.xml.in:107
+#: data/org.gnome.mutter.gschema.xml.in:117
 msgid "Enable experimental features"
 msgstr "Įjungti eksperimentines savybes"
 
-#: data/org.gnome.mutter.gschema.xml.in:108
+#: data/org.gnome.mutter.gschema.xml.in:118
+#| msgid ""
+#| "To enable experimental features, add the feature keyword to the list. "
+#| "Whether the feature requires restarting the compositor depends on the "
+#| "given feature. Any experimental feature is not required to still be "
+#| "available, or configurable. Don’t expect adding anything in this setting "
+#| "to be future proof. Currently possible keywords: • “scale-monitor-"
+#| "framebuffer” — makes mutter default to layout logical monitors in a "
+#| "logical pixel coordinate space, while scaling monitor framebuffers "
+#| "instead of window content, to manage HiDPI monitors. Does not require a "
+#| "restart. • “rt-scheduler” — makes mutter request a low priority real-time "
+#| "scheduling. The executable or user must have CAP_SYS_NICE. Requires a "
+#| "restart. • “dma-buf-screen-sharing\" — enables DMA buffered screen "
+#| "sharing. This is already enabled by default when using the i915 driver, "
+#| "but disabled for everything else. Requires a restart. • “autoclose-"
+#| "xwayland” — automatically terminates Xwayland if all relevant X11 clients "
+#| "are gone. Does not require a restart."
 msgid ""
 "To enable experimental features, add the feature keyword to the list. "
 "Whether the feature requires restarting the compositor depends on the given "
@@ -409,13 +425,15 @@ msgid ""
 "proof. Currently possible keywords: • “scale-monitor-framebuffer” — makes "
 "mutter default to layout logical monitors in a logical pixel coordinate "
 "space, while scaling monitor framebuffers instead of window content, to "
-"manage HiDPI monitors. Does not require a restart. • “rt-scheduler” — makes "
-"mutter request a low priority real-time scheduling. The executable or user "
-"must have CAP_SYS_NICE. Requires a restart. • “dma-buf-screen-sharing\" — "
-"enables DMA buffered screen sharing. This is already enabled by default when "
-"using the i915 driver, but disabled for everything else. Requires a restart. "
-"• “autoclose-xwayland” — automatically terminates Xwayland if all relevant "
-"X11 clients are gone. Does not require a restart."
+"manage HiDPI monitors. Does not require a restart. • “kms-modifiers” — makes "
+"mutter always advertise valid buffer modifiers on Wayland. This is currently "
+"not the case when using the i915 driver. Does not require a restart. • “rt-"
+"scheduler” — makes mutter request a low priority real-time scheduling. "
+"Requires a restart. • “dma-buf-screen-sharing” — enables DMA buffered screen "
+"sharing. This is already enabled by default when using the i915 driver, but "
+"disabled for everything else. Requires a restart. • “autoclose-xwayland” — "
+"automatically terminates Xwayland if all relevant X11 clients are gone. Does "
+"not require a restart."
 msgstr ""
 "Norėdami įjungti eksperimentines savybes, pridėkite į sąrašą raktinį žodį. "
 "Ar savybė reikalauja kompozitoriaus paleidimo iš naujo priklauso nuo "
@@ -425,27 +443,30 @@ msgstr ""
 "framebuffer“ — mutter numatytai išdėsto loginius monitorius loginėje "
 "pikselių koordinačių erdvėje, tuo pat ištempiant monitorių kadrų buferius "
 "vietoje langų turinio, tokiu būdu valdant didelio tankio monitorius. "
-"Nereikalauja paleisti iš naujo. • “rt-scheduler” — priverčia mutter prašyti "
-"žemo prioriteto realaus laiko planavimo. Programa arba naudotojas turi "
-"turėti CAP_SYS_NICE. Reikalauja paleisti iš naujo. • “dma-buf-screen-sharing"
-"\" — įjungia DMA buferio dalijimąsi ekranu. Tai jau įjungta numatytai, kai "
-"naudojama i915 tvarkyklė, bet išjungta visur kitur. Reikalauja paleisti iš "
-"naujo. • “autoclose-xwayland” — automatiškai išjungia Xwayland, kai visi "
-"susiję X11 kleintai uždaromi. Nereikalauja paleisti iš naujo."
-
-#: data/org.gnome.mutter.gschema.xml.in:143
+"Nereikalauja paleisti iš naujo. • „kms-modifiers“ — priverčia mutter visada "
+"pranešti teisingus buferio modifikatorius Wayland aplinkoje. Šiuo metu taip "
+"nėra naudojant i915 tvarkyklę. Nereikalauja paleisti iš naujo. • „rt-"
+"scheduler“ — priverčia mutter prašyti žemo prioriteto realaus laiko "
+"planavimo. Programa arba naudotojas turi turėti CAP_SYS_NICE. Reikalauja "
+"paleisti iš naujo. • „dma-buf-screen-sharing“ — įjungia DMA buferio "
+"dalijimąsi ekranu. Tai jau įjungta numatytai, kai naudojama i915 tvarkyklė, "
+"bet išjungta visur kitur. Reikalauja paleisti iš naujo. • „autoclose-"
+"xwayland“ — automatiškai išjungia Xwayland, kai visi susiję X11 kleintai "
+"uždaromi. Nereikalauja paleisti iš naujo."
+
+#: data/org.gnome.mutter.gschema.xml.in:156
 msgid "Modifier to use to locate the pointer"
 msgstr "Pakaitos klavišas, naudojamas žymękliui surasti"
 
-#: data/org.gnome.mutter.gschema.xml.in:144
+#: data/org.gnome.mutter.gschema.xml.in:157
 msgid "This key will initiate the “locate pointer” action."
 msgstr "Šis klavišas paleisti veiksmą „surasti žymeklį“."
 
-#: data/org.gnome.mutter.gschema.xml.in:151
+#: data/org.gnome.mutter.gschema.xml.in:164
 msgid "Timeout for check-alive ping"
 msgstr "check-alive ping laiko limitas"
 
-#: data/org.gnome.mutter.gschema.xml.in:152
+#: data/org.gnome.mutter.gschema.xml.in:165
 msgid ""
 "Number of milliseconds a client has to respond to a ping request in order to "
 "not be detected as frozen. Using 0 will disable the alive check completely."
@@ -453,19 +474,19 @@ msgstr ""
 "Per kiek milisekundžių klientas turi atsakyti į ping užklausą, kad nebūtų "
 "aptiktas kaip pakibęs. 0 išjungtas šį tikrinimą."
 
-#: data/org.gnome.mutter.gschema.xml.in:176
+#: data/org.gnome.mutter.gschema.xml.in:189
 msgid "Select window from tab popup"
 msgstr "Pasirinkti langą iš tab iššokimo"
 
-#: data/org.gnome.mutter.gschema.xml.in:181
+#: data/org.gnome.mutter.gschema.xml.in:194
 msgid "Cancel tab popup"
 msgstr "Atšaukti tab iššokimą"
 
-#: data/org.gnome.mutter.gschema.xml.in:186
+#: data/org.gnome.mutter.gschema.xml.in:199
 msgid "Switch monitor configurations"
 msgstr "Perjungti monitorių konfigūracijas"
 
-#: data/org.gnome.mutter.gschema.xml.in:191
+#: data/org.gnome.mutter.gschema.xml.in:204
 msgid "Rotates the built-in monitor configuration"
 msgstr "Suka integruotas monitorių konfigūracijas"
 
@@ -623,28 +644,9 @@ msgstr "%s %s"
 msgid "Compositor"
 msgstr "Komponuotojas"
 
-#: src/backends/x11/meta-clutter-backend-x11.c:237
-#| msgid "X Display to use"
-msgid "X display to use"
-msgstr "Naudotinas X vaizduoklis"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:243
-#| msgid "X Display to use"
-msgid "X screen to use"
-msgstr "Naudotinas X ekranas"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:248
-#: src/core/meta-context-main.c:583
-msgid "Make X calls synchronous"
-msgstr "Sinchronizuoti X iškvietimus"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:254
-msgid "Disable XInput support"
-msgstr "Išjungti XInput palaikymą"
-
 #. This probably means that a non-WM compositor like xcompmgr is running;
 #. * we have no way to get it to exit
-#: src/compositor/compositor.c:513
+#: src/compositor/compositor.c:504
 #, c-format
 msgid ""
 "Another compositing manager is already running on screen %i on display “%s”."
@@ -670,63 +672,67 @@ msgid ""
 "application to quit entirely."
 msgstr "Galite šiek tiek palaukti arba priverstinai uždaryti programą."
 
-#: src/core/meta-close-dialog-default.c:165
+#: src/core/meta-close-dialog-default.c:164
 msgid "_Force Quit"
 msgstr "_Priverstinai išeiti"
 
-#: src/core/meta-close-dialog-default.c:165
+#: src/core/meta-close-dialog-default.c:164
 msgid "_Wait"
 msgstr "_Laukti"
 
-#: src/core/meta-context-main.c:553
+#: src/core/meta-context-main.c:555
 msgid "Replace the running window manager"
 msgstr "Pakeisti veikiančią langų tvarkytuvę"
 
-#: src/core/meta-context-main.c:559
+#: src/core/meta-context-main.c:561
 msgid "X Display to use"
 msgstr "Naudotinas X ekranas"
 
-#: src/core/meta-context-main.c:565
+#: src/core/meta-context-main.c:567
 msgid "Disable connection to session manager"
 msgstr "Išjungti susijungimą su sesijos tvarkytuve"
 
-#: src/core/meta-context-main.c:571
+#: src/core/meta-context-main.c:573
 msgid "Specify session management ID"
 msgstr "Nurodyti sesijos tvarkymo ID"
 
-#: src/core/meta-context-main.c:577
+#: src/core/meta-context-main.c:579
 msgid "Initialize session from savefile"
 msgstr "Inicializuoti sesiją iš išsaugojimo failo"
 
-#: src/core/meta-context-main.c:590
+#: src/core/meta-context-main.c:585
+msgid "Make X calls synchronous"
+msgstr "Sinchronizuoti X iškvietimus"
+
+#: src/core/meta-context-main.c:592
 msgid "Run as a wayland compositor"
 msgstr "Vykdyti kaip wayland kompozitorių"
 
-#: src/core/meta-context-main.c:596
+#: src/core/meta-context-main.c:598
 msgid "Run as a nested compositor"
 msgstr "Vykdyti kaip įdėtinį kompozitorių"
 
-#: src/core/meta-context-main.c:602
+#: src/core/meta-context-main.c:604
 msgid "Run wayland compositor without starting Xwayland"
 msgstr "Paleisti wayland kompozitorių nepaleidžiant Xwayland"
 
-#: src/core/meta-context-main.c:608
+#: src/core/meta-context-main.c:610
 msgid "Specify Wayland display name to use"
 msgstr "Nurodo naudotiną Waylant vaizduoklio pavadinimą"
 
-#: src/core/meta-context-main.c:616
+#: src/core/meta-context-main.c:618
 msgid "Run as a full display server, rather than nested"
 msgstr "Vykdyti kaip visą vaizduoklio serverį, o ne įdėtinį"
 
-#: src/core/meta-context-main.c:621
+#: src/core/meta-context-main.c:623
 msgid "Run as a headless display server"
 msgstr "Vykdyti kaip vaizduoklio serverį be vaizdo"
 
-#: src/core/meta-context-main.c:626
+#: src/core/meta-context-main.c:628
 msgid "Add persistent virtual monitor (WxH or WxH@R)"
 msgstr "Pridėti nuolatinį virtualų monitorių (WxH arba WxH@R)"
 
-#: src/core/meta-context-main.c:632
+#: src/core/meta-context-main.c:639
 msgid "Run with X11 backend"
 msgstr "Paleisti su X11 realizacija"
 
@@ -749,11 +755,11 @@ msgstr "Perjungti monitorių"
 msgid "Show on-screen help"
 msgstr "Rodyti pagalbą ekrane"
 
-#: src/core/mutter.c:47
+#: src/core/mutter.c:74
 msgid "Print version"
 msgstr "Parodyti versiją"
 
-#: src/core/mutter.c:53
+#: src/core/mutter.c:80
 msgid "Mutter plugin to use"
 msgstr "Naudojamas Mutter įskiepis"
 
@@ -762,7 +768,7 @@ msgstr "Naudojamas Mutter įskiepis"
 msgid "Workspace %d"
 msgstr "Darbo sritis %d"
 
-#: src/core/util.c:148
+#: src/core/util.c:141
 msgid "Mutter was compiled without support for verbose mode"
 msgstr "Mutter buvo sukompiliuota be išsamaus veikimo veiksenos"
 
@@ -789,7 +795,7 @@ msgstr "Nepavyko inicializuoti GDK"
 msgid "Failed to open X Window System display “%s”"
 msgstr "Nepavyko atverti X Window sistemos vaizduoklio „%s“"
 
-#: src/x11/meta-x11-display.c:1175
+#: src/x11/meta-x11-display.c:1181
 #, c-format
 msgid "Screen %d on display “%s” is invalid"
 msgstr "Ekranas %d vaizduoklyje „%s“ yra netinkamas"
@@ -799,7 +805,7 @@ msgstr "Ekranas %d vaizduoklyje „%s“ yra netinkamas"
 msgid "Format %s not supported"
 msgstr "Formatas %s nepalaikomas"
 
-#: src/x11/session.c:1845
+#: src/x11/session.c:1823
 msgid ""
 "These windows do not support “save current setup” and will have to be "
 "restarted manually next time you log in."
@@ -812,6 +818,17 @@ msgstr ""
 msgid "%s (on %s)"
 msgstr "%s (kompiuteryje %s)"
 
+#~| msgid "X Display to use"
+#~ msgid "X display to use"
+#~ msgstr "Naudotinas X vaizduoklis"
+
+#~| msgid "X Display to use"
+#~ msgid "X screen to use"
+#~ msgstr "Naudotinas X ekranas"
+
+#~ msgid "Disable XInput support"
+#~ msgstr "Išjungti XInput palaikymą"
+
 #~ msgid "Show the activities overview"
 #~ msgstr "Rodyti veiklų apžvalgą"
 
diff --git a/po/oc.po b/po/oc.po
index 844622362..d0896db97 100644
--- a/po/oc.po
+++ b/po/oc.po
@@ -7,8 +7,8 @@ msgid ""
 msgstr ""
 "Project-Id-Version: mutter master\n"
 "Report-Msgid-Bugs-To: https://gitlab.gnome.org/GNOME/mutter/issues\n"
-"POT-Creation-Date: 2021-11-26 16:02+0000\n"
-"PO-Revision-Date: 2021-11-28 14:40+0100\n"
+"POT-Creation-Date: 2021-11-17 09:03+0000\n"
+"PO-Revision-Date: 2021-11-22 10:23+0100\n"
 "Last-Translator: Quentin PAGÈS\n"
 "Language-Team: Tot En Òc\n"
 "Language: oc\n"
@@ -247,11 +247,11 @@ msgstr "Maximizar la fenèstra verticalament"
 msgid "Maximize window horizontally"
 msgstr "Maximizar la fenèstra orizontalament"
 
-#: data/50-mutter-windows.xml:41 data/org.gnome.mutter.gschema.xml.in:166
+#: data/50-mutter-windows.xml:41 data/org.gnome.mutter.gschema.xml.in:179
 msgid "View split on left"
 msgstr "Vista devesida a esquèrra"
 
-#: data/50-mutter-windows.xml:45 data/org.gnome.mutter.gschema.xml.in:171
+#: data/50-mutter-windows.xml:45 data/org.gnome.mutter.gschema.xml.in:184
 msgid "View split on right"
 msgstr "Vista devesida a dreita"
 
@@ -259,12 +259,12 @@ msgstr "Vista devesida a dreita"
 msgid "Mutter"
 msgstr "Mutter"
 
-#: data/org.gnome.mutter.gschema.xml.in:7
+#: data/org.gnome.mutter.gschema.xml.in:16
 msgid "Modifier to use for extended window management operations"
 msgstr ""
 "Tòca d'utilizar per las operacions espandidas de gestion de las fenèstras"
 
-#: data/org.gnome.mutter.gschema.xml.in:8
+#: data/org.gnome.mutter.gschema.xml.in:17
 msgid ""
 "This key will initiate the “overlay”, which is a combination window overview "
 "and application launching system. The default is intended to be the “Windows "
@@ -276,11 +276,11 @@ msgstr ""
 "material PC es la tòca Windows. En principi, aqueste acorchi es configurat "
 "sul reglatge per defaut o sus la cadena voida."
 
-#: data/org.gnome.mutter.gschema.xml.in:20
+#: data/org.gnome.mutter.gschema.xml.in:29
 msgid "Attach modal dialogs"
 msgstr "Estacar las bóstias de dialòg modal"
 
-#: data/org.gnome.mutter.gschema.xml.in:21
+#: data/org.gnome.mutter.gschema.xml.in:30
 msgid ""
 "When true, instead of having independent titlebars, modal dialogs appear "
 "attached to the titlebar of the parent window and are moved together with "
@@ -290,11 +290,11 @@ msgstr ""
 "dialòg apareisson estacadas a la barra de títol de la fenèstra parenta e son "
 "desplaçadas ensembles amb ela."
 
-#: data/org.gnome.mutter.gschema.xml.in:30
+#: data/org.gnome.mutter.gschema.xml.in:39
 msgid "Enable edge tiling when dropping windows on screen edges"
 msgstr "Activar l'empilatge de las fenèstras depausadas suls bòrds de l'ecran"
 
-#: data/org.gnome.mutter.gschema.xml.in:31
+#: data/org.gnome.mutter.gschema.xml.in:40
 msgid ""
 "If enabled, dropping windows on vertical screen edges maximizes them "
 "vertically and resizes them horizontally to cover half of the available "
@@ -305,11 +305,11 @@ msgstr ""
 "mitat de la zòna disponibla. Lo depaus de las fenèstras sul bòrd superior de "
 "l'ecran las maximiza completament."
 
-#: data/org.gnome.mutter.gschema.xml.in:40
+#: data/org.gnome.mutter.gschema.xml.in:49
 msgid "Workspaces are managed dynamically"
 msgstr "Les espacis de trabalh son gerits d'un biais dinamic"
 
-#: data/org.gnome.mutter.gschema.xml.in:41
+#: data/org.gnome.mutter.gschema.xml.in:50
 msgid ""
 "Determines whether workspaces are managed dynamically or whether there’s a "
 "static number of workspaces (determined by the num-workspaces key in org."
@@ -319,11 +319,11 @@ msgstr ""
 "nombre d'espacis de trabalh es fixe (determinat per la clau num-workspaces "
 "dins org.gnome.desktop.wm.preferences)."
 
-#: data/org.gnome.mutter.gschema.xml.in:50
+#: data/org.gnome.mutter.gschema.xml.in:59
 msgid "Workspaces only on primary"
 msgstr "Espacis de trabalh solament sus l'ecran principal"
 
-#: data/org.gnome.mutter.gschema.xml.in:51
+#: data/org.gnome.mutter.gschema.xml.in:60
 msgid ""
 "Determines whether workspace switching should happen for windows on all "
 "monitors or only for windows on the primary monitor."
@@ -332,11 +332,11 @@ msgstr ""
 "fenèstras de totes los ecrans o solament per las fenèstras de l'ecran "
 "principal."
 
-#: data/org.gnome.mutter.gschema.xml.in:59
+#: data/org.gnome.mutter.gschema.xml.in:68
 msgid "No tab popup"
 msgstr "Pas cap d'aparicion en seguida d'una quichada sus la tòca tab"
 
-#: data/org.gnome.mutter.gschema.xml.in:60
+#: data/org.gnome.mutter.gschema.xml.in:69
 msgid ""
 "Determines whether the use of popup and highlight frame should be disabled "
 "for window cycling."
@@ -344,11 +344,11 @@ msgstr ""
 "Determina se l'utilizacion de fenèstras sorgissentas e de mesa en valor deu "
 "èsser desactivada per la consultacion de las fenèstras."
 
-#: data/org.gnome.mutter.gschema.xml.in:68
+#: data/org.gnome.mutter.gschema.xml.in:77
 msgid "Delay focus changes until the pointer stops moving"
 msgstr "Espèra l'arrèst del puntador abans lo cambiament de focus"
 
-#: data/org.gnome.mutter.gschema.xml.in:69
+#: data/org.gnome.mutter.gschema.xml.in:78
 msgid ""
 "If set to true, and the focus mode is either “sloppy” or “mouse” then the "
 "focus will not be changed immediately when entering a window, but only after "
@@ -358,11 +358,11 @@ msgstr ""
 "alara lo focus serà pas cambiat immediatament en passant sus una fenèstra, "
 "mas solament aprèp que lo puntador s'arrèste."
 
-#: data/org.gnome.mutter.gschema.xml.in:79
+#: data/org.gnome.mutter.gschema.xml.in:88
 msgid "Draggable border width"
 msgstr "Largor de bordadura ajustabla"
 
-#: data/org.gnome.mutter.gschema.xml.in:80
+#: data/org.gnome.mutter.gschema.xml.in:89
 msgid ""
 "The amount of total draggable borders. If the theme’s visible borders are "
 "not enough, invisible borders will be added to meet this value."
@@ -371,13 +371,13 @@ msgstr ""
 "visiblas del tèma son pas sufisentas, de bordaduras invisiblas son apondudas "
 "per arribar a aquesta valor."
 
-#: data/org.gnome.mutter.gschema.xml.in:89
+#: data/org.gnome.mutter.gschema.xml.in:98
 msgid "Auto maximize nearly monitor sized windows"
 msgstr ""
 "Maximizar automaticament las fenèstras que la talha n'es pròcha de la de "
 "l'ecran"
 
-#: data/org.gnome.mutter.gschema.xml.in:90
+#: data/org.gnome.mutter.gschema.xml.in:99
 msgid ""
 "If enabled, new windows that are initially the size of the monitor "
 "automatically get maximized."
@@ -385,11 +385,11 @@ msgstr ""
 "Se activat, las novèlas fenèstras qu'an gaireben la talha de l'ecran a la "
 "dobertura seràn maximizadas automaticament."
 
-#: data/org.gnome.mutter.gschema.xml.in:98
+#: data/org.gnome.mutter.gschema.xml.in:107
 msgid "Place new windows in the center"
 msgstr "Plaçar las novèlas fenèstras al centre"
 
-#: data/org.gnome.mutter.gschema.xml.in:99
+#: data/org.gnome.mutter.gschema.xml.in:108
 msgid ""
 "When true, the new windows will always be put in the center of the active "
 "screen of the monitor."
@@ -397,11 +397,11 @@ msgstr ""
 "Se true (verai), las novèlas fenèstras seràn totjorn plaçadas al centre de "
 "l'ecran actiu del monitor."
 
-#: data/org.gnome.mutter.gschema.xml.in:107
+#: data/org.gnome.mutter.gschema.xml.in:117
 msgid "Enable experimental features"
 msgstr "Activar las foncionalistats experimentalas"
 
-#: data/org.gnome.mutter.gschema.xml.in:108
+#: data/org.gnome.mutter.gschema.xml.in:118
 msgid ""
 "To enable experimental features, add the feature keyword to the list. "
 "Whether the feature requires restarting the compositor depends on the given "
@@ -410,28 +410,47 @@ msgid ""
 "proof. Currently possible keywords: • “scale-monitor-framebuffer” — makes "
 "mutter default to layout logical monitors in a logical pixel coordinate "
 "space, while scaling monitor framebuffers instead of window content, to "
-"manage HiDPI monitors. Does not require a restart. • “rt-scheduler” — makes "
-"mutter request a low priority real-time scheduling. The executable or user "
-"must have CAP_SYS_NICE. Requires a restart. • “dma-buf-screen-sharing\" — "
-"enables DMA buffered screen sharing. This is already enabled by default when "
-"using the i915 driver, but disabled for everything else. Requires a restart. "
-"• “autoclose-xwayland” — automatically terminates Xwayland if all relevant "
-"X11 clients are gone. Does not require a restart."
+"manage HiDPI monitors. Does not require a restart. • “kms-modifiers” — makes "
+"mutter always advertise valid buffer modifiers on Wayland. This is currently "
+"not the case when using the i915 driver. Does not require a restart. • “rt-"
+"scheduler” — makes mutter request a low priority real-time scheduling. "
+"Requires a restart. • “dma-buf-screen-sharing” — enables DMA buffered screen "
+"sharing. This is already enabled by default when using the i915 driver, but "
+"disabled for everything else. Requires a restart. • “autoclose-xwayland” — "
+"automatically terminates Xwayland if all relevant X11 clients are gone. Does "
+"not require a restart."
 msgstr ""
-
-#: data/org.gnome.mutter.gschema.xml.in:143
+"Per activar las fonctionnalitats experimentalas, ajustatz lo mot-clau de la "
+"fonctionnalitat dins la lista. Segon la fonctionnalitat, pòt èsser necessari "
+"de reaviar lo compositor. Cada fonctionnalitat experimentala pòt "
+"disparéisser o èsser pas mai configurabla. Esperetz pas a çò que lo "
+"contengut d'aquel reglatge d'acòrdi estable dins lo temps. Los mots-claus "
+"actualament possiblas son : • « scale-monitor-framebuffer » — demanda a "
+"mutter d'utilizar per deca una disposicion per monitor logic dins un espaci "
+"de coordenadas de pixèl logic, tot en metent a l'escala las « framebuffers » "
+"de monitor al lòc dels contenguts de fenèstra per poder gerir los monitors a "
+"nauta densitat. Aquò necessita pas de reaviada. • « rt-scheduler » — indica "
+"a mutter de demandar un ordonnancement temps real a febla prioritat. "
+"L'executable o l'utilizaire deure aver CAP_SYS_NIÇA. Necessita una reaviada. "
+"• « dma-buf-screen-sharing » — activa lo partiment d'ecran amb tampon DMA. "
+"Aquò es ja actiu per deca amb lo pilòte i915, mas desactivat per tota la "
+"rèsta. Necessita una reaviada. • « autoclose-xwayland » — quita "
+"automaticament Xwayland se totes los clients X11 concernits son partits. "
+"Necessita pas cap de reaviada."
+
+#: data/org.gnome.mutter.gschema.xml.in:156
 msgid "Modifier to use to locate the pointer"
 msgstr "Tòca modificadora d’utilizar per localizar lo puntador"
 
-#: data/org.gnome.mutter.gschema.xml.in:144
+#: data/org.gnome.mutter.gschema.xml.in:157
 msgid "This key will initiate the “locate pointer” action."
-msgstr "Aquesta tòca iniciarà l’accion « localizar lo puntador »."
+msgstr "Aquesta tòca iniciarà l’accion « localizar lo puntador »."
 
-#: data/org.gnome.mutter.gschema.xml.in:151
+#: data/org.gnome.mutter.gschema.xml.in:164
 msgid "Timeout for check-alive ping"
 msgstr "Relambi pel ping de verificacion d’activitat"
 
-#: data/org.gnome.mutter.gschema.xml.in:152
+#: data/org.gnome.mutter.gschema.xml.in:165
 msgid ""
 "Number of milliseconds a client has to respond to a ping request in order to "
 "not be detected as frozen. Using 0 will disable the alive check completely."
@@ -440,21 +459,21 @@ msgstr ""
 "èsser pas detectat coma blocat. L’utilizacion de 0 desactivarà complètament "
 "la verificacion."
 
-#: data/org.gnome.mutter.gschema.xml.in:176
+#: data/org.gnome.mutter.gschema.xml.in:189
 msgid "Select window from tab popup"
 msgstr ""
 "Seleccionar la fenèstra dins la vista qu'apareis en seguida d'una quichada "
 "sus la tòca tab"
 
-#: data/org.gnome.mutter.gschema.xml.in:181
+#: data/org.gnome.mutter.gschema.xml.in:194
 msgid "Cancel tab popup"
 msgstr "Tampar la vista qu'apareis en seguida d'una quichada sus la tòca tab"
 
-#: data/org.gnome.mutter.gschema.xml.in:186
+#: data/org.gnome.mutter.gschema.xml.in:199
 msgid "Switch monitor configurations"
 msgstr "Bascular la configuracion del monitor"
 
-#: data/org.gnome.mutter.gschema.xml.in:191
+#: data/org.gnome.mutter.gschema.xml.in:204
 msgid "Rotates the built-in monitor configuration"
 msgstr "Vira la configuracion d’usina del monitor"
 
@@ -615,26 +634,9 @@ msgstr "%s %s"
 msgid "Compositor"
 msgstr "Compositor"
 
-#: src/backends/x11/meta-clutter-backend-x11.c:237
-msgid "X display to use"
-msgstr "Afichatge X d'utilizar"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:243
-msgid "X screen to use"
-msgstr "Ecran X d'utilizar"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:248
-#: src/core/meta-context-main.c:585
-msgid "Make X calls synchronous"
-msgstr "Rendre sincròns los apèls a X"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:254
-msgid "Disable XInput support"
-msgstr "Desactivar la presa en carga de XInput"
-
 #. This probably means that a non-WM compositor like xcompmgr is running;
 #. * we have no way to get it to exit
-#: src/compositor/compositor.c:513
+#: src/compositor/compositor.c:504
 #, c-format
 msgid ""
 "Another compositing manager is already running on screen %i on display “%s”."
@@ -664,11 +666,11 @@ msgstr ""
 "Podètz pacientar un moment per contunhar o forçar l'aplicacion a quitar "
 "definitivament."
 
-#: src/core/meta-close-dialog-default.c:164
+#: src/core/meta-close-dialog-default.c:165
 msgid "_Force Quit"
 msgstr "_Forçar a quitar"
 
-#: src/core/meta-close-dialog-default.c:164
+#: src/core/meta-close-dialog-default.c:165
 msgid "_Wait"
 msgstr "_Esperar"
 
@@ -692,6 +694,10 @@ msgstr "Indicar l'ID de gestion de sessions"
 msgid "Initialize session from savefile"
 msgstr "Inicializar la session dempuèi lo fichièr de salvament"
 
+#: src/core/meta-context-main.c:585
+msgid "Make X calls synchronous"
+msgstr "Rendre sincròns los apèls a X"
+
 #: src/core/meta-context-main.c:592
 msgid "Run as a wayland compositor"
 msgstr "Aviar coma un compositor wayland"
@@ -743,11 +749,11 @@ msgstr "Cambiar de monitor"
 msgid "Show on-screen help"
 msgstr "Afichar l’ajuda a l’ecran"
 
-#: src/core/mutter.c:48
+#: src/core/mutter.c:74
 msgid "Print version"
 msgstr "Imprimir la version"
 
-#: src/core/mutter.c:54
+#: src/core/mutter.c:80
 msgid "Mutter plugin to use"
 msgstr "Empeuton de Mutter d'utilizar"
 
@@ -756,7 +762,7 @@ msgstr "Empeuton de Mutter d'utilizar"
 msgid "Workspace %d"
 msgstr "Espaci de trabalh %d"
 
-#: src/core/util.c:148
+#: src/core/util.c:149
 msgid "Mutter was compiled without support for verbose mode"
 msgstr "Mutter es estat compilat sens la presa en carga del mòde verbós"
 
@@ -783,7 +789,7 @@ msgstr "Impossible d'inicializar GDK"
 msgid "Failed to open X Window System display “%s”"
 msgstr "Impossible de dobrir l'afichatge « %s » del sistèma X Window"
 
-#: src/x11/meta-x11-display.c:1175
+#: src/x11/meta-x11-display.c:1181
 #, c-format
 msgid "Screen %d on display “%s” is invalid"
 msgstr "L'ecran %d sus l'afichatge « %s » es pas valid"
@@ -793,7 +799,7 @@ msgstr "L'ecran %d sus l'afichatge « %s » es pas valid"
 msgid "Format %s not supported"
 msgstr "Lo format %s es pas pres en carga"
 
-#: src/x11/session.c:1845
+#: src/x11/session.c:1823
 msgid ""
 "These windows do not support “save current setup” and will have to be "
 "restarted manually next time you log in."
diff --git a/po/pt.po b/po/pt.po
index 127ac9935..b73ba1ed6 100644
--- a/po/pt.po
+++ b/po/pt.po
@@ -5,14 +5,14 @@
 # Pedro Albuquerque <palbuquerque73@openmailbox.com>, 2015.
 # Tiago Santos <tiagofsantos81@sapo.pt>, 2016.
 # Juliano de Souza Camargo <julianosc@protonmail.com>, 2020.
-# Hugo Carvalho <hugokarvalho@hotmail.com>, 2020.
+# Hugo Carvalho <hugokarvalho@hotmail.com>, 2020, 2021.
 #
 msgid ""
 msgstr ""
 "Project-Id-Version: 3.10\n"
 "Report-Msgid-Bugs-To: https://gitlab.gnome.org/GNOME/mutter/issues\n"
-"POT-Creation-Date: 2021-07-19 15:55+0000\n"
-"PO-Revision-Date: 2021-07-22 11:37+0100\n"
+"POT-Creation-Date: 2021-11-04 20:03+0000\n"
+"PO-Revision-Date: 2021-11-07 22:25+0000\n"
 "Last-Translator: Hugo Carvalho <hugokarvalho@hotmail.com>\n"
 "Language-Team: https://l10n.gnome.org/teams/pt/\n"
 "Language: pt\n"
@@ -183,10 +183,6 @@ msgstr "Sistema"
 msgid "Show the run command prompt"
 msgstr "Mostrar a linha de comando de execução"
 
-#: data/50-mutter-system.xml:10
-msgid "Show the activities overview"
-msgstr "Mostrar o resumo de atividades"
-
 #: data/50-mutter-wayland.xml:8
 msgid "Restore the keyboard shortcuts"
 msgstr "Redefinir as teclas de atalho"
@@ -255,11 +251,11 @@ msgstr "Maximizar janela verticalmente"
 msgid "Maximize window horizontally"
 msgstr "Maximizar janela horizontalmente"
 
-#: data/50-mutter-windows.xml:41 data/org.gnome.mutter.gschema.xml.in:166
+#: data/50-mutter-windows.xml:41 data/org.gnome.mutter.gschema.xml.in:179
 msgid "View split on left"
 msgstr "Ver a divisão à esquerda"
 
-#: data/50-mutter-windows.xml:45 data/org.gnome.mutter.gschema.xml.in:171
+#: data/50-mutter-windows.xml:45 data/org.gnome.mutter.gschema.xml.in:184
 msgid "View split on right"
 msgstr "Ver a divisão à direita"
 
@@ -267,11 +263,11 @@ msgstr "Ver a divisão à direita"
 msgid "Mutter"
 msgstr "Mutter"
 
-#: data/org.gnome.mutter.gschema.xml.in:7
+#: data/org.gnome.mutter.gschema.xml.in:16
 msgid "Modifier to use for extended window management operations"
 msgstr "Modificador a utilizar para operações estendidas de gestão de janelas"
 
-#: data/org.gnome.mutter.gschema.xml.in:8
+#: data/org.gnome.mutter.gschema.xml.in:17
 msgid ""
 "This key will initiate the “overlay”, which is a combination window overview "
 "and application launching system. The default is intended to be the “Windows "
@@ -283,11 +279,11 @@ msgstr ""
 "computadores PC. Espera-se que esta associação seja a predefinição ou uma "
 "cadeia vazia."
 
-#: data/org.gnome.mutter.gschema.xml.in:20
+#: data/org.gnome.mutter.gschema.xml.in:29
 msgid "Attach modal dialogs"
 msgstr "Anexar diálogos modais"
 
-#: data/org.gnome.mutter.gschema.xml.in:21
+#: data/org.gnome.mutter.gschema.xml.in:30
 msgid ""
 "When true, instead of having independent titlebars, modal dialogs appear "
 "attached to the titlebar of the parent window and are moved together with "
@@ -297,11 +293,11 @@ msgstr ""
 "diálogos modais surgem anexados à barra de título da janela principal e são "
 "movidos juntamente com a janela principal."
 
-#: data/org.gnome.mutter.gschema.xml.in:30
+#: data/org.gnome.mutter.gschema.xml.in:39
 msgid "Enable edge tiling when dropping windows on screen edges"
 msgstr "Ativar ajuste em grelha ao largar janelas nos limites do ecrã"
 
-#: data/org.gnome.mutter.gschema.xml.in:31
+#: data/org.gnome.mutter.gschema.xml.in:40
 msgid ""
 "If enabled, dropping windows on vertical screen edges maximizes them "
 "vertically and resizes them horizontally to cover half of the available "
@@ -312,11 +308,11 @@ msgstr ""
 "disponível. Largar janelas no limite superior do ecrã maximiza-as "
 "completamente."
 
-#: data/org.gnome.mutter.gschema.xml.in:40
+#: data/org.gnome.mutter.gschema.xml.in:49
 msgid "Workspaces are managed dynamically"
 msgstr "Áreas de trabalho geridas dinamicamente"
 
-#: data/org.gnome.mutter.gschema.xml.in:41
+#: data/org.gnome.mutter.gschema.xml.in:50
 msgid ""
 "Determines whether workspaces are managed dynamically or whether there’s a "
 "static number of workspaces (determined by the num-workspaces key in org."
@@ -326,11 +322,11 @@ msgstr ""
 "número estático de áreas de trabalho (determinado pela chave num-workspaces "
 "em org.gnome.desktop.wm.preferences)."
 
-#: data/org.gnome.mutter.gschema.xml.in:50
+#: data/org.gnome.mutter.gschema.xml.in:59
 msgid "Workspaces only on primary"
 msgstr "Áreas de trabalho só no principal"
 
-#: data/org.gnome.mutter.gschema.xml.in:51
+#: data/org.gnome.mutter.gschema.xml.in:60
 msgid ""
 "Determines whether workspace switching should happen for windows on all "
 "monitors or only for windows on the primary monitor."
@@ -338,11 +334,11 @@ msgstr ""
 "Determina se a troca de área de trabalho deverá ocorrer para janelas em "
 "todos os monitores ou apenas para janelas no monitor principal."
 
-#: data/org.gnome.mutter.gschema.xml.in:59
+#: data/org.gnome.mutter.gschema.xml.in:68
 msgid "No tab popup"
 msgstr "Sem popup ao utilizar a tecla tab"
 
-#: data/org.gnome.mutter.gschema.xml.in:60
+#: data/org.gnome.mutter.gschema.xml.in:69
 msgid ""
 "Determines whether the use of popup and highlight frame should be disabled "
 "for window cycling."
@@ -350,11 +346,11 @@ msgstr ""
 "Determina se deverá ou não ser desativado o popup e o realce na janela ao "
 "circular entre janelas."
 
-#: data/org.gnome.mutter.gschema.xml.in:68
+#: data/org.gnome.mutter.gschema.xml.in:77
 msgid "Delay focus changes until the pointer stops moving"
 msgstr "Adiar as alterações de foco até que o ponteiro pare de se mover"
 
-#: data/org.gnome.mutter.gschema.xml.in:69
+#: data/org.gnome.mutter.gschema.xml.in:78
 msgid ""
 "If set to true, and the focus mode is either “sloppy” or “mouse” then the "
 "focus will not be changed immediately when entering a window, but only after "
@@ -364,11 +360,11 @@ msgstr ""
 "será alterado imediatamente ao entrar numa janela mas apenas quando o "
 "ponteiro parar de se mover."
 
-#: data/org.gnome.mutter.gschema.xml.in:79
+#: data/org.gnome.mutter.gschema.xml.in:88
 msgid "Draggable border width"
 msgstr "Largura da margem de arrasto"
 
-#: data/org.gnome.mutter.gschema.xml.in:80
+#: data/org.gnome.mutter.gschema.xml.in:89
 msgid ""
 "The amount of total draggable borders. If the theme’s visible borders are "
 "not enough, invisible borders will be added to meet this value."
@@ -377,11 +373,11 @@ msgstr ""
 "forem suficientes, serão adicionadas margens invisíveis para atingir este "
 "valor."
 
-#: data/org.gnome.mutter.gschema.xml.in:89
+#: data/org.gnome.mutter.gschema.xml.in:98
 msgid "Auto maximize nearly monitor sized windows"
 msgstr "Maximizar automaticamente janelas de dimensão aproximada à do monitor"
 
-#: data/org.gnome.mutter.gschema.xml.in:90
+#: data/org.gnome.mutter.gschema.xml.in:99
 msgid ""
 "If enabled, new windows that are initially the size of the monitor "
 "automatically get maximized."
@@ -389,11 +385,11 @@ msgstr ""
 "Se ativo, novas janelas que sejam inicialmente do tamanho do monitor são "
 "maximizadas automaticamente."
 
-#: data/org.gnome.mutter.gschema.xml.in:98
+#: data/org.gnome.mutter.gschema.xml.in:107
 msgid "Place new windows in the center"
 msgstr "Posicionar novas janelas no centro"
 
-#: data/org.gnome.mutter.gschema.xml.in:99
+#: data/org.gnome.mutter.gschema.xml.in:108
 msgid ""
 "When true, the new windows will always be put in the center of the active "
 "screen of the monitor."
@@ -401,11 +397,11 @@ msgstr ""
 "Se ativo, as novas janelas são sempre posicionadas no centro do ecrã do "
 "monitor ativo."
 
-#: data/org.gnome.mutter.gschema.xml.in:107
+#: data/org.gnome.mutter.gschema.xml.in:117
 msgid "Enable experimental features"
 msgstr "Ativar as funcionalidades experimentais"
 
-#: data/org.gnome.mutter.gschema.xml.in:108
+#: data/org.gnome.mutter.gschema.xml.in:118
 msgid ""
 "To enable experimental features, add the feature keyword to the list. "
 "Whether the feature requires restarting the compositor depends on the given "
@@ -414,13 +410,15 @@ msgid ""
 "proof. Currently possible keywords: • “scale-monitor-framebuffer” — makes "
 "mutter default to layout logical monitors in a logical pixel coordinate "
 "space, while scaling monitor framebuffers instead of window content, to "
-"manage HiDPI monitors. Does not require a restart. • “rt-scheduler” — makes "
-"mutter request a low priority real-time scheduling. The executable or user "
-"must have CAP_SYS_NICE. Requires a restart. • “dma-buf-screen-sharing\" — "
-"enables DMA buffered screen sharing. This is already enabled by default when "
-"using the i915 driver, but disabled for everything else. Requires a restart. "
-"• “autoclose-xwayland” — automatically terminates Xwayland if all relevant "
-"X11 clients are gone. Does not require a restart."
+"manage HiDPI monitors. Does not require a restart. • “kms-modifiers” — makes "
+"mutter always advertise valid buffer modifiers on Wayland. This is currently "
+"not the case when using the i915 driver. Does not require a restart. • “rt-"
+"scheduler” — makes mutter request a low priority real-time scheduling. "
+"Requires a restart. • “dma-buf-screen-sharing” — enables DMA buffered screen "
+"sharing. This is already enabled by default when using the i915 driver, but "
+"disabled for everything else. Requires a restart. • “autoclose-xwayland” — "
+"automatically terminates Xwayland if all relevant X11 clients are gone. Does "
+"not require a restart."
 msgstr ""
 "Para ativar as funcionalidades experimentais, adicione a palavra-chave da "
 "funcionalidade na lista. Se deve reiniciar o compositor após ativá-la, "
@@ -430,28 +428,30 @@ msgstr ""
 "chave são: • “scale-monitor-framebuffer” — torna o mutter padrão para a "
 "disposição de monitores lógicos num espaço de coordenadas de pixel lógico, "
 "enquanto dimensiona os framebuffers do monitor em vez do conteúdo da janela, "
-"para gerir monitores HiDPI. Não requer um reinício. - \"rt-scheduler\" - "
-"torna o pedido do mutter uma programação em tempo real de baixa prioridade. "
-"O executável ou utilizador deve ter CAP_SYS_NICE. Requer um reinício. - "
-"\"dma-buf-screen-sharing\" . — permite a partilha de ecrã DMA em buffer. "
-"Isto já está ativado por defeito quando se utiliza o controlador i915, mas "
-"desativado para tudo o resto. Requer um reinício. • “autoclose-xwayland” — "
-"Termina automaticamente o Xwayland se todos os clientes X11 relevantes "
-"desapareceram. Não requer um reinício."
-
-#: data/org.gnome.mutter.gschema.xml.in:143
+"para gerir monitores HiDPI. Não requer um reinício. • “kms-modifiers” — faz "
+"o mutter publicitar sempre modificadores buffer no Wayland. Este não é "
+"atualmente o caso quando se utiliza o controlador i915. Não requer um "
+"reinício. - \"rt-scheduler\" - torna o pedido do mutter uma programação em "
+"tempo real de baixa prioridade. Requer um reinício. - \"dma-buf-screen-"
+"sharing\" . — permite a partilha de ecrã DMA em buffer. Isto já está ativado "
+"por defeito quando se utiliza o controlador i915, mas desativado para tudo o "
+"resto. Requer um reinício. • “autoclose-xwayland” — Termina automaticamente "
+"o Xwayland se todos os clientes X11 relevantes desapareceram. Não requer um "
+"reinício."
+
+#: data/org.gnome.mutter.gschema.xml.in:156
 msgid "Modifier to use to locate the pointer"
 msgstr "Modificador para localizar o cursor"
 
-#: data/org.gnome.mutter.gschema.xml.in:144
+#: data/org.gnome.mutter.gschema.xml.in:157
 msgid "This key will initiate the “locate pointer” action."
 msgstr "Esta chave iniciará a ação “localizar cursor”."
 
-#: data/org.gnome.mutter.gschema.xml.in:151
+#: data/org.gnome.mutter.gschema.xml.in:164
 msgid "Timeout for check-alive ping"
 msgstr "Expirou o teste de atividade"
 
-#: data/org.gnome.mutter.gschema.xml.in:152
+#: data/org.gnome.mutter.gschema.xml.in:165
 msgid ""
 "Number of milliseconds a client has to respond to a ping request in order to "
 "not be detected as frozen. Using 0 will disable the alive check completely."
@@ -460,19 +460,19 @@ msgstr ""
 "atividade de maneira que não seja detetado como inativo. Usar 0 desativará o "
 "teste de atividade completamente."
 
-#: data/org.gnome.mutter.gschema.xml.in:176
+#: data/org.gnome.mutter.gschema.xml.in:189
 msgid "Select window from tab popup"
 msgstr "Selecionar a janela no popup de tabulador"
 
-#: data/org.gnome.mutter.gschema.xml.in:181
+#: data/org.gnome.mutter.gschema.xml.in:194
 msgid "Cancel tab popup"
 msgstr "Cancelar a exibição do tab"
 
-#: data/org.gnome.mutter.gschema.xml.in:186
+#: data/org.gnome.mutter.gschema.xml.in:199
 msgid "Switch monitor configurations"
 msgstr "Alternar configurações de ecrã"
 
-#: data/org.gnome.mutter.gschema.xml.in:191
+#: data/org.gnome.mutter.gschema.xml.in:204
 msgid "Rotates the built-in monitor configuration"
 msgstr "Alternar as configurações nativas do ecrã"
 
@@ -600,26 +600,26 @@ msgstr ""
 "selecionadas. O Xwayland precisa de ser reiniciado para que esta "
 "configuração tenha efeito."
 
-#: src/backends/meta-monitor.c:235
+#: src/backends/meta-monitor.c:246
 msgid "Built-in display"
 msgstr "Ecrã embutido"
 
-#: src/backends/meta-monitor.c:264
+#: src/backends/meta-monitor.c:275
 msgid "Unknown"
 msgstr "Desconhecido"
 
-#: src/backends/meta-monitor.c:266
+#: src/backends/meta-monitor.c:277
 msgid "Unknown Display"
 msgstr "Ecrã desconhecido"
 
-#: src/backends/meta-monitor.c:274
+#: src/backends/meta-monitor.c:285
 #, c-format
 msgctxt ""
 "This is a monitor vendor name, followed by a size in inches, like 'Dell 15\"'"
 msgid "%s %s"
 msgstr "%s %s"
 
-#: src/backends/meta-monitor.c:282
+#: src/backends/meta-monitor.c:293
 #, c-format
 msgctxt ""
 "This is a monitor vendor name followed by product/model name where size in "
@@ -632,26 +632,9 @@ msgstr "%s %s"
 msgid "Compositor"
 msgstr "Compositor"
 
-#: src/backends/x11/meta-clutter-backend-x11.c:237
-msgid "X display to use"
-msgstr "Visor X a utilizar"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:243
-msgid "X screen to use"
-msgstr "Ecrã X a utilizar"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:248
-#: src/core/meta-context-main.c:583
-msgid "Make X calls synchronous"
-msgstr "Fazer as chamadas X sincronamente"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:254
-msgid "Disable XInput support"
-msgstr "Desativar suporte XInput"
-
 #. This probably means that a non-WM compositor like xcompmgr is running;
 #. * we have no way to get it to exit
-#: src/compositor/compositor.c:513
+#: src/compositor/compositor.c:504
 #, c-format
 msgid ""
 "Another compositing manager is already running on screen %i on display “%s”."
@@ -688,55 +671,59 @@ msgstr "_Forçar terminar"
 msgid "_Wait"
 msgstr "Aguardar"
 
-#: src/core/meta-context-main.c:553
+#: src/core/meta-context-main.c:555
 msgid "Replace the running window manager"
 msgstr "Substituir o gestor de janelas em execução"
 
-#: src/core/meta-context-main.c:559
+#: src/core/meta-context-main.c:561
 msgid "X Display to use"
 msgstr "Ecrã X a utilizar"
 
-#: src/core/meta-context-main.c:565
+#: src/core/meta-context-main.c:567
 msgid "Disable connection to session manager"
 msgstr "Desativar a ligação ao gestor de sessão"
 
-#: src/core/meta-context-main.c:571
+#: src/core/meta-context-main.c:573
 msgid "Specify session management ID"
 msgstr "Especificar a ID de gestão de sessão"
 
-#: src/core/meta-context-main.c:577
+#: src/core/meta-context-main.c:579
 msgid "Initialize session from savefile"
 msgstr "Inicializar a sessão a partir de um ficheiro de gravação de sessão"
 
-#: src/core/meta-context-main.c:590
+#: src/core/meta-context-main.c:585
+msgid "Make X calls synchronous"
+msgstr "Fazer as chamadas X sincronamente"
+
+#: src/core/meta-context-main.c:592
 msgid "Run as a wayland compositor"
 msgstr "Executar como compositor wayland"
 
-#: src/core/meta-context-main.c:596
+#: src/core/meta-context-main.c:598
 msgid "Run as a nested compositor"
 msgstr "Executar como compositor aninhado"
 
-#: src/core/meta-context-main.c:602
+#: src/core/meta-context-main.c:604
 msgid "Run wayland compositor without starting Xwayland"
 msgstr "Executar o compositor wayland sem a utilização do Xwayland"
 
-#: src/core/meta-context-main.c:608
+#: src/core/meta-context-main.c:610
 msgid "Specify Wayland display name to use"
 msgstr "Especificar o nome do visor Wayland a utilizar"
 
-#: src/core/meta-context-main.c:616
+#: src/core/meta-context-main.c:618
 msgid "Run as a full display server, rather than nested"
 msgstr "Executar como servidor de ecrã inteiro, em vez de aninhado"
 
-#: src/core/meta-context-main.c:621
+#: src/core/meta-context-main.c:623
 msgid "Run as a headless display server"
 msgstr "Executar como um servidor sem monitor"
 
-#: src/core/meta-context-main.c:626
+#: src/core/meta-context-main.c:628
 msgid "Add persistent virtual monitor (WxH or WxH@R)"
 msgstr "Adicionar monitor virtual persistente (WxH ou WxH@R)"
 
-#: src/core/meta-context-main.c:632
+#: src/core/meta-context-main.c:639
 msgid "Run with X11 backend"
 msgstr "Executar com a infira-estrutura X11"
 
@@ -759,11 +746,11 @@ msgstr "Alternar monitor"
 msgid "Show on-screen help"
 msgstr "Mostrar ajuda no ecrã"
 
-#: src/core/mutter.c:47
+#: src/core/mutter.c:74
 msgid "Print version"
 msgstr "Imprimir a versão"
 
-#: src/core/mutter.c:53
+#: src/core/mutter.c:80
 msgid "Mutter plugin to use"
 msgstr "Extensão Mutter a utilizar"
 
@@ -772,7 +759,7 @@ msgstr "Extensão Mutter a utilizar"
 msgid "Workspace %d"
 msgstr "Área de trabalho %d"
 
-#: src/core/util.c:148
+#: src/core/util.c:149
 msgid "Mutter was compiled without support for verbose mode"
 msgstr "O Mutter foi compilado sem suporte para modo verbose"
 
@@ -799,7 +786,7 @@ msgstr "Falhou ao iniciar o GDK"
 msgid "Failed to open X Window System display “%s”"
 msgstr "Falha ao abrir ecrã “%s” do sistema Janelas X"
 
-#: src/x11/meta-x11-display.c:1175
+#: src/x11/meta-x11-display.c:1181
 #, c-format
 msgid "Screen %d on display “%s” is invalid"
 msgstr "Ecrã %d no monitor “%s” é inválido"
@@ -809,7 +796,7 @@ msgstr "Ecrã %d no monitor “%s” é inválido"
 msgid "Format %s not supported"
 msgstr "O formato “%s” não é suportado"
 
-#: src/x11/session.c:1845
+#: src/x11/session.c:1823
 msgid ""
 "These windows do not support “save current setup” and will have to be "
 "restarted manually next time you log in."
@@ -822,6 +809,18 @@ msgstr ""
 msgid "%s (on %s)"
 msgstr "%s (em %s)"
 
+#~ msgid "Show the activities overview"
+#~ msgstr "Mostrar o resumo de atividades"
+
+#~ msgid "X display to use"
+#~ msgstr "Visor X a utilizar"
+
+#~ msgid "X screen to use"
+#~ msgstr "Ecrã X a utilizar"
+
+#~ msgid "Disable XInput support"
+#~ msgstr "Desativar suporte XInput"
+
 #~ msgid ""
 #~ "mutter %s\n"
 #~ "Copyright © 2001-%d Havoc Pennington, Red Hat, Inc., and others\n"
diff --git a/po/ru.po b/po/ru.po
index 51cfebf72..2ae65b667 100644
--- a/po/ru.po
+++ b/po/ru.po
@@ -15,9 +15,9 @@ msgid ""
 msgstr ""
 "Project-Id-Version: metacity ru\n"
 "Report-Msgid-Bugs-To: https://gitlab.gnome.org/GNOME/mutter/issues\n"
-"POT-Creation-Date: 2021-07-19 16:03+0000\n"
-"PO-Revision-Date: 2021-07-22 19:13+0300\n"
-"Last-Translator: Alexey Rubtsov <rushills@gmail.com>\n"
+"POT-Creation-Date: 2021-12-07 14:28+0000\n"
+"PO-Revision-Date: 2021-12-11 15:19+0300\n"
+"Last-Translator: Aleksandr Melman <Alexmelman88@gmail.com>\n"
 "Language-Team: Русский <gnome-cyr@gnome.org>\n"
 "Language: ru\n"
 "MIME-Version: 1.0\n"
@@ -25,7 +25,7 @@ msgstr ""
 "Content-Transfer-Encoding: 8bit\n"
 "Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
 "%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
-"X-Generator: Poedit 2.4.3\n"
+"X-Generator: Poedit 3.0\n"
 
 #: data/50-mutter-navigation.xml:6
 msgid "Navigation"
@@ -187,10 +187,6 @@ msgstr "Система"
 msgid "Show the run command prompt"
 msgstr "Показать командную строку"
 
-#: data/50-mutter-system.xml:10
-msgid "Show the activities overview"
-msgstr "Открыть обзор"
-
 #: data/50-mutter-wayland.xml:8
 msgid "Restore the keyboard shortcuts"
 msgstr "Восстановление сочетаний клавиш"
@@ -259,11 +255,11 @@ msgstr "Развернуть окно на весь экран вертикал
 msgid "Maximize window horizontally"
 msgstr "Развернуть окно на весь экран горизонтально"
 
-#: data/50-mutter-windows.xml:41 data/org.gnome.mutter.gschema.xml.in:166
+#: data/50-mutter-windows.xml:41 data/org.gnome.mutter.gschema.xml.in:179
 msgid "View split on left"
 msgstr "Разделитель слева"
 
-#: data/50-mutter-windows.xml:45 data/org.gnome.mutter.gschema.xml.in:171
+#: data/50-mutter-windows.xml:45 data/org.gnome.mutter.gschema.xml.in:184
 msgid "View split on right"
 msgstr "Разделитель справа"
 
@@ -271,12 +267,12 @@ msgstr "Разделитель справа"
 msgid "Mutter"
 msgstr "Mutter"
 
-#: data/org.gnome.mutter.gschema.xml.in:7
+#: data/org.gnome.mutter.gschema.xml.in:16
 msgid "Modifier to use for extended window management operations"
 msgstr ""
 "Модификатор для использования дополнительных действий управления окнами"
 
-#: data/org.gnome.mutter.gschema.xml.in:8
+#: data/org.gnome.mutter.gschema.xml.in:17
 msgid ""
 "This key will initiate the “overlay”, which is a combination window overview "
 "and application launching system. The default is intended to be the “Windows "
@@ -287,11 +283,11 @@ msgstr ""
 "Для обычных ПК используется клавиша «Windows». Ожидается, что значение этой "
 "привязки будет иметь значение по умолчанию или будет пустой строкой."
 
-#: data/org.gnome.mutter.gschema.xml.in:20
+#: data/org.gnome.mutter.gschema.xml.in:29
 msgid "Attach modal dialogs"
 msgstr "Прикреплять модальные диалоговые окна"
 
-#: data/org.gnome.mutter.gschema.xml.in:21
+#: data/org.gnome.mutter.gschema.xml.in:30
 msgid ""
 "When true, instead of having independent titlebars, modal dialogs appear "
 "attached to the titlebar of the parent window and are moved together with "
@@ -301,11 +297,11 @@ msgstr ""
 "окна будут прикрепляться к заголовку родительского окна и перемещаться "
 "вместе с родительским окном."
 
-#: data/org.gnome.mutter.gschema.xml.in:30
+#: data/org.gnome.mutter.gschema.xml.in:39
 msgid "Enable edge tiling when dropping windows on screen edges"
 msgstr "Включить краевые фреймы при перемещении окон к границам экрана"
 
-#: data/org.gnome.mutter.gschema.xml.in:31
+#: data/org.gnome.mutter.gschema.xml.in:40
 msgid ""
 "If enabled, dropping windows on vertical screen edges maximizes them "
 "vertically and resizes them horizontally to cover half of the available "
@@ -316,11 +312,11 @@ msgstr ""
 "покрывая половину доступного места. Перемещение окна к верхней части экрана "
 "полностью разворачивает окно."
 
-#: data/org.gnome.mutter.gschema.xml.in:40
+#: data/org.gnome.mutter.gschema.xml.in:49
 msgid "Workspaces are managed dynamically"
 msgstr "Рабочие места управляются динамически"
 
-#: data/org.gnome.mutter.gschema.xml.in:41
+#: data/org.gnome.mutter.gschema.xml.in:50
 msgid ""
 "Determines whether workspaces are managed dynamically or whether there’s a "
 "static number of workspaces (determined by the num-workspaces key in org."
@@ -330,11 +326,11 @@ msgstr ""
 "мест постоянно (количество задаётся ключом в org.gnome.desktop.wm."
 "preferences)."
 
-#: data/org.gnome.mutter.gschema.xml.in:50
+#: data/org.gnome.mutter.gschema.xml.in:59
 msgid "Workspaces only on primary"
 msgstr "Рабочие места только на главном окне"
 
-#: data/org.gnome.mutter.gschema.xml.in:51
+#: data/org.gnome.mutter.gschema.xml.in:60
 msgid ""
 "Determines whether workspace switching should happen for windows on all "
 "monitors or only for windows on the primary monitor."
@@ -342,11 +338,11 @@ msgstr ""
 "Определяет, должно ли переключение рабочего места происходить для окон на "
 "всех мониторах или только для окон на главном мониторе."
 
-#: data/org.gnome.mutter.gschema.xml.in:59
+#: data/org.gnome.mutter.gschema.xml.in:68
 msgid "No tab popup"
 msgstr "Без всплывающей табуляции"
 
-#: data/org.gnome.mutter.gschema.xml.in:60
+#: data/org.gnome.mutter.gschema.xml.in:69
 msgid ""
 "Determines whether the use of popup and highlight frame should be disabled "
 "for window cycling."
@@ -354,11 +350,11 @@ msgstr ""
 "Определяет, нужно ли отключить использование всплывающей области для "
 "циклического переключения окон."
 
-#: data/org.gnome.mutter.gschema.xml.in:68
+#: data/org.gnome.mutter.gschema.xml.in:77
 msgid "Delay focus changes until the pointer stops moving"
 msgstr "Отложить переключение фокуса до тех пор, пока не остановится указатель"
 
-#: data/org.gnome.mutter.gschema.xml.in:69
+#: data/org.gnome.mutter.gschema.xml.in:78
 msgid ""
 "If set to true, and the focus mode is either “sloppy” or “mouse” then the "
 "focus will not be changed immediately when entering a window, but only after "
@@ -368,11 +364,11 @@ msgstr ""
 "«sloppy» или «mouse», тогда фокус не будет меняться при переходе к другому "
 "окну до тех пор, пока не остановится указатель."
 
-#: data/org.gnome.mutter.gschema.xml.in:79
+#: data/org.gnome.mutter.gschema.xml.in:88
 msgid "Draggable border width"
 msgstr "Ширина рамки перетаскивания"
 
-#: data/org.gnome.mutter.gschema.xml.in:80
+#: data/org.gnome.mutter.gschema.xml.in:89
 msgid ""
 "The amount of total draggable borders. If the theme’s visible borders are "
 "not enough, invisible borders will be added to meet this value."
@@ -380,11 +376,11 @@ msgstr ""
 "Общая ширина рамок для перетаскивания. Если видимых рамок, используемых в "
 "теме, недостаточно, то будут добавлены невидимые рамки до этого значения."
 
-#: data/org.gnome.mutter.gschema.xml.in:89
+#: data/org.gnome.mutter.gschema.xml.in:98
 msgid "Auto maximize nearly monitor sized windows"
 msgstr "Автоматически увеличивать размеры окна до размеров монитора"
 
-#: data/org.gnome.mutter.gschema.xml.in:90
+#: data/org.gnome.mutter.gschema.xml.in:99
 msgid ""
 "If enabled, new windows that are initially the size of the monitor "
 "automatically get maximized."
@@ -392,11 +388,11 @@ msgstr ""
 "Если включено, новые окна будут автоматически увеличены до максимального "
 "размера."
 
-#: data/org.gnome.mutter.gschema.xml.in:98
+#: data/org.gnome.mutter.gschema.xml.in:107
 msgid "Place new windows in the center"
 msgstr "Размещать новые окна в центре"
 
-#: data/org.gnome.mutter.gschema.xml.in:99
+#: data/org.gnome.mutter.gschema.xml.in:108
 msgid ""
 "When true, the new windows will always be put in the center of the active "
 "screen of the monitor."
@@ -404,11 +400,11 @@ msgstr ""
 "Если выбрано, то новые окна всегда будут помещаться в центр активного экрана "
 "монитора."
 
-#: data/org.gnome.mutter.gschema.xml.in:107
+#: data/org.gnome.mutter.gschema.xml.in:117
 msgid "Enable experimental features"
 msgstr "Включить экспериментальные функции"
 
-#: data/org.gnome.mutter.gschema.xml.in:108
+#: data/org.gnome.mutter.gschema.xml.in:118
 msgid ""
 "To enable experimental features, add the feature keyword to the list. "
 "Whether the feature requires restarting the compositor depends on the given "
@@ -417,13 +413,15 @@ msgid ""
 "proof. Currently possible keywords: • “scale-monitor-framebuffer” — makes "
 "mutter default to layout logical monitors in a logical pixel coordinate "
 "space, while scaling monitor framebuffers instead of window content, to "
-"manage HiDPI monitors. Does not require a restart. • “rt-scheduler” — makes "
-"mutter request a low priority real-time scheduling. The executable or user "
-"must have CAP_SYS_NICE. Requires a restart. • “dma-buf-screen-sharing\" — "
-"enables DMA buffered screen sharing. This is already enabled by default when "
-"using the i915 driver, but disabled for everything else. Requires a restart. "
-"• “autoclose-xwayland” — automatically terminates Xwayland if all relevant "
-"X11 clients are gone. Does not require a restart."
+"manage HiDPI monitors. Does not require a restart. • “kms-modifiers” — makes "
+"mutter always advertise valid buffer modifiers on Wayland. This is currently "
+"not the case when using the i915 driver. Does not require a restart. • “rt-"
+"scheduler” — makes mutter request a low priority real-time scheduling. "
+"Requires a restart. • “dma-buf-screen-sharing” — enables DMA buffered screen "
+"sharing. This is already enabled by default when using the i915 driver, but "
+"disabled for everything else. Requires a restart. • “autoclose-xwayland” — "
+"automatically terminates Xwayland if all relevant X11 clients are gone. Does "
+"not require a restart."
 msgstr ""
 "Чтобы включить экспериментальные функции, добавьте в список ключевое слово "
 "feature. Требует ли функция перезапуска композитора, зависит от данной "
@@ -433,30 +431,31 @@ msgstr ""
 "framebuffer\" - заставляет mutter по умолчанию компоновать логические "
 "мониторы в логическом пиксельном координатном пространстве, при этом "
 "масштабируя фреймбуферы мониторов, а не содержимое окна, для управления "
-"мониторами HiDPI. Не требует перезапуска. - \"rt-scheduler\" - заставляет "
-"mutter запрашивать низкоприоритетное планирование в реальном времени. "
-"Исполняемый файл или пользователь должны иметь CAP_SYS_NICE. Требует "
-"перезапуска. - \"dma-buf-screen-sharing\" - включает совместное "
-"использование экрана с буферизацией DMA. Это уже включено по умолчанию при "
-"использовании драйвера i915, но отключено для всего остального. Требуется "
-"перезагрузка. - \"autoclose-xwayland\" - автоматически завершает работу "
-"Xwayland, если все соответствующие клиенты X11 удалены. Не требует "
-"перезапуска."
-
-#: data/org.gnome.mutter.gschema.xml.in:143
+"мониторами HiDPI. Не требует перезапуска. - \"kms-modifiers\" - заставляет "
+"mutter всегда рекламировать действительные модификаторы буфера на Wayland. В "
+"настоящее время это не так при использовании драйвера i915. Не требует "
+"перезапуска. - \"rt-scheduler\" - заставляет mutter запрашивать "
+"низкоприоритетное планирование реального времени. Требует перезапуска. - "
+"\"dma-buf-screen-sharing\" - включает совместное использование экрана с "
+"буферизацией DMA. Это уже включено по умолчанию при использовании драйвера "
+"i915, но отключено для всего остального. Требуется перезагрузка. - "
+"\"autoclose-xwayland\" - автоматически завершает работу Xwayland, если все "
+"соответствующие клиенты X11 удалены. Не требует перезапуска."
+
+#: data/org.gnome.mutter.gschema.xml.in:156
 msgid "Modifier to use to locate the pointer"
 msgstr "Модификатор, используемый для определения местоположения указателя"
 
-#: data/org.gnome.mutter.gschema.xml.in:144
+#: data/org.gnome.mutter.gschema.xml.in:157
 msgid "This key will initiate the “locate pointer” action."
 msgstr ""
 "Эта клавиша инициирует действие \"определить местоположение указателя\"."
 
-#: data/org.gnome.mutter.gschema.xml.in:151
+#: data/org.gnome.mutter.gschema.xml.in:164
 msgid "Timeout for check-alive ping"
 msgstr "Тайм-аут для пинга с проверкой работоспособности"
 
-#: data/org.gnome.mutter.gschema.xml.in:152
+#: data/org.gnome.mutter.gschema.xml.in:165
 msgid ""
 "Number of milliseconds a client has to respond to a ping request in order to "
 "not be detected as frozen. Using 0 will disable the alive check completely."
@@ -465,19 +464,19 @@ msgstr ""
 "ping, чтобы не быть определенным как \"замороженный\". Использование "
 "значения 0 полностью отключает проверку \"живого\" клиента."
 
-#: data/org.gnome.mutter.gschema.xml.in:176
+#: data/org.gnome.mutter.gschema.xml.in:189
 msgid "Select window from tab popup"
 msgstr "Выбор окна из всплывающей табуляции"
 
-#: data/org.gnome.mutter.gschema.xml.in:181
+#: data/org.gnome.mutter.gschema.xml.in:194
 msgid "Cancel tab popup"
 msgstr "Отменить всплывающую табуляцию"
 
-#: data/org.gnome.mutter.gschema.xml.in:186
+#: data/org.gnome.mutter.gschema.xml.in:199
 msgid "Switch monitor configurations"
 msgstr "Переключить конфигурации монитора"
 
-#: data/org.gnome.mutter.gschema.xml.in:191
+#: data/org.gnome.mutter.gschema.xml.in:204
 msgid "Rotates the built-in monitor configuration"
 msgstr "Перебирает встроенные конфигурации монитора"
 
@@ -605,26 +604,26 @@ msgstr ""
 "Xwayland был создан без поддержки выбранных расширений. Чтобы эта настройка "
 "вступила в силу, Xwayland необходимо перезапустить."
 
-#: src/backends/meta-monitor.c:235
+#: src/backends/meta-monitor.c:246
 msgid "Built-in display"
 msgstr "Встроенный дисплей"
 
-#: src/backends/meta-monitor.c:264
+#: src/backends/meta-monitor.c:275
 msgid "Unknown"
 msgstr "Неизвестный"
 
-#: src/backends/meta-monitor.c:266
+#: src/backends/meta-monitor.c:277
 msgid "Unknown Display"
 msgstr "Неизвестный дисплей"
 
-#: src/backends/meta-monitor.c:274
+#: src/backends/meta-monitor.c:285
 #, c-format
 msgctxt ""
 "This is a monitor vendor name, followed by a size in inches, like 'Dell 15\"'"
 msgid "%s %s"
 msgstr "%s %s"
 
-#: src/backends/meta-monitor.c:282
+#: src/backends/meta-monitor.c:293
 #, c-format
 msgctxt ""
 "This is a monitor vendor name followed by product/model name where size in "
@@ -637,26 +636,9 @@ msgstr "%s %s"
 msgid "Compositor"
 msgstr "Композитор"
 
-#: src/backends/x11/meta-clutter-backend-x11.c:237
-msgid "X display to use"
-msgstr "Используемый дисплей X"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:243
-msgid "X screen to use"
-msgstr "Используемый экран X"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:248
-#: src/core/meta-context-main.c:583
-msgid "Make X calls synchronous"
-msgstr "Сделать X-вызовы синхронными"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:254
-msgid "Disable XInput support"
-msgstr "Запретить поддержку XInput"
-
 #. This probably means that a non-WM compositor like xcompmgr is running;
 #. * we have no way to get it to exit
-#: src/compositor/compositor.c:513
+#: src/compositor/compositor.c:504
 #, c-format
 msgid ""
 "Another compositing manager is already running on screen %i on display “%s”."
@@ -682,63 +664,67 @@ msgid ""
 "application to quit entirely."
 msgstr "Можно немного подождать или принудительно завершить работу приложения."
 
-#: src/core/meta-close-dialog-default.c:165
+#: src/core/meta-close-dialog-default.c:164
 msgid "_Force Quit"
 msgstr "Завер_шить"
 
-#: src/core/meta-close-dialog-default.c:165
+#: src/core/meta-close-dialog-default.c:164
 msgid "_Wait"
 msgstr "_Подождать"
 
-#: src/core/meta-context-main.c:553
+#: src/core/meta-context-main.c:555
 msgid "Replace the running window manager"
 msgstr "Заменить запущенный оконный менеджер"
 
-#: src/core/meta-context-main.c:559
+#: src/core/meta-context-main.c:561
 msgid "X Display to use"
 msgstr "Используемый дисплей X"
 
-#: src/core/meta-context-main.c:565
+#: src/core/meta-context-main.c:567
 msgid "Disable connection to session manager"
 msgstr "Запретить подключение к менеджеру сеансов"
 
-#: src/core/meta-context-main.c:571
+#: src/core/meta-context-main.c:573
 msgid "Specify session management ID"
 msgstr "Указать идентификатор управления сеансом"
 
-#: src/core/meta-context-main.c:577
+#: src/core/meta-context-main.c:579
 msgid "Initialize session from savefile"
 msgstr "Инициализировать сеанс из сохранённого файла"
 
-#: src/core/meta-context-main.c:590
+#: src/core/meta-context-main.c:585
+msgid "Make X calls synchronous"
+msgstr "Сделать X-вызовы синхронными"
+
+#: src/core/meta-context-main.c:592
 msgid "Run as a wayland compositor"
 msgstr "Запустить в качестве композитора wayland"
 
-#: src/core/meta-context-main.c:596
+#: src/core/meta-context-main.c:598
 msgid "Run as a nested compositor"
 msgstr "Запустить в качестве встроенного композитора"
 
-#: src/core/meta-context-main.c:602
+#: src/core/meta-context-main.c:604
 msgid "Run wayland compositor without starting Xwayland"
 msgstr "Запуск wayland compositor без запуска Xwayland"
 
-#: src/core/meta-context-main.c:608
+#: src/core/meta-context-main.c:610
 msgid "Specify Wayland display name to use"
 msgstr "Укажите отображаемое имя Wayland для использования"
 
-#: src/core/meta-context-main.c:616
+#: src/core/meta-context-main.c:618
 msgid "Run as a full display server, rather than nested"
 msgstr "Запустить в качестве полноэкранного сервера вместо встроенного"
 
-#: src/core/meta-context-main.c:621
+#: src/core/meta-context-main.c:623
 msgid "Run as a headless display server"
 msgstr "Запуск в качестве сервера отображения без дисплея"
 
-#: src/core/meta-context-main.c:626
+#: src/core/meta-context-main.c:628
 msgid "Add persistent virtual monitor (WxH or WxH@R)"
 msgstr "Добавьте постоянный виртуальный монитор (WxH или WxH@R)"
 
-#: src/core/meta-context-main.c:632
+#: src/core/meta-context-main.c:639
 msgid "Run with X11 backend"
 msgstr "Запуск с бэкендом X11"
 
@@ -761,11 +747,11 @@ msgstr "Переключить монитор"
 msgid "Show on-screen help"
 msgstr "Показать справку на экране"
 
-#: src/core/mutter.c:47
+#: src/core/mutter.c:74
 msgid "Print version"
 msgstr "Вывести версию"
 
-#: src/core/mutter.c:53
+#: src/core/mutter.c:80
 msgid "Mutter plugin to use"
 msgstr "Использовать модуль mutter"
 
@@ -774,7 +760,7 @@ msgstr "Использовать модуль mutter"
 msgid "Workspace %d"
 msgstr "Рабочее место %d"
 
-#: src/core/util.c:148
+#: src/core/util.c:141
 msgid "Mutter was compiled without support for verbose mode"
 msgstr "Mutter был скомпилирован без поддержки режима verbose"
 
@@ -801,7 +787,7 @@ msgstr "Не удалось инициализировать GDK"
 msgid "Failed to open X Window System display “%s”"
 msgstr "Не удалось открыть дисплей X Window System «%s»"
 
-#: src/x11/meta-x11-display.c:1175
+#: src/x11/meta-x11-display.c:1181
 #, c-format
 msgid "Screen %d on display “%s” is invalid"
 msgstr "Экран %d на дисплее «%s» недействителен"
@@ -811,7 +797,7 @@ msgstr "Экран %d на дисплее «%s» недействителен"
 msgid "Format %s not supported"
 msgstr "Формат %s не поддерживается"
 
-#: src/x11/session.c:1845
+#: src/x11/session.c:1823
 msgid ""
 "These windows do not support “save current setup” and will have to be "
 "restarted manually next time you log in."
@@ -824,505 +810,3 @@ msgstr ""
 msgid "%s (on %s)"
 msgstr "%s (на %s)"
 
-#~ msgid "Toggle shaded state"
-#~ msgstr "Переключить затенённое состояние"
-
-#~ msgid ""
-#~ "mutter %s\n"
-#~ "Copyright © 2001-%d Havoc Pennington, Red Hat, Inc., and others\n"
-#~ "This is free software; see the source for copying conditions.\n"
-#~ "There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A "
-#~ "PARTICULAR PURPOSE.\n"
-#~ msgstr ""
-#~ "mutter %s\n"
-#~ "Авторское право © 2001—%d Havoc Pennington, Red Hat, Inc. и другие\n"
-#~ "Это — свободное программное обеспечение; условия копирования указаны в "
-#~ "исходном тексте.\n"
-#~ "Распространяется без каких-либо гарантий, в том числе и БЕЗ гарантий "
-#~ "потребительской стоимости и пригодности для выполнения каких бы то ни "
-#~ "было определённых задач.\n"
-
-#~ msgid "Failed to scan themes directory: %s\n"
-#~ msgstr "Не удалось прочитать каталог тем: %s\n"
-
-#~ msgid ""
-#~ "Could not find a theme! Be sure %s exists and contains the usual themes.\n"
-#~ msgstr ""
-#~ "Не удалось найти тему! Убедитесь, что «%s» существует и содержит обычные "
-#~ "темы.\n"
-
-#~ msgid "Screen %d on display \"%s\" already has a window manager\n"
-#~ msgstr "У экрана %d дисплея «%s» уже есть менеджер окон\n"
-
-#~ msgid "%d x %d"
-#~ msgstr "%d × %d"
-
-#~ msgid "top"
-#~ msgstr "top"
-
-#~ msgid "bottom"
-#~ msgstr "bottom"
-
-#~ msgid "left"
-#~ msgstr "left"
-
-#~ msgid "right"
-#~ msgstr "right"
-
-#~ msgid "frame geometry does not specify \"%s\" dimension"
-#~ msgstr "геометрия рамки не указывает размер «%s»"
-
-#~ msgid "frame geometry does not specify dimension \"%s\" for border \"%s\""
-#~ msgstr "геометрия рамки не указывает размер «%s» для границы «%s»"
-
-#~ msgid "Button aspect ratio %g is not reasonable"
-#~ msgstr "Соотношение сторон кнопки %g недопустимо"
-
-#~ msgid "Frame geometry does not specify size of buttons"
-#~ msgstr "Геометрия рамки не указывает размер кнопок"
-
-#~ msgid "Gradients should have at least two colors"
-#~ msgstr "У градиентов должно быть не меньше двух цветов"
-
-#~ msgid ""
-#~ "GTK custom color specification must have color name and fallback in "
-#~ "parentheses, e.g. gtk:custom(foo,bar); could not parse \"%s\""
-#~ msgstr ""
-#~ "В пользовательской спецификации цвета GTK+ в скобках должно быть указано "
-#~ "имя цвета и значение по умолчанию, например, gtk:custom(foo,bar); не "
-#~ "удалось разобрать «%s»"
-
-#~ msgid ""
-#~ "Invalid character '%c' in color_name parameter of gtk:custom, only A-Za-"
-#~ "z0-9-_ are valid"
-#~ msgstr ""
-#~ "Недопустимый символ «%c» в параметре color_name для gtk:custom; разрешены "
-#~ "только A-Za-z0-9-_"
-
-#~ msgid ""
-#~ "Gtk:custom format is \"gtk:custom(color_name,fallback)\", \"%s\" does not "
-#~ "fit the format"
-#~ msgstr ""
-#~ "Формат Gtk:custom — «gtk:custom(color_name,fallback)»; «%s» не "
-#~ "соответствует формату"
-
-#~ msgid ""
-#~ "GTK color specification must have the state in brackets, e.g. gtk:"
-#~ "fg[NORMAL] where NORMAL is the state; could not parse \"%s\""
-#~ msgstr ""
-#~ "У спецификации цвета GTK+ в скобках должен быть указан режим, например, "
-#~ "gtk:fg[NORMAL], где NORMAL — это режим; не удалось разобрать «%s»"
-
-#~ msgid ""
-#~ "GTK color specification must have a close bracket after the state, e.g. "
-#~ "gtk:fg[NORMAL] where NORMAL is the state; could not parse \"%s\""
-#~ msgstr ""
-#~ "У спецификации цвета GTK+ после указания режима должна быть закрывающая "
-#~ "скобка, например, gtk:fg[NORMAL], где NORMAL — это режим; не удалось "
-#~ "разобрать «%s»"
-
-#~ msgid "Did not understand state \"%s\" in color specification"
-#~ msgstr "Не удалось распознать режим «%s» в спецификации цвета"
-
-#~ msgid "Did not understand color component \"%s\" in color specification"
-#~ msgstr ""
-#~ "Не удалось распознать составную часть цвета «%s» в спецификации цвета"
-
-#~ msgid ""
-#~ "Blend format is \"blend/bg_color/fg_color/alpha\", \"%s\" does not fit "
-#~ "the format"
-#~ msgstr ""
-#~ "Формат определения смешанного цвета — «blend/bg_color/fg_color/alpha»; "
-#~ "«%s» не соответствует формату"
-
-#~ msgid "Could not parse alpha value \"%s\" in blended color"
-#~ msgstr "Не удалось разобрать значение альфа-канала «%s» в смешанном цвете"
-
-#~ msgid "Alpha value \"%s\" in blended color is not between 0.0 and 1.0"
-#~ msgstr ""
-#~ "Значение альфа-канала «%s» в смешанном цвете не входит в диапазон между "
-#~ "0.0 и 1.0"
-
-#~ msgid ""
-#~ "Shade format is \"shade/base_color/factor\", \"%s\" does not fit the "
-#~ "format"
-#~ msgstr ""
-#~ "Формат тени — «shade/base_color/factor»; «%s» не соответствует формату"
-
-#~ msgid "Could not parse shade factor \"%s\" in shaded color"
-#~ msgstr "Не удалось разобрать составную часть тени «%s» в затенённом цвете"
-
-#~ msgid "Shade factor \"%s\" in shaded color is negative"
-#~ msgstr "Составная часть тени «%s» в затенённом цвете отрицательна"
-
-#~ msgid "Could not parse color \"%s\""
-#~ msgstr "Не удалось разобрать цвет «%s»"
-
-#~ msgid "Coordinate expression contains character '%s' which is not allowed"
-#~ msgstr ""
-#~ "Выражение координаты содержит символ «%s», который нельзя использовать"
-
-#~ msgid ""
-#~ "Coordinate expression contains floating point number '%s' which could not "
-#~ "be parsed"
-#~ msgstr ""
-#~ "Выражение координаты содержит число с плавающей запятой «%s», которое не "
-#~ "удалось разобрать"
-
-#~ msgid ""
-#~ "Coordinate expression contains integer '%s' which could not be parsed"
-#~ msgstr ""
-#~ "Выражение координаты содержит целое число «%s», которое не удалось "
-#~ "разобрать"
-
-#~ msgid ""
-#~ "Coordinate expression contained unknown operator at the start of this "
-#~ "text: \"%s\""
-#~ msgstr ""
-#~ "Выражение координаты содержит неизвестный оператор в начале следующего "
-#~ "текста: «%s»"
-
-#~ msgid "Coordinate expression was empty or not understood"
-#~ msgstr "Выражение координаты пустое, или его не удалось распознать"
-
-#~ msgid "Coordinate expression results in division by zero"
-#~ msgstr "Вычисление выражения координаты привело к делению на ноль"
-
-#~ msgid ""
-#~ "Coordinate expression tries to use mod operator on a floating-point number"
-#~ msgstr ""
-#~ "Выражение координаты пытается использовать оператор взятия остатка от "
-#~ "деления для числа с плавающей запятой"
-
-#~ msgid ""
-#~ "Coordinate expression has an operator \"%s\" where an operand was expected"
-#~ msgstr ""
-#~ "В выражении координаты используется оператор «%s» там, где должен быть "
-#~ "операнд"
-
-#~ msgid "Coordinate expression had an operand where an operator was expected"
-#~ msgstr ""
-#~ "В выражении координаты используется операнд там, где должен быть оператор"
-
-#~ msgid "Coordinate expression ended with an operator instead of an operand"
-#~ msgstr "Выражение координаты заканчивается оператором, а не операндом"
-
-#~ msgid ""
-#~ "Coordinate expression has operator \"%c\" following operator \"%c\" with "
-#~ "no operand in between"
-#~ msgstr ""
-#~ "В выражении координаты за оператором «%c» следует оператор «%c», между "
-#~ "ними нет операнда"
-
-#~ msgid "Coordinate expression had unknown variable or constant \"%s\""
-#~ msgstr "В выражении координаты неизвестная переменная или константа «%s»"
-
-#~ msgid "Coordinate expression parser overflowed its buffer."
-#~ msgstr "Произошло переполнение буфера обработчика координат."
-
-#~ msgid ""
-#~ "Coordinate expression had a close parenthesis with no open parenthesis"
-#~ msgstr ""
-#~ "В выражении координаты использованы закрывающие скобки, но нет "
-#~ "соответствующих открывающих скобок"
-
-#~ msgid ""
-#~ "Coordinate expression had an open parenthesis with no close parenthesis"
-#~ msgstr ""
-#~ "В выражении координаты использованы открывающие скобки, но нет "
-#~ "соответствующих закрывающих скобок"
-
-#~ msgid "Coordinate expression doesn't seem to have any operators or operands"
-#~ msgstr "В выражении координаты нет операторов и операндов"
-
-#~ msgid "Theme contained an expression that resulted in an error: %s\n"
-#~ msgstr "В теме было выражение, которое вызвало ошибку: %s\n"
-
-#~ msgid ""
-#~ "<button function=\"%s\" state=\"%s\" draw_ops=\"whatever\"/> must be "
-#~ "specified for this frame style"
-#~ msgstr ""
-#~ "для этого стиля рамки необходимо указать <button function=\"%s\" state="
-#~ "\"%s\" draw_ops=\"что-нибудь\"/>"
-
-#~ msgid ""
-#~ "Missing <frame state=\"%s\" resize=\"%s\" focus=\"%s\" style=\"whatever\"/"
-#~ ">"
-#~ msgstr ""
-#~ "Отсутствует <frame state=\"%s\" resize=\"%s\" focus=\"%s\" style=\"что-"
-#~ "нибудь\"/>"
-
-#~ msgid "Failed to load theme \"%s\": %s\n"
-#~ msgstr "Не удалось загрузить тему «%s»: %s\n"
-
-#~ msgid "No <%s> set for theme \"%s\""
-#~ msgstr "Отсутствует элемент <%s> для темы «%s»"
-
-#~ msgid ""
-#~ "No frame style set for window type \"%s\" in theme \"%s\", add a <window "
-#~ "type=\"%s\" style_set=\"whatever\"/> element"
-#~ msgstr ""
-#~ "Нет стиля рамки для типа окна «%s» в теме «%s», добавьте элемент <window "
-#~ "type=\"%s\" style_set=\"что-нибудь\"/>"
-
-#~ msgid ""
-#~ "User-defined constants must begin with a capital letter; \"%s\" does not"
-#~ msgstr ""
-#~ "Константы, заданные пользователем, должны начинаться с заглавной буквы; "
-#~ "«%s» не начинается с заглавной буквы"
-
-#~ msgid "Constant \"%s\" has already been defined"
-#~ msgstr "Константа «%s» уже задана"
-
-#~ msgid "No \"%s\" attribute on element <%s>"
-#~ msgstr "Отсутствует атрибут «%s» для элемента <%s>"
-
-#~ msgid "Line %d character %d: %s"
-#~ msgstr "Строка %d, символ %d: %s"
-
-#~ msgid "Attribute \"%s\" repeated twice on the same <%s> element"
-#~ msgstr "Атрибут «%s» дважды повторяется в одном и том же элементе <%s>"
-
-#~ msgid "Attribute \"%s\" is invalid on <%s> element in this context"
-#~ msgstr "Атрибут «%s» не может применяться в элементе <%s> в этом контексте"
-
-#~ msgid "Could not parse \"%s\" as an integer"
-#~ msgstr "Не удалось разобрать «%s» как целое число"
-
-#~ msgid "Did not understand trailing characters \"%s\" in string \"%s\""
-#~ msgstr "Не удалось распознать замыкающие символы «%s» в строке «%s»"
-
-#~ msgid "Integer %ld must be positive"
-#~ msgstr "Целое число %ld должно быть положительным"
-
-#~ msgid "Integer %ld is too large, current max is %d"
-#~ msgstr "Целое число %ld слишком большое, текущий максимум равен %d"
-
-#~ msgid "Could not parse \"%s\" as a floating point number"
-#~ msgstr "Не удалось разобрать «%s» как число с плавающей запятой"
-
-#~ msgid "Boolean values must be \"true\" or \"false\" not \"%s\""
-#~ msgstr "Логические значения должны быть «true» или «false», а не «%s»"
-
-#~ msgid "Angle must be between 0.0 and 360.0, was %g\n"
-#~ msgstr "Угол должен быть от 0,0 до 360,0, а был %g\n"
-
-#~ msgid ""
-#~ "Alpha must be between 0.0 (invisible) and 1.0 (fully opaque), was %g\n"
-#~ msgstr ""
-#~ "Альфа-канал должен быть от 0,0 (невидимость) до 1,0 (полная "
-#~ "непрозрачность), а был %g\n"
-
-#~ msgid ""
-#~ "Invalid title scale \"%s\" (must be one of xx-small,x-small,small,medium,"
-#~ "large,x-large,xx-large)\n"
-#~ msgstr ""
-#~ "Масштаб заголовка «%s» (возможные значения: xx-small, x-small, small, "
-#~ "medium, large, x-large, xx-large) недопустим\n"
-
-#~ msgid "<%s> name \"%s\" used a second time"
-#~ msgstr "Имя «%s» элемента <%s> использовалось второй раз"
-
-#~ msgid "<%s> parent \"%s\" has not been defined"
-#~ msgstr "Родительский объект «%s» элемента <%s> не определён"
-
-#~ msgid "<%s> geometry \"%s\" has not been defined"
-#~ msgstr "Геометрия «%s» объекта <%s> не определена"
-
-#~ msgid "<%s> must specify either a geometry or a parent that has a geometry"
-#~ msgstr ""
-#~ "В элементе <%s> должны быть определены либо геометрия, либо родительский "
-#~ "объект, имеющий геометрию"
-
-#~ msgid "You must specify a background for an alpha value to be meaningful"
-#~ msgstr "Необходимо задать фон, чтобы значение альфа-канала имело смысл"
-
-#~ msgid "Unknown type \"%s\" on <%s> element"
-#~ msgstr "Тип «%s» для элемента <%s> неизвестен"
-
-#~ msgid "Unknown style_set \"%s\" on <%s> element"
-#~ msgstr "Параметр style_set «%s» для элемента <%s> неизвестен"
-
-#~ msgid "Window type \"%s\" has already been assigned a style set"
-#~ msgstr "Типу окна «%s» уже был приписан набор стилей"
-
-#~ msgid "Element <%s> is not allowed below <%s>"
-#~ msgstr "Использование элемента <%s> под <%s> недопустимо"
-
-#~ msgid ""
-#~ "Cannot specify both \"button_width\"/\"button_height\" and \"aspect_ratio"
-#~ "\" for buttons"
-#~ msgstr ""
-#~ "Невозможно одновременно задать параметры \"button_width\"/\"button_height"
-#~ "\" и \"aspect_ratio\" для кнопок"
-
-#~ msgid "Distance \"%s\" is unknown"
-#~ msgstr "Расстояние «%s» неизвестно"
-
-#~ msgid "Aspect ratio \"%s\" is unknown"
-#~ msgstr "Соотношение сторон «%s» неизвестно"
-
-#~ msgid "Border \"%s\" is unknown"
-#~ msgstr "Рамка «%s» неизвестна"
-
-#~ msgid "No \"start_angle\" or \"from\" attribute on element <%s>"
-#~ msgstr "Нет ни атрибута «start_angle», ни атрибута «from» для элемента <%s>"
-
-#~ msgid "No \"extent_angle\" or \"to\" attribute on element <%s>"
-#~ msgstr "Нет ни атрибута «extent_angle», ни атрибута «to» для элемента <%s>"
-
-#~ msgid "Did not understand value \"%s\" for type of gradient"
-#~ msgstr "Не удалось распознать значение «%s» для типа градиента"
-
-#~ msgid "Did not understand fill type \"%s\" for <%s> element"
-#~ msgstr "Не удалось распознать тип заливки «%s» для элемента <%s> "
-
-#~ msgid "Did not understand state \"%s\" for <%s> element"
-#~ msgstr "Не удалось распознать состояние «%s» для элемента <%s> "
-
-#~ msgid "Did not understand shadow \"%s\" for <%s> element"
-#~ msgstr "Не удалось распознать тень «%s» для элемента <%s>"
-
-#~ msgid "Did not understand arrow \"%s\" for <%s> element"
-#~ msgstr "Не удалось распознать стрелку «%s» для элемента <%s>"
-
-#~ msgid "No <draw_ops> called \"%s\" has been defined"
-#~ msgstr "Параметр <draw_ops> с именем «%s» не задан"
-
-#~ msgid "Including draw_ops \"%s\" here would create a circular reference"
-#~ msgstr "Вставка сюда параметра draw_ops «%s» создаст циклическую ссылку"
-
-#~ msgid "Unknown position \"%s\" for frame piece"
-#~ msgstr "Неизвестная позиция «%s» для участка рамки"
-
-#~ msgid "Frame style already has a piece at position %s"
-#~ msgstr "У стиля рамки уже есть участок в позиции %s"
-
-#~ msgid "No <draw_ops> with the name \"%s\" has been defined"
-#~ msgstr "Не задан ни один параметр <draw_ops> с именем «%s»"
-
-#~ msgid "Unknown function \"%s\" for button"
-#~ msgstr "Неизвестная функция «%s» для кнопки"
-
-#~ msgid "Button function \"%s\" does not exist in this version (%d, need %d)"
-#~ msgstr ""
-#~ "Функция кнопки «%s» не существует в этой версии (%d, необходима версия %d)"
-
-#~ msgid "Unknown state \"%s\" for button"
-#~ msgstr "Неизвестное состояние «%s» для кнопки"
-
-#~ msgid "Frame style already has a button for function %s state %s"
-#~ msgstr "У стиля рамки уже есть кнопка для режима %s функции %s"
-
-#~ msgid "\"%s\" is not a valid value for focus attribute"
-#~ msgstr "«%s» — недопустимое значение для атрибута «focus»"
-
-#~ msgid "\"%s\" is not a valid value for state attribute"
-#~ msgstr "«%s» — недопустимое значение для атрибута «state»"
-
-#~ msgid "A style called \"%s\" has not been defined"
-#~ msgstr "Стиль с именем «%s» не задан"
-
-#~ msgid "\"%s\" is not a valid value for resize attribute"
-#~ msgstr "«%s» — недопустимое значение для атрибута «resize»"
-
-#~ msgid ""
-#~ "Should not have \"resize\" attribute on <%s> element for maximized/shaded "
-#~ "states"
-#~ msgstr ""
-#~ "Не следует использовать атрибут «resize» в элементе <%s> для развернутого "
-#~ "и скрученного состояний"
-
-#~ msgid ""
-#~ "Should not have \"resize\" attribute on <%s> element for maximized states"
-#~ msgstr ""
-#~ "Не следует использовать атрибут «resize» в элементе <%s> для развёрнутых "
-#~ "состояний"
-
-#~ msgid "Style has already been specified for state %s resize %s focus %s"
-#~ msgstr "Для атрибутов state %s resize %s focus %s стиль уже задан"
-
-#~ msgid "Style has already been specified for state %s focus %s"
-#~ msgstr "Для атрибутов state %s focus %s стиль уже задан"
-
-#~ msgid ""
-#~ "Can't have a two draw_ops for a <piece> element (theme specified a "
-#~ "draw_ops attribute and also a <draw_ops> element, or specified two "
-#~ "elements)"
-#~ msgstr ""
-#~ "Невозможно использовать два параметра draw_ops для элемента <piece> (в "
-#~ "теме указан атрибут draw_ops и элемент <draw_ops> или указаны два "
-#~ "элемента)"
-
-#~ msgid ""
-#~ "Can't have a two draw_ops for a <button> element (theme specified a "
-#~ "draw_ops attribute and also a <draw_ops> element, or specified two "
-#~ "elements)"
-#~ msgstr ""
-#~ "Невозможно использовать два параметра draw_ops для элемента <button> (в "
-#~ "теме указан атрибут draw_ops и элемент <draw_ops> или указаны два "
-#~ "элемента)"
-
-#~ msgid ""
-#~ "Can't have a two draw_ops for a <menu_icon> element (theme specified a "
-#~ "draw_ops attribute and also a <draw_ops> element, or specified two "
-#~ "elements)"
-#~ msgstr ""
-#~ "Невозможно использовать два параметра draw_ops для элемента <menu_icon> "
-#~ "(в теме указан атрибут draw_ops и элемент <draw_ops> или указаны два "
-#~ "элемента)"
-
-#~ msgid "Bad version specification '%s'"
-#~ msgstr "Неверная спецификация версии «%s»"
-
-#~ msgid ""
-#~ "\"version\" attribute cannot be used in metacity-theme-1.xml or metacity-"
-#~ "theme-2.xml"
-#~ msgstr ""
-#~ "Атрибут «version» не может использоваться в metacity-theme-1.xml или "
-#~ "metacity-theme-2.xml"
-
-#~ msgid ""
-#~ "Theme requires version %s but latest supported theme version is %d.%d"
-#~ msgstr "Тема требует версию %s, но последняя поддерживаемая версия — %d.%d"
-
-#~ msgid "Outermost element in theme must be <metacity_theme> not <%s>"
-#~ msgstr ""
-#~ "Элемент верхнего уровня в теме должен быть <metacity_theme>, а не <%s>"
-
-#~ msgid ""
-#~ "Element <%s> is not allowed inside a name/author/date/description element"
-#~ msgstr ""
-#~ "Использование элемента <%s> внутри элементов name/author/date/description "
-#~ "недопустимо"
-
-#~ msgid "Element <%s> is not allowed inside a <constant> element"
-#~ msgstr "Использование элемента <%s> внутри элемента <constant> недопустимо"
-
-#~ msgid ""
-#~ "Element <%s> is not allowed inside a distance/border/aspect_ratio element"
-#~ msgstr ""
-#~ "Использование элемента <%s> внутри элементов distance/border/aspect_ratio "
-#~ "недопустимо"
-
-#~ msgid "Element <%s> is not allowed inside a draw operation element"
-#~ msgstr ""
-#~ "Использование элемента <%s> внутри элемента draw operation недопустимо"
-
-#~ msgid "Element <%s> is not allowed inside a <%s> element"
-#~ msgstr "Использование элемента <%s> внутри элемента <%s> недопустимо"
-
-#~ msgid "No draw_ops provided for frame piece"
-#~ msgstr "Не задан параметр draw_ops для участка рамки"
-
-#~ msgid "No draw_ops provided for button"
-#~ msgstr "Не задан параметр draw_ops для кнопки"
-
-#~ msgid "No text is allowed inside element <%s>"
-#~ msgstr "Использование текста внутри элемента <%s> недопустимо"
-
-#~ msgid "<%s> specified twice for this theme"
-#~ msgstr "<%s> указан для этой темы дважды"
-
-#~ msgid "Failed to find a valid file for theme %s\n"
-#~ msgstr "Не удалось найти допустимый файл для темы %s\n"
diff --git a/po/uk.po b/po/uk.po
index 1b273b819..76c793664 100644
--- a/po/uk.po
+++ b/po/uk.po
@@ -2,13 +2,13 @@
 # Yuriy Syrota <rasta@renome.rovno.ua>, 2001, 2002.
 # Maxim Dziumanenko <dziumanenko@gmail.com>, 2004-2008.
 # Daniel Korostil <ted.korostiled@gmail.com>, 2014, 2015.
-# Yuri Chornoivan <yurchor@ukr.net>, 2020, 2021.
+# Yuri Chornoivan <yurchor@ukr.net>, 2020, 2021, 2022.
 msgid ""
 msgstr ""
 "Project-Id-Version: metacity\n"
 "Report-Msgid-Bugs-To: https://gitlab.gnome.org/GNOME/mutter/issues\n"
-"POT-Creation-Date: 2021-07-19 15:55+0000\n"
-"PO-Revision-Date: 2021-07-19 19:02+0300\n"
+"POT-Creation-Date: 2022-01-05 17:17+0000\n"
+"PO-Revision-Date: 2022-01-05 21:49+0200\n"
 "Last-Translator: Yuri Chornoivan <yurchor@ukr.net>\n"
 "Language-Team: Ukrainian <trans-uk@lists.fedoraproject.org>\n"
 "Language: uk\n"
@@ -179,10 +179,6 @@ msgstr "Система"
 msgid "Show the run command prompt"
 msgstr "Показати запуск командного рядка"
 
-#: data/50-mutter-system.xml:10
-msgid "Show the activities overview"
-msgstr "Показати огляд активності"
-
 #: data/50-mutter-wayland.xml:8
 msgid "Restore the keyboard shortcuts"
 msgstr "Відновити клавіатурні скорочення"
@@ -252,11 +248,11 @@ msgstr "Розгорнути вікно на весь екран вертика
 msgid "Maximize window horizontally"
 msgstr "Розгорнути вікно на весь екран горизонтально"
 
-#: data/50-mutter-windows.xml:41 data/org.gnome.mutter.gschema.xml.in:166
+#: data/50-mutter-windows.xml:41 data/org.gnome.mutter.gschema.xml.in:179
 msgid "View split on left"
 msgstr "Перегляд розділити ліворуч"
 
-#: data/50-mutter-windows.xml:45 data/org.gnome.mutter.gschema.xml.in:171
+#: data/50-mutter-windows.xml:45 data/org.gnome.mutter.gschema.xml.in:184
 msgid "View split on right"
 msgstr "Перегляд розділити праворуч"
 
@@ -264,12 +260,12 @@ msgstr "Перегляд розділити праворуч"
 msgid "Mutter"
 msgstr "Mutter"
 
-#: data/org.gnome.mutter.gschema.xml.in:7
+#: data/org.gnome.mutter.gschema.xml.in:16
 msgid "Modifier to use for extended window management operations"
 msgstr ""
 "Модифікатор, що використовується для розширених дій віконного менеджера"
 
-#: data/org.gnome.mutter.gschema.xml.in:8
+#: data/org.gnome.mutter.gschema.xml.in:17
 msgid ""
 "This key will initiate the “overlay”, which is a combination window overview "
 "and application launching system. The default is intended to be the “Windows "
@@ -280,11 +276,11 @@ msgstr ""
 "запуску програм. Типово на це призначено клавішу «Win» в обладнанні. "
 "Очікується, що це буде прив'язка або типова, або порожній рядок."
 
-#: data/org.gnome.mutter.gschema.xml.in:20
+#: data/org.gnome.mutter.gschema.xml.in:29
 msgid "Attach modal dialogs"
 msgstr "Долучити модальні вікна"
 
-#: data/org.gnome.mutter.gschema.xml.in:21
+#: data/org.gnome.mutter.gschema.xml.in:30
 msgid ""
 "When true, instead of having independent titlebars, modal dialogs appear "
 "attached to the titlebar of the parent window and are moved together with "
@@ -294,11 +290,11 @@ msgstr ""
 "долучено до батьківського вікна заголовка і пересунуто разом з батьківських "
 "вікном."
 
-#: data/org.gnome.mutter.gschema.xml.in:30
+#: data/org.gnome.mutter.gschema.xml.in:39
 msgid "Enable edge tiling when dropping windows on screen edges"
 msgstr "Увімкнути розбиття країв, коли кладуться вікна на краї екрана"
 
-#: data/org.gnome.mutter.gschema.xml.in:31
+#: data/org.gnome.mutter.gschema.xml.in:40
 msgid ""
 "If enabled, dropping windows on vertical screen edges maximizes them "
 "vertically and resizes them horizontally to cover half of the available "
@@ -308,11 +304,11 @@ msgstr ""
 "змінить їхній розмір горизонтально, щоб покрити половину доступної ділянки. "
 "Перекидання вікон на верхівку екрана розгорне їх повністю."
 
-#: data/org.gnome.mutter.gschema.xml.in:40
+#: data/org.gnome.mutter.gschema.xml.in:49
 msgid "Workspaces are managed dynamically"
 msgstr "Робочі простори організовуються динамічно"
 
-#: data/org.gnome.mutter.gschema.xml.in:41
+#: data/org.gnome.mutter.gschema.xml.in:50
 msgid ""
 "Determines whether workspaces are managed dynamically or whether there’s a "
 "static number of workspaces (determined by the num-workspaces key in org."
@@ -322,11 +318,11 @@ msgstr ""
 "кількість просторів (визначено ключем num-workspaces у org.gnome.desktop.wm."
 "preferences)."
 
-#: data/org.gnome.mutter.gschema.xml.in:50
+#: data/org.gnome.mutter.gschema.xml.in:59
 msgid "Workspaces only on primary"
 msgstr "Робочий простір лише на первинному"
 
-#: data/org.gnome.mutter.gschema.xml.in:51
+#: data/org.gnome.mutter.gschema.xml.in:60
 msgid ""
 "Determines whether workspace switching should happen for windows on all "
 "monitors or only for windows on the primary monitor."
@@ -334,11 +330,11 @@ msgstr ""
 "Визначає, чи перемикання робочого простору повинно здійснюватись для вікон "
 "на всіх моніторах, чи лише для вікон на первинному моніторі."
 
-#: data/org.gnome.mutter.gschema.xml.in:59
+#: data/org.gnome.mutter.gschema.xml.in:68
 msgid "No tab popup"
 msgstr "Без контекстних вкладок"
 
-#: data/org.gnome.mutter.gschema.xml.in:60
+#: data/org.gnome.mutter.gschema.xml.in:69
 msgid ""
 "Determines whether the use of popup and highlight frame should be disabled "
 "for window cycling."
@@ -346,11 +342,11 @@ msgstr ""
 "Визначає, чи слід вимкнути виринання і підкреслювання рамки для повторюваних "
 "вікон. "
 
-#: data/org.gnome.mutter.gschema.xml.in:68
+#: data/org.gnome.mutter.gschema.xml.in:77
 msgid "Delay focus changes until the pointer stops moving"
 msgstr "Затримувати зміни фокусу, поки вказівник не перестане рухатись"
 
-#: data/org.gnome.mutter.gschema.xml.in:69
+#: data/org.gnome.mutter.gschema.xml.in:78
 msgid ""
 "If set to true, and the focus mode is either “sloppy” or “mouse” then the "
 "focus will not be changed immediately when entering a window, but only after "
@@ -360,11 +356,11 @@ msgstr ""
 "будуть негайні, коли переходите на вікно, але тільки після того, як "
 "вказівник не рухатиметься."
 
-#: data/org.gnome.mutter.gschema.xml.in:79
+#: data/org.gnome.mutter.gschema.xml.in:88
 msgid "Draggable border width"
 msgstr "Перетяжна ширина меж"
 
-#: data/org.gnome.mutter.gschema.xml.in:80
+#: data/org.gnome.mutter.gschema.xml.in:89
 msgid ""
 "The amount of total draggable borders. If the theme’s visible borders are "
 "not enough, invisible borders will be added to meet this value."
@@ -372,11 +368,11 @@ msgstr ""
 "Загальний об'єм перетяжних меж. Якщо видимих меж теми не вистачає, буде "
 "використано це значення з невидимих меж."
 
-#: data/org.gnome.mutter.gschema.xml.in:89
+#: data/org.gnome.mutter.gschema.xml.in:98
 msgid "Auto maximize nearly monitor sized windows"
 msgstr "Автоматично розгортати вікна з розміром екрана"
 
-#: data/org.gnome.mutter.gschema.xml.in:90
+#: data/org.gnome.mutter.gschema.xml.in:99
 msgid ""
 "If enabled, new windows that are initially the size of the monitor "
 "automatically get maximized."
@@ -384,21 +380,39 @@ msgstr ""
 "Якщо вказано, нові вікна, які запущено в розмірі екрана, автоматично "
 "розгортаються на ввесь екран."
 
-#: data/org.gnome.mutter.gschema.xml.in:98
+#: data/org.gnome.mutter.gschema.xml.in:107
 msgid "Place new windows in the center"
 msgstr "Помістити нове вікно в центр"
 
-#: data/org.gnome.mutter.gschema.xml.in:99
+#: data/org.gnome.mutter.gschema.xml.in:108
 msgid ""
 "When true, the new windows will always be put in the center of the active "
 "screen of the monitor."
 msgstr "Якщо вказано, нові вікна будуть завжди в центрі чинного екрана."
 
-#: data/org.gnome.mutter.gschema.xml.in:107
+#: data/org.gnome.mutter.gschema.xml.in:117
 msgid "Enable experimental features"
 msgstr "Увімкнути експериментальні можливості"
 
-#: data/org.gnome.mutter.gschema.xml.in:108
+#: data/org.gnome.mutter.gschema.xml.in:118
+#| msgid ""
+#| "To enable experimental features, add the feature keyword to the list. "
+#| "Whether the feature requires restarting the compositor depends on the "
+#| "given feature. Any experimental feature is not required to still be "
+#| "available, or configurable. Don’t expect adding anything in this setting "
+#| "to be future proof. Currently possible keywords: • “scale-monitor-"
+#| "framebuffer” — makes mutter default to layout logical monitors in a "
+#| "logical pixel coordinate space, while scaling monitor framebuffers "
+#| "instead of window content, to manage HiDPI monitors. Does not require a "
+#| "restart. • “kms-modifiers” — makes mutter always advertise valid buffer "
+#| "modifiers on Wayland. This is currently not the case when using the i915 "
+#| "driver. Does not require a restart. • “rt-scheduler” — makes mutter "
+#| "request a low priority real-time scheduling. Requires a restart. • “dma-"
+#| "buf-screen-sharing” — enables DMA buffered screen sharing. This is "
+#| "already enabled by default when using the i915 driver, but disabled for "
+#| "everything else. Requires a restart. • “autoclose-xwayland” — "
+#| "automatically terminates Xwayland if all relevant X11 clients are gone. "
+#| "Does not require a restart."
 msgid ""
 "To enable experimental features, add the feature keyword to the list. "
 "Whether the feature requires restarting the compositor depends on the given "
@@ -407,13 +421,15 @@ msgid ""
 "proof. Currently possible keywords: • “scale-monitor-framebuffer” — makes "
 "mutter default to layout logical monitors in a logical pixel coordinate "
 "space, while scaling monitor framebuffers instead of window content, to "
-"manage HiDPI monitors. Does not require a restart. • “rt-scheduler” — makes "
-"mutter request a low priority real-time scheduling. The executable or user "
-"must have CAP_SYS_NICE. Requires a restart. • “dma-buf-screen-sharing\" — "
-"enables DMA buffered screen sharing. This is already enabled by default when "
-"using the i915 driver, but disabled for everything else. Requires a restart. "
-"• “autoclose-xwayland” — automatically terminates Xwayland if all relevant "
-"X11 clients are gone. Does not require a restart."
+"manage HiDPI monitors. Does not require a restart. • “kms-modifiers” — makes "
+"mutter always advertise valid buffer modifiers on Wayland. This is currently "
+"not the case when using the i915 driver. Requires a restart. • “rt-"
+"scheduler” — makes mutter request a low priority real-time scheduling. "
+"Requires a restart. • “dma-buf-screen-sharing” — enables DMA buffered screen "
+"sharing. This is already enabled by default when using the i915 driver, but "
+"disabled for everything else. Requires a restart. • “autoclose-xwayland” — "
+"automatically terminates Xwayland if all relevant X11 clients are gone. Does "
+"not require a restart."
 msgstr ""
 "Щоб увімкнути експериментальну можливість, додайте до списку ключове слово "
 "можливості. Те, чи потребуватиме вмикання можливості перезапуску "
@@ -424,30 +440,31 @@ msgstr ""
 "слова: • «scale-monitor-framebuffer» — наказує mutter типово розташовувати "
 "логічні монітори у координатному просторі логічних пікселів, масштабуючи "
 "буфери кадрів моніторів, замість вмісту вікон. Призначено для роботи із "
-"моніторами із високою роздільною здатністю. Не потребує перезапуску "
-"композитора. • «rt-scheduler» — наказати mutter надсилати до системи запит "
-"щодо низькопріоритетного планування режиму реального часу. Для виконуваного "
-"файла або запису користувача має бути встановлено CAP_SYS_NICE. Потребує "
-"перезапуску композитора. • “dma-buf-screen-sharing\" — вмикає спільне "
-"використання буферизованих екранів DMA. Типово вже увімкнено, якщо "
-"використано драйвер i915, але вимкнено для усіх інших драйверів. Потребує "
-"перезапуску композитора. • «autoclose-xwayland» — автоматично перериває "
-"роботу Xwayland, якщо завершать роботу усі відповідні клієнти X11. Не "
-"потребує перезапуску композитора."
-
-#: data/org.gnome.mutter.gschema.xml.in:143
+"моніторами із високою роздільною здатністю. Не потребує перезапуску. • «kms-"
+"modifiers» — наказує mutter завжди надавати чинні модифікатори буфера у "
+"Wayland. У поточній версії такі модифікатори не надаються при використанні "
+"драйвера i915. Потребує перезапуску композитора. • «rt-scheduler» — "
+"наказати mutter надсилати до системи запит щодо низькопріоритетного "
+"планування режиму реального часу. Потребує перезапуску композитора. • “dma-"
+"buf-screen-sharing\" — вмикає спільне використання буферизованих екранів "
+"DMA. Типово вже увімкнено, якщо використано драйвер i915, але вимкнено для "
+"усіх інших драйверів. Потребує перезапуску композитора. • «autoclose-"
+"xwayland» — автоматично перериває роботу Xwayland, якщо завершать роботу усі "
+"відповідні клієнти X11. Не потребує перезапуску композитора."
+
+#: data/org.gnome.mutter.gschema.xml.in:156
 msgid "Modifier to use to locate the pointer"
 msgstr "Модифікатор для пошуку вказівника"
 
-#: data/org.gnome.mutter.gschema.xml.in:144
+#: data/org.gnome.mutter.gschema.xml.in:157
 msgid "This key will initiate the “locate pointer” action."
 msgstr "Ця комбінація ініціює дію «встановити розташування вказівника»"
 
-#: data/org.gnome.mutter.gschema.xml.in:151
+#: data/org.gnome.mutter.gschema.xml.in:164
 msgid "Timeout for check-alive ping"
 msgstr "Інтервал між послідовними перевірками працездатності"
 
-#: data/org.gnome.mutter.gschema.xml.in:152
+#: data/org.gnome.mutter.gschema.xml.in:165
 msgid ""
 "Number of milliseconds a client has to respond to a ping request in order to "
 "not be detected as frozen. Using 0 will disable the alive check completely."
@@ -456,19 +473,19 @@ msgstr ""
 "запит, щоб вважатися працездатним. Скористайтеся значенням 0, щоб повністю "
 "вимкнути перевірку працездатності."
 
-#: data/org.gnome.mutter.gschema.xml.in:176
+#: data/org.gnome.mutter.gschema.xml.in:189
 msgid "Select window from tab popup"
 msgstr "Вибрати вікно з контекстних вкладок"
 
-#: data/org.gnome.mutter.gschema.xml.in:181
+#: data/org.gnome.mutter.gschema.xml.in:194
 msgid "Cancel tab popup"
 msgstr "Скасувати контекстні вкладки"
 
-#: data/org.gnome.mutter.gschema.xml.in:186
+#: data/org.gnome.mutter.gschema.xml.in:199
 msgid "Switch monitor configurations"
 msgstr "Перемкнути налаштування монітора"
 
-#: data/org.gnome.mutter.gschema.xml.in:191
+#: data/org.gnome.mutter.gschema.xml.in:204
 msgid "Rotates the built-in monitor configuration"
 msgstr "Зміна конфігурації вбудованого монітора"
 
@@ -600,25 +617,25 @@ msgstr ""
 "не впливає, якщо Xwayland було зібрано без підтримки вибраних розширень. Для "
 "набуття змінами у цьому параметрі чинності Xwayland слід перезапустити."
 
-#: src/backends/meta-monitor.c:235
+#: src/backends/meta-monitor.c:246
 msgid "Built-in display"
 msgstr "Вбудований екран"
 
-#: src/backends/meta-monitor.c:264
+#: src/backends/meta-monitor.c:275
 msgid "Unknown"
 msgstr "Невідомо"
 
-#: src/backends/meta-monitor.c:266
+#: src/backends/meta-monitor.c:277
 msgid "Unknown Display"
 msgstr "Невідомий екран"
 
-#: src/backends/meta-monitor.c:274
+#: src/backends/meta-monitor.c:285
 #, c-format
 msgctxt "This is a monitor vendor name, followed by a size in inches, like 'Dell 15\"'"
 msgid "%s %s"
 msgstr "%s %s"
 
-#: src/backends/meta-monitor.c:282
+#: src/backends/meta-monitor.c:293
 #, c-format
 msgctxt ""
 "This is a monitor vendor name followed by product/model name where size in "
@@ -631,29 +648,9 @@ msgstr "%s %s"
 msgid "Compositor"
 msgstr "Композитор"
 
-#: src/backends/x11/meta-clutter-backend-x11.c:237
-#| msgid "X Display to use"
-msgid "X display to use"
-msgstr "Дисплей сервера X, який буде використано"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:243
-#| msgid "X Display to use"
-msgid "X screen to use"
-msgstr "X-екран, яким слід скористатися"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:248
-#: src/core/meta-context-main.c:583
-msgid "Make X calls synchronous"
-msgstr "Зробити виклики X синхронними"
-
-#: src/backends/x11/meta-clutter-backend-x11.c:254
-msgid "Disable XInput support"
-msgstr ""
-"Вимкнути підтримку XInput"
-
 #. This probably means that a non-WM compositor like xcompmgr is running;
 #. * we have no way to get it to exit
-#: src/compositor/compositor.c:513
+#: src/compositor/compositor.c:504
 #, c-format
 msgid ""
 "Another compositing manager is already running on screen %i on display “%s”."
@@ -680,63 +677,67 @@ msgid ""
 msgstr ""
 "Можете трошки зачекати відновлення активності або примусово закрити програму."
 
-#: src/core/meta-close-dialog-default.c:165
+#: src/core/meta-close-dialog-default.c:164
 msgid "_Force Quit"
 msgstr "_Завершити примусово"
 
-#: src/core/meta-close-dialog-default.c:165
+#: src/core/meta-close-dialog-default.c:164
 msgid "_Wait"
 msgstr "_Зачекати"
 
-#: src/core/meta-context-main.c:553
+#: src/core/meta-context-main.c:555
 msgid "Replace the running window manager"
 msgstr "Замінити запущений віконний менеджер"
 
-#: src/core/meta-context-main.c:559
+#: src/core/meta-context-main.c:561
 msgid "X Display to use"
 msgstr "Дисплей X"
 
-#: src/core/meta-context-main.c:565
+#: src/core/meta-context-main.c:567
 msgid "Disable connection to session manager"
 msgstr "Вимкнути з'єднання з менеджером сеансу"
 
-#: src/core/meta-context-main.c:571
+#: src/core/meta-context-main.c:573
 msgid "Specify session management ID"
 msgstr "Вказати ідентифікатор сеансу"
 
-#: src/core/meta-context-main.c:577
+#: src/core/meta-context-main.c:579
 msgid "Initialize session from savefile"
 msgstr "Розпочати сеанс зі збереженого файла"
 
-#: src/core/meta-context-main.c:590
+#: src/core/meta-context-main.c:585
+msgid "Make X calls synchronous"
+msgstr "Зробити виклики X синхронними"
+
+#: src/core/meta-context-main.c:592
 msgid "Run as a wayland compositor"
 msgstr "запустити як композитор wayland"
 
-#: src/core/meta-context-main.c:596
+#: src/core/meta-context-main.c:598
 msgid "Run as a nested compositor"
 msgstr "Запустити як вкладений композитор"
 
-#: src/core/meta-context-main.c:602
+#: src/core/meta-context-main.c:604
 msgid "Run wayland compositor without starting Xwayland"
 msgstr "Запустити композитор wayland без запуску Xwayland"
 
-#: src/core/meta-context-main.c:608
+#: src/core/meta-context-main.c:610
 msgid "Specify Wayland display name to use"
 msgstr "Вказати назву дисплея Wayland, якою слід скористатися"
 
-#: src/core/meta-context-main.c:616
+#: src/core/meta-context-main.c:618
 msgid "Run as a full display server, rather than nested"
 msgstr "Запустити як повноцінний сервер, а не вкладений"
 
-#: src/core/meta-context-main.c:621
+#: src/core/meta-context-main.c:623
 msgid "Run as a headless display server"
 msgstr "Запустити у форматі сервера без дисплея"
 
-#: src/core/meta-context-main.c:626
+#: src/core/meta-context-main.c:628
 msgid "Add persistent virtual monitor (WxH or WxH@R)"
 msgstr "Додати сталий віртуальний монітор (ШxВ або ШxВ@Ч)"
 
-#: src/core/meta-context-main.c:632
+#: src/core/meta-context-main.c:639
 msgid "Run with X11 backend"
 msgstr "Запустити із модулем X11"
 
@@ -759,11 +760,11 @@ msgstr "Перемкнути монітор"
 msgid "Show on-screen help"
 msgstr "Показати довідку на екрані"
 
-#: src/core/mutter.c:47
+#: src/core/mutter.c:74
 msgid "Print version"
 msgstr "Показати версію"
 
-#: src/core/mutter.c:53
+#: src/core/mutter.c:80
 msgid "Mutter plugin to use"
 msgstr "Додатки Clutter для використання"
 
@@ -772,7 +773,7 @@ msgstr "Додатки Clutter для використання"
 msgid "Workspace %d"
 msgstr "Робочий простір %d"
 
-#: src/core/util.c:148
+#: src/core/util.c:141
 msgid "Mutter was compiled without support for verbose mode"
 msgstr "Mutter зібрано без підтримки докладного режиму"
 
@@ -799,7 +800,7 @@ msgstr "Не вдалося ініціалізувати GDK"
 msgid "Failed to open X Window System display “%s”"
 msgstr "Не вдалося відкрити дисплей віконної системи X «%s»"
 
-#: src/x11/meta-x11-display.c:1175
+#: src/x11/meta-x11-display.c:1181
 #, c-format
 msgid "Screen %d on display “%s” is invalid"
 msgstr "Екран %d на дисплеї «%s» є некоректним"
@@ -809,7 +810,7 @@ msgstr "Екран %d на дисплеї «%s» є некоректним"
 msgid "Format %s not supported"
 msgstr "Підтримки формату %s не передбачено"
 
-#: src/x11/session.c:1845
+#: src/x11/session.c:1823
 msgid ""
 "These windows do not support “save current setup” and will have to be "
 "restarted manually next time you log in."
@@ -822,6 +823,20 @@ msgstr ""
 msgid "%s (on %s)"
 msgstr "%s (на %s)"
 
+#~ msgid "Show the activities overview"
+#~ msgstr "Показати огляд активності"
+
+#~| msgid "X Display to use"
+#~ msgid "X display to use"
+#~ msgstr "Дисплей сервера X, який буде використано"
+
+#~| msgid "X Display to use"
+#~ msgid "X screen to use"
+#~ msgstr "X-екран, яким слід скористатися"
+
+#~ msgid "Disable XInput support"
+#~ msgstr "Вимкнути підтримку XInput"
+
 #~ msgid ""
 #~ "mutter %s\n"
 #~ "Copyright © 2001-%d Havoc Pennington, Red Hat, Inc., and others\n"
diff --git a/src/backends/meta-backend-private.h b/src/backends/meta-backend-private.h
index 555239157..546c612e2 100644
--- a/src/backends/meta-backend-private.h
+++ b/src/backends/meta-backend-private.h
@@ -106,6 +106,8 @@ struct _MetaBackendClass
 
   void (* set_pointer_constraint) (MetaBackend           *backend,
                                    MetaPointerConstraint *constraint);
+
+  gboolean (* is_headless) (MetaBackend *backend);
 };
 
 void meta_backend_destroy (MetaBackend *backend);
@@ -115,6 +117,7 @@ void meta_backend_prepare_shutdown (MetaBackend *backend);
 META_EXPORT_TEST
 ClutterBackend * meta_backend_get_clutter_backend (MetaBackend *backend);
 
+META_EXPORT_TEST
 ClutterSeat * meta_backend_get_default_seat (MetaBackend *bakcend);
 
 MetaIdleMonitor * meta_backend_get_idle_monitor (MetaBackend        *backend,
@@ -122,8 +125,6 @@ MetaIdleMonitor * meta_backend_get_idle_monitor (MetaBackend        *backend,
 
 MetaIdleManager * meta_backend_get_idle_manager (MetaBackend *backend);
 
-META_EXPORT_TEST
-MetaMonitorManager * meta_backend_get_monitor_manager (MetaBackend *backend);
 META_EXPORT_TEST
 MetaOrientationManager * meta_backend_get_orientation_manager (MetaBackend *backend);
 MetaCursorTracker * meta_backend_get_cursor_tracker (MetaBackend *backend);
diff --git a/src/backends/meta-backend.c b/src/backends/meta-backend.c
index 033a3d938..369b03b1e 100644
--- a/src/backends/meta-backend.c
+++ b/src/backends/meta-backend.c
@@ -162,7 +162,7 @@ struct _MetaBackendPrivate
   WacomDeviceDatabase *wacom_db;
 #endif
 
-  ClutterBackend *clutter_backend;
+  ClutterContext *clutter_context;
   ClutterSeat *default_seat;
   ClutterActor *stage;
 
@@ -257,7 +257,7 @@ meta_backend_dispose (GObject *object)
   g_clear_pointer (&priv->stage, clutter_actor_destroy);
   g_clear_pointer (&priv->idle_manager, meta_idle_manager_free);
   g_clear_object (&priv->renderer);
-  g_clear_pointer (&priv->clutter_backend, clutter_backend_destroy);
+  g_clear_pointer (&priv->clutter_context, clutter_context_free);
   g_clear_list (&priv->gpus, g_object_unref);
 
   G_OBJECT_CLASS (meta_backend_parent_class)->dispose (object);
@@ -349,7 +349,28 @@ update_cursors (MetaBackend *backend)
 void
 meta_backend_monitors_changed (MetaBackend *backend)
 {
+  MetaBackendPrivate *priv = meta_backend_get_instance_private (backend);
+  MetaMonitorManager *monitor_manager =
+    meta_backend_get_monitor_manager (backend);
+  ClutterSeat *seat = priv->default_seat;
+  ClutterInputDevice *device = clutter_seat_get_pointer (seat);
+  graphene_point_t point;
+
   meta_backend_sync_screen_size (backend);
+
+  if (clutter_seat_query_state (seat, device, NULL, &point, NULL))
+    {
+      /* If we're outside all monitors, warp the pointer back inside */
+      if ((!meta_monitor_manager_get_logical_monitor_at (monitor_manager,
+                                                         point.x, point.y) ||
+           !priv->is_pointer_position_initialized) &&
+          !meta_monitor_manager_is_headless (monitor_manager))
+        {
+          reset_pointer_position (backend);
+          priv->is_pointer_position_initialized = TRUE;
+        }
+    }
+
   update_cursors (backend);
 }
 
@@ -612,12 +633,24 @@ meta_backend_real_create_cursor_tracker (MetaBackend *backend)
                        NULL);
 }
 
+static gboolean
+meta_backend_real_is_headless (MetaBackend *backend)
+{
+  return FALSE;
+}
+
 gboolean
 meta_backend_is_lid_closed (MetaBackend *backend)
 {
   return META_BACKEND_GET_CLASS (backend)->is_lid_closed (backend);
 }
 
+gboolean
+meta_backend_is_headless (MetaBackend *backend)
+{
+  return META_BACKEND_GET_CLASS (backend)->is_headless (backend);
+}
+
 static void
 upower_properties_changed (GDBusProxy *proxy,
                            GVariant   *changed_properties,
@@ -645,7 +678,7 @@ upower_properties_changed (GDBusProxy *proxy,
           g_signal_emit (backend, signals[LID_IS_CLOSED_CHANGED], 0,
                          priv->lid_is_closed);
 
-          if (!lid_is_closed)
+          if (lid_is_closed)
             reset_idle_time = TRUE;
         }
     }
@@ -838,6 +871,7 @@ meta_backend_class_init (MetaBackendClass *klass)
   klass->select_stage_events = meta_backend_real_select_stage_events;
   klass->is_lid_closed = meta_backend_real_is_lid_closed;
   klass->create_cursor_tracker = meta_backend_real_create_cursor_tracker;
+  klass->is_headless = meta_backend_real_is_headless;
 
   obj_props[PROP_CONTEXT] =
     g_param_spec_object ("context",
@@ -1016,11 +1050,11 @@ static GSourceFuncs clutter_source_funcs = {
 };
 
 static ClutterBackend *
-meta_get_clutter_backend (void)
+meta_clutter_backend_constructor (gpointer user_data)
 {
-  MetaBackend *backend = meta_get_backend ();
+  MetaBackend *backend = META_BACKEND (user_data);
 
-  return meta_backend_get_clutter_backend (backend);
+  return META_BACKEND_GET_CLASS (backend)->create_clutter_backend (backend);
 }
 
 static ClutterSeat *
@@ -1038,14 +1072,11 @@ init_clutter (MetaBackend  *backend,
   MetaBackendSource *backend_source;
   GSource *source;
 
-  clutter_set_custom_backend_func (meta_get_clutter_backend);
-
-  if (clutter_init (NULL, NULL) != CLUTTER_INIT_SUCCESS)
-    {
-      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
-                   "Unable to initialize Clutter");
-      return FALSE;
-    }
+  priv->clutter_context = clutter_context_new (meta_clutter_backend_constructor,
+                                               backend,
+                                               error);
+  if (!priv->clutter_context)
+    return FALSE;
 
   priv->default_seat = meta_backend_create_default_seat (backend, error);
   if (!priv->default_seat)
@@ -1167,7 +1198,9 @@ meta_backend_get_idle_manager (MetaBackend *backend)
 }
 
 /**
- * meta_backend_get_monitor_manager: (skip)
+ * meta_backend_get_monitor_manager:
+ *
+ * Returns: (transfer none): A #MetaMonitorManager
  */
 MetaMonitorManager *
 meta_backend_get_monitor_manager (MetaBackend *backend)
@@ -1512,14 +1545,13 @@ ClutterBackend *
 meta_backend_get_clutter_backend (MetaBackend *backend)
 {
   MetaBackendPrivate *priv = meta_backend_get_instance_private (backend);
+  ClutterContext *clutter_context;
 
-  if (!priv->clutter_backend)
-    {
-      priv->clutter_backend =
-        META_BACKEND_GET_CLASS (backend)->create_clutter_backend (backend);
-    }
+  clutter_context = priv->clutter_context;
+  if (!clutter_context)
+    return NULL;
 
-  return priv->clutter_backend;
+  return clutter_context_get_backend (clutter_context);
 }
 
 void
diff --git a/src/backends/meta-cursor-renderer.c b/src/backends/meta-cursor-renderer.c
index 5ed0fb8fc..c4fdbf19e 100644
--- a/src/backends/meta-cursor-renderer.c
+++ b/src/backends/meta-cursor-renderer.c
@@ -395,7 +395,6 @@ meta_cursor_renderer_update_cursor (MetaCursorRenderer *renderer,
                                     MetaCursorSprite   *cursor_sprite)
 {
   MetaCursorRendererPrivate *priv = meta_cursor_renderer_get_instance_private (renderer);
-  gboolean handled_by_backend;
 
   if (cursor_sprite)
     {
@@ -407,11 +406,9 @@ meta_cursor_renderer_update_cursor (MetaCursorRenderer *renderer,
                                      (int) priv->current_y);
     }
 
-  handled_by_backend =
+  priv->handled_by_backend =
     META_CURSOR_RENDERER_GET_CLASS (renderer)->update_cursor (renderer,
                                                               cursor_sprite);
-  if (handled_by_backend != priv->handled_by_backend)
-    priv->handled_by_backend = handled_by_backend;
 
   meta_cursor_renderer_update_stage_overlay (renderer, cursor_sprite);
 }
diff --git a/src/backends/meta-cursor-sprite-xcursor.c b/src/backends/meta-cursor-sprite-xcursor.c
index 947440b9d..742e1a0bf 100644
--- a/src/backends/meta-cursor-sprite-xcursor.c
+++ b/src/backends/meta-cursor-sprite-xcursor.c
@@ -38,6 +38,7 @@ struct _MetaCursorSpriteXcursor
 
   int theme_scale;
   gboolean theme_dirty;
+  gboolean invalidated;
 };
 
 G_DEFINE_TYPE (MetaCursorSpriteXcursor, meta_cursor_sprite_xcursor,
@@ -316,13 +317,29 @@ load_cursor_from_theme (MetaCursorSprite *sprite)
   load_from_current_xcursor_image (sprite_xcursor);
 }
 
-static void
+static gboolean
 meta_cursor_sprite_xcursor_realize_texture (MetaCursorSprite *sprite)
 {
   MetaCursorSpriteXcursor *sprite_xcursor = META_CURSOR_SPRITE_XCURSOR (sprite);
+  gboolean retval = sprite_xcursor->invalidated;
 
   if (sprite_xcursor->theme_dirty)
-    load_cursor_from_theme (sprite);
+    {
+      load_cursor_from_theme (sprite);
+      retval = TRUE;
+    }
+
+  sprite_xcursor->invalidated = FALSE;
+
+  return retval;
+}
+
+static void
+meta_cursor_sprite_xcursor_invalidate (MetaCursorSprite *sprite)
+{
+  MetaCursorSpriteXcursor *sprite_xcursor = META_CURSOR_SPRITE_XCURSOR (sprite);
+
+  sprite_xcursor->invalidated = TRUE;
 }
 
 MetaCursorSpriteXcursor *
@@ -367,6 +384,8 @@ meta_cursor_sprite_xcursor_class_init (MetaCursorSpriteXcursorClass *klass)
 
   cursor_sprite_class->realize_texture =
     meta_cursor_sprite_xcursor_realize_texture;
+  cursor_sprite_class->invalidate =
+    meta_cursor_sprite_xcursor_invalidate;
   cursor_sprite_class->is_animated = meta_cursor_sprite_xcursor_is_animated;
   cursor_sprite_class->tick_frame = meta_cursor_sprite_xcursor_tick_frame;
   cursor_sprite_class->get_current_frame_time =
diff --git a/src/backends/meta-cursor-tracker.c b/src/backends/meta-cursor-tracker.c
index a330cd995..d6dd7e0f7 100644
--- a/src/backends/meta-cursor-tracker.c
+++ b/src/backends/meta-cursor-tracker.c
@@ -132,6 +132,7 @@ update_displayed_cursor (MetaCursorTracker *tracker)
 
   if (cursor)
     {
+      meta_cursor_sprite_invalidate (cursor);
       g_signal_connect (cursor, "texture-changed",
                         G_CALLBACK (cursor_texture_updated), tracker);
     }
diff --git a/src/backends/meta-cursor.c b/src/backends/meta-cursor.c
index 9360b031e..53f2cdf4b 100644
--- a/src/backends/meta-cursor.c
+++ b/src/backends/meta-cursor.c
@@ -30,24 +30,23 @@
 
 enum
 {
-  PREPARE_AT,
-  TEXTURE_CHANGED,
+  PROP_0,
 
-  LAST_SIGNAL
+  PROP_CURSOR_TRACKER,
+
+  N_PROPS
 };
 
-static guint signals[LAST_SIGNAL];
+static GParamSpec *obj_props[N_PROPS];
 
 enum
 {
-  PROP_0,
-
-  PROP_CURSOR_TRACKER,
+  TEXTURE_CHANGED,
 
-  N_PROPS
+  LAST_SIGNAL
 };
 
-static GParamSpec *obj_props[N_PROPS];
+static guint signals[LAST_SIGNAL];
 
 typedef struct _MetaCursorSpritePrivate
 {
@@ -58,6 +57,9 @@ typedef struct _MetaCursorSpritePrivate
   MetaMonitorTransform texture_transform;
   int hot_x, hot_y;
 
+  MetaCursorPrepareFunc prepare_func;
+  gpointer prepare_func_data;
+
   MetaCursorTracker *cursor_tracker;
 } MetaCursorSpritePrivate;
 
@@ -95,6 +97,7 @@ meta_cursor_sprite_clear_texture (MetaCursorSprite *sprite)
     meta_cursor_sprite_get_instance_private (sprite);
 
   g_clear_pointer (&priv->texture, cogl_object_unref);
+  meta_cursor_sprite_invalidate (sprite);
 }
 
 void
@@ -112,6 +115,8 @@ meta_cursor_sprite_set_texture (MetaCursorSprite *sprite,
   priv->hot_x = hot_x;
   priv->hot_y = hot_y;
 
+  meta_cursor_sprite_invalidate (sprite);
+
   g_signal_emit (sprite, signals[TEXTURE_CHANGED], 0);
 }
 
@@ -122,6 +127,9 @@ meta_cursor_sprite_set_texture_scale (MetaCursorSprite *sprite,
   MetaCursorSpritePrivate *priv =
     meta_cursor_sprite_get_instance_private (sprite);
 
+  if (priv->texture_scale != scale)
+    meta_cursor_sprite_invalidate (sprite);
+
   priv->texture_scale = scale;
 }
 
@@ -132,6 +140,9 @@ meta_cursor_sprite_set_texture_transform (MetaCursorSprite     *sprite,
   MetaCursorSpritePrivate *priv =
     meta_cursor_sprite_get_instance_private (sprite);
 
+  if (priv->texture_transform != transform)
+    meta_cursor_sprite_invalidate (sprite);
+
   priv->texture_transform = transform;
 }
 
@@ -192,19 +203,44 @@ meta_cursor_sprite_get_texture_transform (MetaCursorSprite *sprite)
   return priv->texture_transform;
 }
 
+void
+meta_cursor_sprite_set_prepare_func (MetaCursorSprite      *sprite,
+                                     MetaCursorPrepareFunc  func,
+                                     gpointer               user_data)
+{
+  MetaCursorSpritePrivate *priv =
+    meta_cursor_sprite_get_instance_private (sprite);
+
+  priv->prepare_func = func;
+  priv->prepare_func_data = user_data;
+}
+
 void
 meta_cursor_sprite_prepare_at (MetaCursorSprite   *sprite,
                                float               best_scale,
                                int                 x,
                                int                 y)
 {
-  g_signal_emit (sprite, signals[PREPARE_AT], 0, best_scale, x, y);
+  MetaCursorSpritePrivate *priv =
+    meta_cursor_sprite_get_instance_private (sprite);
+
+  if (priv->prepare_func)
+    priv->prepare_func (sprite, best_scale, x, y, priv->prepare_func_data);
+}
+
+gboolean
+meta_cursor_sprite_realize_texture (MetaCursorSprite *sprite)
+{
+  return META_CURSOR_SPRITE_GET_CLASS (sprite)->realize_texture (sprite);
 }
 
 void
-meta_cursor_sprite_realize_texture (MetaCursorSprite *sprite)
+meta_cursor_sprite_invalidate (MetaCursorSprite *sprite)
 {
-  META_CURSOR_SPRITE_GET_CLASS (sprite)->realize_texture (sprite);
+  MetaCursorSpriteClass *sprite_class = META_CURSOR_SPRITE_GET_CLASS (sprite);
+
+  if (sprite_class->invalidate)
+    sprite_class->invalidate (sprite);
 }
 
 static void
@@ -288,15 +324,6 @@ meta_cursor_sprite_class_init (MetaCursorSpriteClass *klass)
                          G_PARAM_STATIC_STRINGS);
   g_object_class_install_properties (object_class, N_PROPS, obj_props);
 
-  signals[PREPARE_AT] = g_signal_new ("prepare-at",
-                                      G_TYPE_FROM_CLASS (object_class),
-                                      G_SIGNAL_RUN_LAST,
-                                      0,
-                                      NULL, NULL, NULL,
-                                      G_TYPE_NONE, 3,
-                                      G_TYPE_FLOAT,
-                                      G_TYPE_INT,
-                                      G_TYPE_INT);
   signals[TEXTURE_CHANGED] = g_signal_new ("texture-changed",
                                            G_TYPE_FROM_CLASS (object_class),
                                            G_SIGNAL_RUN_LAST,
diff --git a/src/backends/meta-cursor.h b/src/backends/meta-cursor.h
index a65e128c4..1bf63f107 100644
--- a/src/backends/meta-cursor.h
+++ b/src/backends/meta-cursor.h
@@ -36,18 +36,30 @@ struct _MetaCursorSpriteClass
 {
   GObjectClass parent_class;
 
-  void (* realize_texture) (MetaCursorSprite *sprite);
+  void (* invalidate) (MetaCursorSprite *sprite);
+  gboolean (* realize_texture) (MetaCursorSprite *sprite);
   gboolean (* is_animated) (MetaCursorSprite *sprite);
   void (* tick_frame) (MetaCursorSprite *sprite);
   unsigned int (* get_current_frame_time) (MetaCursorSprite *sprite);
 };
 
+typedef void (* MetaCursorPrepareFunc) (MetaCursorSprite *sprite,
+                                        float             scale,
+                                        int               x,
+                                        int               y,
+                                        gpointer          user_data);
+
+void meta_cursor_sprite_set_prepare_func (MetaCursorSprite      *sprite,
+                                          MetaCursorPrepareFunc  func,
+                                          gpointer               user_data);
+
 void meta_cursor_sprite_prepare_at (MetaCursorSprite *sprite,
                                     float             best_scale,
                                     int               x,
                                     int               y);
 
-void meta_cursor_sprite_realize_texture (MetaCursorSprite *sprite);
+void meta_cursor_sprite_invalidate (MetaCursorSprite *sprite);
+gboolean meta_cursor_sprite_realize_texture (MetaCursorSprite *sprite);
 
 void meta_cursor_sprite_clear_texture (MetaCursorSprite *sprite);
 
diff --git a/src/backends/meta-egl.c b/src/backends/meta-egl.c
index 0d3f8c95d..0563b55b5 100644
--- a/src/backends/meta-egl.c
+++ b/src/backends/meta-egl.c
@@ -72,6 +72,8 @@ struct _MetaEgl
 
   PFNEGLQUERYDMABUFFORMATSEXTPROC eglQueryDmaBufFormatsEXT;
   PFNEGLQUERYDMABUFMODIFIERSEXTPROC eglQueryDmaBufModifiersEXT;
+
+  PFNEGLQUERYDISPLAYATTRIBEXTPROC eglQueryDisplayAttribEXT;
 };
 
 G_DEFINE_TYPE (MetaEgl, meta_egl, G_TYPE_OBJECT)
@@ -1094,7 +1096,26 @@ meta_egl_query_dma_buf_modifiers (MetaEgl      *egl,
       return FALSE;
     }
 
-    return TRUE;
+  return TRUE;
+}
+
+gboolean
+meta_egl_query_display_attrib (MetaEgl     *egl,
+                               EGLDisplay   display,
+                               EGLint       attribute,
+                               EGLAttrib   *value,
+                               GError     **error)
+{
+  if (!is_egl_proc_valid (egl->eglQueryDisplayAttribEXT, error))
+    return FALSE;
+
+  if (!egl->eglQueryDisplayAttribEXT (display, attribute, value))
+    {
+      set_egl_error (error);
+      return FALSE;
+    }
+
+  return TRUE;
 }
 
 #define GET_EGL_PROC_ADDR(proc) \
@@ -1136,6 +1157,8 @@ meta_egl_constructed (GObject *object)
 
   GET_EGL_PROC_ADDR (eglQueryDmaBufFormatsEXT);
   GET_EGL_PROC_ADDR (eglQueryDmaBufModifiersEXT);
+
+  GET_EGL_PROC_ADDR (eglQueryDisplayAttribEXT);
 }
 
 #undef GET_EGL_PROC_ADDR
diff --git a/src/backends/meta-egl.h b/src/backends/meta-egl.h
index e108e714a..83405b46a 100644
--- a/src/backends/meta-egl.h
+++ b/src/backends/meta-egl.h
@@ -269,4 +269,10 @@ gboolean meta_egl_query_dma_buf_modifiers (MetaEgl      *egl,
                                            EGLint       *num_formats,
                                            GError      **error);
 
+gboolean meta_egl_query_display_attrib (MetaEgl     *egl,
+                                        EGLDisplay   display,
+                                        EGLint       attribute,
+                                        EGLAttrib   *value,
+                                        GError     **error);
+
 #endif /* META_EGL_H */
diff --git a/src/backends/meta-monitor-manager.c b/src/backends/meta-monitor-manager.c
index 092cae76c..1a68d71e0 100644
--- a/src/backends/meta-monitor-manager.c
+++ b/src/backends/meta-monitor-manager.c
@@ -70,6 +70,7 @@ enum
 
   PROP_BACKEND,
   PROP_PANEL_ORIENTATION_MANAGED,
+  PROP_HAS_BUILTIN_PANEL,
 
   PROP_LAST
 };
@@ -107,6 +108,8 @@ typedef struct _MetaMonitorManagerPrivate
   GList *virtual_monitors;
 
   gboolean shutting_down;
+
+  gboolean has_builtin_panel;
 } MetaMonitorManagerPrivate;
 
 G_DEFINE_TYPE_WITH_PRIVATE (MetaMonitorManager, meta_monitor_manager,
@@ -1036,6 +1039,33 @@ update_panel_orientation_managed (MetaMonitorManager *manager)
     handle_orientation_change (orientation_manager, manager);
 }
 
+static void
+update_has_builtin_panel (MetaMonitorManager *manager)
+{
+  MetaMonitorManagerPrivate *priv =
+    meta_monitor_manager_get_instance_private (manager);
+  GList *l;
+  gboolean has_builtin_panel = FALSE;
+
+  for (l = manager->monitors; l; l = l->next)
+    {
+      MetaMonitor *monitor = META_MONITOR (l->data);
+
+      if (meta_monitor_is_laptop_panel (monitor))
+        {
+          has_builtin_panel = TRUE;
+          break;
+        }
+    }
+
+  if (priv->has_builtin_panel == has_builtin_panel)
+    return;
+
+  priv->has_builtin_panel = has_builtin_panel;
+  g_object_notify_by_pspec (G_OBJECT (manager),
+                            obj_props[PROP_HAS_BUILTIN_PANEL]);
+}
+
 void
 meta_monitor_manager_setup (MetaMonitorManager *manager)
 {
@@ -1148,6 +1178,7 @@ meta_monitor_manager_set_property (GObject      *object,
       manager->backend = g_value_get_object (value);
       break;
     case PROP_PANEL_ORIENTATION_MANAGED:
+    case PROP_HAS_BUILTIN_PANEL:
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
     }
@@ -1160,6 +1191,8 @@ meta_monitor_manager_get_property (GObject    *object,
                                    GParamSpec *pspec)
 {
   MetaMonitorManager *manager = META_MONITOR_MANAGER (object);
+  MetaMonitorManagerPrivate *priv =
+    meta_monitor_manager_get_instance_private (manager);
 
   switch (prop_id)
     {
@@ -1169,6 +1202,9 @@ meta_monitor_manager_get_property (GObject    *object,
     case PROP_PANEL_ORIENTATION_MANAGED:
       g_value_set_boolean (value, manager->panel_orientation_managed);
       break;
+    case PROP_HAS_BUILTIN_PANEL:
+      g_value_set_boolean (value, priv->has_builtin_panel);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
     }
@@ -1237,6 +1273,16 @@ meta_monitor_manager_class_init (MetaMonitorManagerClass *klass)
                           G_PARAM_READABLE |
                           G_PARAM_EXPLICIT_NOTIFY |
                           G_PARAM_STATIC_STRINGS);
+
+  obj_props[PROP_HAS_BUILTIN_PANEL] =
+    g_param_spec_boolean ("has-builtin-panel",
+                          "Has builtin panel",
+                          "The system has a built in panel",
+                          FALSE,
+                          G_PARAM_READABLE |
+                          G_PARAM_EXPLICIT_NOTIFY |
+                          G_PARAM_STATIC_STRINGS);
+
   g_object_class_install_properties (object_class, PROP_LAST, obj_props);
 }
 
@@ -3152,6 +3198,7 @@ rebuild_monitors (MetaMonitorManager *manager)
     }
 
   update_panel_orientation_managed (manager);
+  update_has_builtin_panel (manager);
 }
 
 void
diff --git a/src/backends/meta-screen-cast-monitor-stream-src.c b/src/backends/meta-screen-cast-monitor-stream-src.c
index 307500901..82d3862c9 100644
--- a/src/backends/meta-screen-cast-monitor-stream-src.c
+++ b/src/backends/meta-screen-cast-monitor-stream-src.c
@@ -162,7 +162,6 @@ before_stage_painted (MetaStage           *stage,
   MetaScreenCastMonitorStreamSrc *monitor_src =
     META_SCREEN_CAST_MONITOR_STREAM_SRC (user_data);
   MetaScreenCastStreamSrc *src = META_SCREEN_CAST_STREAM_SRC (monitor_src);
-  MetaScreenCastRecordFlag flags;
 
   if (monitor_src->maybe_record_idle_id)
     return;
@@ -170,8 +169,10 @@ before_stage_painted (MetaStage           *stage,
   if (!clutter_stage_view_peek_scanout (view))
     return;
 
-  flags = META_SCREEN_CAST_RECORD_FLAG_DMABUF_ONLY;
-  meta_screen_cast_stream_src_maybe_record_frame (src, flags);
+  monitor_src->maybe_record_idle_id = g_idle_add (maybe_record_frame_on_idle,
+                                                  src);
+  g_source_set_name_by_id (monitor_src->maybe_record_idle_id,
+                           "[mutter] maybe_record_frame_on_idle [monitor-src]");
 }
 
 static MetaBackend *
diff --git a/src/backends/meta-screen-cast-session.c b/src/backends/meta-screen-cast-session.c
index 60fffdea5..d96fb6709 100644
--- a/src/backends/meta-screen-cast-session.c
+++ b/src/backends/meta-screen-cast-session.c
@@ -51,6 +51,7 @@ struct _MetaScreenCastSession
 
   MetaScreenCastSessionHandle *handle;
 
+  gboolean is_active;
   gboolean disable_animations;
 };
 
@@ -117,14 +118,24 @@ meta_screen_cast_session_start (MetaScreenCastSession  *session,
 
   init_remote_access_handle (session);
 
+  session->is_active = TRUE;
+
   return TRUE;
 }
 
+gboolean
+meta_screen_cast_session_is_active (MetaScreenCastSession *session)
+{
+  return session->is_active;
+}
+
 void
 meta_screen_cast_session_close (MetaScreenCastSession *session)
 {
   MetaDBusScreenCastSession *skeleton = META_DBUS_SCREEN_CAST_SESSION (session);
 
+  session->is_active = FALSE;
+
   g_list_free_full (session->streams, g_object_unref);
 
   meta_dbus_session_notify_closed (META_DBUS_SESSION (session));
diff --git a/src/backends/meta-screen-cast-session.h b/src/backends/meta-screen-cast-session.h
index 46bde5eb9..d9c3d0ecc 100644
--- a/src/backends/meta-screen-cast-session.h
+++ b/src/backends/meta-screen-cast-session.h
@@ -59,6 +59,8 @@ MetaScreenCastSession * meta_screen_cast_session_new (MetaScreenCast
 gboolean meta_screen_cast_session_start (MetaScreenCastSession  *session,
                                          GError                **error);
 
+gboolean meta_screen_cast_session_is_active (MetaScreenCastSession *session);
+
 void meta_screen_cast_session_close (MetaScreenCastSession *session);
 
 MetaScreenCastStream * meta_screen_cast_session_get_stream (MetaScreenCastSession *session,
diff --git a/src/backends/meta-screen-cast-stream-src.c b/src/backends/meta-screen-cast-stream-src.c
index 9c13661ff..c3ede8aea 100644
--- a/src/backends/meta-screen-cast-stream-src.c
+++ b/src/backends/meta-screen-cast-stream-src.c
@@ -430,19 +430,15 @@ maybe_record_cursor (MetaScreenCastStreamSrc *src,
 
 static gboolean
 do_record_frame (MetaScreenCastStreamSrc  *src,
-                 MetaScreenCastRecordFlag  flags,
                  struct spa_buffer        *spa_buffer,
                  uint8_t                  *data,
                  GError                  **error)
 {
   MetaScreenCastStreamSrcPrivate *priv =
     meta_screen_cast_stream_src_get_instance_private (src);
-  gboolean dmabuf_only;
 
-  dmabuf_only = flags & META_SCREEN_CAST_RECORD_FLAG_DMABUF_ONLY;
-  if (!dmabuf_only &&
-      (spa_buffer->datas[0].data ||
-       spa_buffer->datas[0].type == SPA_DATA_MemFd))
+  if (spa_buffer->datas[0].data ||
+      spa_buffer->datas[0].type == SPA_DATA_MemFd)
     {
       int width = priv->video_format.size.width;
       int height = priv->video_format.size.height;
@@ -570,7 +566,7 @@ meta_screen_cast_stream_src_maybe_record_frame (MetaScreenCastStreamSrc  *src,
   if (!(flags & META_SCREEN_CAST_RECORD_FLAG_CURSOR_ONLY))
     {
       g_clear_handle_id (&priv->follow_up_frame_source_id, g_source_remove);
-      if (do_record_frame (src, flags, spa_buffer, data, &error))
+      if (do_record_frame (src, spa_buffer, data, &error))
         {
           struct spa_meta_region *spa_meta_video_crop;
 
diff --git a/src/backends/meta-screen-cast-stream-src.h b/src/backends/meta-screen-cast-stream-src.h
index 0e14dbb61..456b5bd97 100644
--- a/src/backends/meta-screen-cast-stream-src.h
+++ b/src/backends/meta-screen-cast-stream-src.h
@@ -41,7 +41,6 @@ typedef enum _MetaScreenCastRecordFlag
 {
   META_SCREEN_CAST_RECORD_FLAG_NONE = 0,
   META_SCREEN_CAST_RECORD_FLAG_CURSOR_ONLY = 1 << 0,
-  META_SCREEN_CAST_RECORD_FLAG_DMABUF_ONLY = 1 << 1,
 } MetaScreenCastRecordFlag;
 
 #define META_TYPE_SCREEN_CAST_STREAM_SRC (meta_screen_cast_stream_src_get_type ())
diff --git a/src/backends/meta-screen-cast-stream.c b/src/backends/meta-screen-cast-stream.c
index b8ab5abd5..bf8648ab6 100644
--- a/src/backends/meta-screen-cast-stream.c
+++ b/src/backends/meta-screen-cast-stream.c
@@ -63,12 +63,17 @@ typedef struct _MetaScreenCastStreamPrivate
   MetaScreenCastStreamSrc *src;
 } MetaScreenCastStreamPrivate;
 
+static void
+meta_screen_cast_stream_init_iface (MetaDBusScreenCastStreamIface *iface);
+
 static void
 meta_screen_cast_stream_init_initable_iface (GInitableIface *iface);
 
 G_DEFINE_TYPE_WITH_CODE (MetaScreenCastStream,
                          meta_screen_cast_stream,
                          META_DBUS_TYPE_SCREEN_CAST_STREAM_SKELETON,
+                         G_IMPLEMENT_INTERFACE (META_DBUS_TYPE_SCREEN_CAST_STREAM,
+                                                meta_screen_cast_stream_init_iface)
                          G_IMPLEMENT_INTERFACE (G_TYPE_INITABLE,
                                                 meta_screen_cast_stream_init_initable_iface)
                          G_ADD_PRIVATE (MetaScreenCastStream))
@@ -137,6 +142,13 @@ meta_screen_cast_stream_start (MetaScreenCastStream  *stream,
     meta_screen_cast_stream_get_instance_private (stream);
   MetaScreenCastStreamSrc *src;
 
+  if (priv->src)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "Stream already started");
+      return FALSE;
+    }
+
   src = meta_screen_cast_stream_create_src (stream, error);
   if (!src)
     return FALSE;
@@ -280,6 +292,65 @@ meta_screen_cast_stream_finalize (GObject *object)
   G_OBJECT_CLASS (meta_screen_cast_stream_parent_class)->finalize (object);
 }
 
+static gboolean
+check_permission (MetaScreenCastStream  *stream,
+                  GDBusMethodInvocation *invocation)
+{
+  MetaScreenCastStreamPrivate *priv =
+    meta_screen_cast_stream_get_instance_private (stream);
+  char *peer_name;
+
+  peer_name = meta_screen_cast_session_get_peer_name (priv->session);
+  return g_strcmp0 (peer_name,
+                    g_dbus_method_invocation_get_sender (invocation)) == 0;
+}
+
+static gboolean
+handle_start (MetaDBusScreenCastStream *skeleton,
+              GDBusMethodInvocation    *invocation)
+{
+  MetaScreenCastStream *stream = META_SCREEN_CAST_STREAM (skeleton);
+  MetaScreenCastStreamPrivate *priv =
+    meta_screen_cast_stream_get_instance_private (stream);
+  g_autoptr (GError) error = NULL;
+
+  if (!check_permission (stream, invocation))
+    {
+      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
+                                             G_DBUS_ERROR_ACCESS_DENIED,
+                                             "Permission denied");
+      return TRUE;
+    }
+
+  if (!meta_screen_cast_session_is_active (priv->session))
+    {
+      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
+                                             G_DBUS_ERROR_FAILED,
+                                             "Failed to start stream: "
+                                             "session not started");
+      return TRUE;
+    }
+
+  if (!meta_screen_cast_stream_start (stream, &error))
+    {
+      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
+                                             G_DBUS_ERROR_FAILED,
+                                             "Failed to start stream: %s",
+                                             error->message);
+      return TRUE;
+    }
+
+  meta_dbus_screen_cast_stream_complete_start (skeleton, invocation);
+
+  return TRUE;
+}
+
+static void
+meta_screen_cast_stream_init_iface (MetaDBusScreenCastStreamIface *iface)
+{
+  iface->handle_start = handle_start;
+}
+
 static gboolean
 meta_screen_cast_stream_initable_init (GInitable     *initable,
                                        GCancellable  *cancellable,
diff --git a/src/backends/meta-stage-impl.c b/src/backends/meta-stage-impl.c
index 28534ec81..2990c8977 100644
--- a/src/backends/meta-stage-impl.c
+++ b/src/backends/meta-stage-impl.c
@@ -199,6 +199,48 @@ paint_damage_region (ClutterStageWindow *stage_window,
   cogl_framebuffer_pop_matrix (framebuffer);
 }
 
+static void
+queue_damage_region (ClutterStageWindow *stage_window,
+                     ClutterStageView   *stage_view,
+                     cairo_region_t     *damage_region)
+{
+  int *damage, n_rects, i;
+  g_autofree int *freeme = NULL;
+  CoglFramebuffer *framebuffer;
+  CoglOnscreen *onscreen;
+
+  if (cairo_region_is_empty (damage_region))
+    return;
+
+  framebuffer = clutter_stage_view_get_onscreen (stage_view);
+  if (!COGL_IS_ONSCREEN (framebuffer))
+    return;
+
+  onscreen = COGL_ONSCREEN (framebuffer);
+
+  n_rects = cairo_region_num_rectangles (damage_region);
+
+  if (n_rects < MAX_STACK_RECTS)
+    damage = g_newa (int, n_rects * 4);
+  else
+    damage = freeme = g_new (int, n_rects * 4);
+
+  for (i = 0; i < n_rects; i++)
+    {
+      cairo_rectangle_int_t rect;
+      int height = cogl_framebuffer_get_height (framebuffer);
+
+      cairo_region_get_rectangle (damage_region, i, &rect);
+      damage[i * 4] = rect.x;
+      /* y coordinate needs to be flipped for OpenGL */
+      damage[i * 4 + 1] = height - rect.y - rect.height;
+      damage[i * 4 + 2] = rect.width;
+      damage[i * 4 + 3] = rect.height;
+    }
+
+  cogl_onscreen_queue_damage_region (onscreen, damage, n_rects);
+}
+
 static void
 swap_framebuffer (ClutterStageWindow *stage_window,
                   ClutterStageView   *stage_view,
@@ -550,6 +592,8 @@ meta_stage_impl_redraw_view_primary (MetaStageImpl    *stage_impl,
     }
   else if (use_clipped_redraw)
     {
+      queue_damage_region (stage_window, stage_view, fb_clip_region);
+
       cogl_framebuffer_push_region_clip (fb, fb_clip_region);
 
       paint_stage (stage_impl, stage_view, redraw_clip);
diff --git a/src/backends/native/gen-default-modes.py b/src/backends/native/gen-default-modes.py
index fed514d45..79542f82f 100755
--- a/src/backends/native/gen-default-modes.py
+++ b/src/backends/native/gen-default-modes.py
@@ -55,6 +55,15 @@ common_resolutions = [
     (5120, 2880),
 ]
 
+common_refresh_rates = [
+    60,
+    90,
+    120,
+    144,
+    165,
+    240,
+]
+
 output_lines = [
     "/* Generated by gen-default-modes.py */\n",
     "static const drmModeModeInfo meta_default_landscape_drm_mode_infos[] = {",
@@ -84,7 +93,7 @@ def drm_mode_info_from_modeline(line):
 
 def portrait_drm_mode_info_from_modeline(line):
     sline = line.split()
-    return "{ %d, %d, %d, %d, %d, 0, %d, %d, %d, %d, 0, 0, %s, DRM_MODE_TYPE_DEFAULT, \"%dx%d_60.00\" }," % \
+    return "{ %d, %d, %d, %d, %d, 0, %d, %d, %d, %d, 0, 0, %s, DRM_MODE_TYPE_DEFAULT, \"%dx%d_%s }," % \
         (int(float(sline[2]) * 1000),
          int(sline[7]),
          int(sline[8]),
@@ -95,24 +104,26 @@ def portrait_drm_mode_info_from_modeline(line):
          int(sline[5]),
          int(sline[6]),
          sync_flags(sline[12], sline[11]),
-         int(sline[7]), int(sline[3]))
+         int(sline[7]), int(sline[3]), sline[1].split("_")[1])
 
 for resolution in common_resolutions:
-    cvt = os.popen("%s %s %s" % ('cvt', resolution[0], resolution[1]))
-    cvt.readline() # discard comment line
-    line = cvt.readline()
-    output_lines.append(drm_mode_info_from_modeline(line))
-    cvt.close()
+    for refresh_rate in common_refresh_rates:
+        cvt = os.popen("%s %s %s %s" % ('cvt', resolution[0], resolution[1], refresh_rate))
+        cvt.readline() # discard comment line
+        line = cvt.readline()
+        output_lines.append(drm_mode_info_from_modeline(line))
+        cvt.close()
 output_lines.append("};")
 
 output_lines.append("")
 output_lines.append("static const drmModeModeInfo meta_default_portrait_drm_mode_infos[] = {")
 for resolution in common_resolutions:
-    cvt = os.popen("%s %s %s" % ('cvt', resolution[0], resolution[1]))
-    cvt.readline() # discard comment line
-    line = cvt.readline()
-    output_lines.append(portrait_drm_mode_info_from_modeline(line))
-    cvt.close()
+    for refresh_rate in common_refresh_rates:
+        cvt = os.popen("%s %s %s %s" % ('cvt', resolution[0], resolution[1], refresh_rate))
+        cvt.readline() # discard comment line
+        line = cvt.readline()
+        output_lines.append(portrait_drm_mode_info_from_modeline(line))
+        cvt.close()
 output_lines.append("};")
 
 try:
diff --git a/src/backends/native/meta-backend-native-types.h b/src/backends/native/meta-backend-native-types.h
index 152b57cf6..f6c87484b 100644
--- a/src/backends/native/meta-backend-native-types.h
+++ b/src/backends/native/meta-backend-native-types.h
@@ -31,6 +31,7 @@ typedef struct _MetaCrtcVirtual MetaCrtcVirtual;
 typedef struct _MetaCrtcModeVirtual MetaCrtcModeVirtual;
 typedef struct _MetaDevicePool MetaDevicePool;
 typedef struct _MetaDeviceFile MetaDeviceFile;
+typedef struct _MetaDrmBuffer MetaDrmBuffer;
 
 typedef enum _MetaSeatNativeFlag
 {
diff --git a/src/backends/native/meta-backend-native.c b/src/backends/native/meta-backend-native.c
index 2cc9add75..0cbe40d87 100644
--- a/src/backends/native/meta-backend-native.c
+++ b/src/backends/native/meta-backend-native.c
@@ -38,7 +38,6 @@
 #include "backends/native/meta-backend-native-private.h"
 #include "backends/native/meta-input-thread.h"
 
-#include <sched.h>
 #include <stdlib.h>
 
 #include "backends/meta-cursor-tracker-private.h"
@@ -61,6 +60,7 @@
 #include "cogl/cogl.h"
 #include "core/meta-border.h"
 #include "meta/main.h"
+#include "meta-dbus-rtkit1.h"
 
 #ifdef HAVE_REMOTE_DESKTOP
 #include "backends/meta-screen-cast.h"
@@ -117,7 +117,7 @@ meta_backend_native_dispose (GObject *object)
 static ClutterBackend *
 meta_backend_native_create_clutter_backend (MetaBackend *backend)
 {
-  return g_object_new (META_TYPE_CLUTTER_BACKEND_NATIVE, NULL);
+  return CLUTTER_BACKEND (meta_clutter_backend_native_new (backend));
 }
 
 static ClutterSeat *
@@ -130,7 +130,7 @@ meta_backend_native_create_default_seat (MetaBackend  *backend,
 
   seat_id = meta_backend_native_get_seat_id (backend_native);
 
-  if (meta_backend_native_is_headless (backend_native))
+  if (meta_backend_is_headless (backend))
     flags = META_SEAT_NATIVE_FLAG_NO_LIBINPUT;
   else
     flags = META_SEAT_NATIVE_FLAG_NONE;
@@ -209,15 +209,36 @@ meta_backend_native_post_init (MetaBackend *backend)
   if (meta_settings_is_experimental_feature_enabled (settings,
                                                      META_EXPERIMENTAL_FEATURE_RT_SCHEDULER))
     {
-      int retval;
-      struct sched_param sp = {
-        .sched_priority = sched_get_priority_min (SCHED_RR)
-      };
-
-      retval = sched_setscheduler (0, SCHED_RR | SCHED_RESET_ON_FORK, &sp);
+      g_autoptr (MetaDbusRealtimeKit1) rtkit_proxy = NULL;
+      g_autoptr (GError) error = NULL;
+
+      rtkit_proxy =
+        meta_dbus_realtime_kit1_proxy_new_for_bus_sync (G_BUS_TYPE_SYSTEM,
+                                                        G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES |
+                                                        G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS |
+                                                        G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START,
+                                                        "org.freedesktop.RealtimeKit1",
+                                                        "/org/freedesktop/RealtimeKit1",
+                                                        NULL,
+                                                        &error);
+
+      if (rtkit_proxy)
+        {
+          uint32_t priority;
+
+          priority = sched_get_priority_min (SCHED_RR);
+          meta_dbus_realtime_kit1_call_make_thread_realtime_sync (rtkit_proxy,
+                                                                  gettid (),
+                                                                  priority,
+                                                                  NULL,
+                                                                  &error);
+        }
 
-      if (retval != 0)
-        g_warning ("Failed to set RT scheduler: %m");
+      if (error)
+        {
+          g_dbus_error_strip_remote_error (error);
+          g_message ("Failed to set RT scheduler: %s", error->message);
+        }
     }
 
 #ifdef HAVE_REMOTE_DESKTOP
@@ -357,10 +378,10 @@ meta_backend_native_get_seat_id (MetaBackendNative *backend_native)
     return meta_launcher_get_seat_id (backend_native->launcher);
 }
 
-gboolean
-meta_backend_native_is_headless (MetaBackendNative *backend_native)
+static gboolean
+meta_backend_native_is_headless (MetaBackend *backend)
 {
-  return backend_native->is_headless;
+  return META_BACKEND_NATIVE (backend)->is_headless;
 }
 
 static void
@@ -626,6 +647,8 @@ meta_backend_native_class_init (MetaBackendNativeClass *klass)
 
   backend_class->set_pointer_constraint = meta_backend_native_set_pointer_constraint;
 
+  backend_class->is_headless = meta_backend_native_is_headless;
+
   obj_props[PROP_HEADLESS] =
     g_param_spec_boolean ("headless",
                           "headless",
diff --git a/src/backends/native/meta-backend-native.h b/src/backends/native/meta-backend-native.h
index aad4c8413..eac81acb0 100644
--- a/src/backends/native/meta-backend-native.h
+++ b/src/backends/native/meta-backend-native.h
@@ -50,6 +50,4 @@ MetaKms * meta_backend_native_get_kms (MetaBackendNative *native);
 
 const char * meta_backend_native_get_seat_id (MetaBackendNative *backend_native);
 
-gboolean meta_backend_native_is_headless (MetaBackendNative *backend_native);
-
 #endif /* META_BACKEND_NATIVE_H */
diff --git a/src/backends/native/meta-clutter-backend-native.c b/src/backends/native/meta-clutter-backend-native.c
index a28ecea99..87963e78e 100644
--- a/src/backends/native/meta-clutter-backend-native.c
+++ b/src/backends/native/meta-clutter-backend-native.c
@@ -54,6 +54,8 @@
 struct _MetaClutterBackendNative
 {
   ClutterBackend parent;
+
+  MetaBackend *backend;
 };
 
 G_DEFINE_TYPE (MetaClutterBackendNative, meta_clutter_backend_native,
@@ -63,7 +65,9 @@ static CoglRenderer *
 meta_clutter_backend_native_get_renderer (ClutterBackend  *clutter_backend,
                                           GError         **error)
 {
-  MetaBackend *backend = meta_get_backend ();
+  MetaClutterBackendNative *clutter_backend_nativen =
+    META_CLUTTER_BACKEND_NATIVE (clutter_backend);
+  MetaBackend *backend = clutter_backend_nativen->backend;
   MetaRenderer *renderer = meta_backend_get_renderer (backend);
 
   return meta_renderer_create_cogl_renderer (renderer);
@@ -83,7 +87,9 @@ meta_clutter_backend_native_create_stage (ClutterBackend  *clutter_backend,
 static ClutterSeat *
 meta_clutter_backend_native_get_default_seat (ClutterBackend *clutter_backend)
 {
-  MetaBackend *backend = meta_get_backend ();
+  MetaClutterBackendNative *clutter_backend_nativen =
+    META_CLUTTER_BACKEND_NATIVE (clutter_backend);
+  MetaBackend *backend = clutter_backend_nativen->backend;
 
   return meta_backend_get_default_seat (backend);
 }
@@ -109,3 +115,15 @@ meta_clutter_backend_native_class_init (MetaClutterBackendNativeClass *klass)
   clutter_backend_class->get_default_seat = meta_clutter_backend_native_get_default_seat;
   clutter_backend_class->is_display_server = meta_clutter_backend_native_is_display_server;
 }
+
+MetaClutterBackendNative *
+meta_clutter_backend_native_new (MetaBackend *backend)
+{
+  MetaClutterBackendNative *clutter_backend_native;
+
+  clutter_backend_native = g_object_new (META_TYPE_CLUTTER_BACKEND_NATIVE,
+                                         NULL);
+  clutter_backend_native->backend = backend;
+
+  return clutter_backend_native;
+}
diff --git a/src/backends/native/meta-clutter-backend-native.h b/src/backends/native/meta-clutter-backend-native.h
index dea35988c..432c72083 100644
--- a/src/backends/native/meta-clutter-backend-native.h
+++ b/src/backends/native/meta-clutter-backend-native.h
@@ -27,6 +27,7 @@
 
 #include <glib-object.h>
 
+#include "backends/meta-backend-types.h"
 #include "backends/native/meta-stage-native.h"
 #include "clutter/clutter.h"
 
@@ -35,4 +36,6 @@ G_DECLARE_FINAL_TYPE (MetaClutterBackendNative, meta_clutter_backend_native,
                       META, CLUTTER_BACKEND_NATIVE,
                       ClutterBackend)
 
+MetaClutterBackendNative * meta_clutter_backend_native_new (MetaBackend *backend);
+
 #endif /* META_CLUTTER_BACKEND_NATIVE_H */
diff --git a/src/backends/native/meta-cursor-renderer-native.c b/src/backends/native/meta-cursor-renderer-native.c
index 81f4da05c..df5862c4c 100644
--- a/src/backends/native/meta-cursor-renderer-native.c
+++ b/src/backends/native/meta-cursor-renderer-native.c
@@ -1074,9 +1074,13 @@ meta_cursor_renderer_native_update_cursor (MetaCursorRenderer *renderer,
 
   if (cursor_sprite)
     {
-      meta_cursor_sprite_realize_texture (cursor_sprite);
+      gboolean realized;
+
+      realized = meta_cursor_sprite_realize_texture (cursor_sprite);
       gpus = calculate_cursor_sprite_gpus (renderer, cursor_sprite);
-      realize_cursor_sprite (renderer, cursor_sprite, gpus);
+
+      if (realized)
+        realize_cursor_sprite (renderer, cursor_sprite, gpus);
     }
 
   maybe_schedule_cursor_sprite_animation_frame (native, cursor_sprite);
@@ -1257,6 +1261,7 @@ load_cursor_sprite_gbm_buffer_for_gpu (MetaCursorRendererNative *native,
       uint8_t buf[4 * cursor_width * cursor_height];
       uint i;
       g_autoptr (GError) error = NULL;
+      MetaDrmBufferFlags flags;
       MetaDrmBufferGbm *buffer_gbm;
 
       device_file = meta_device_pool_open (device_pool,
@@ -1290,7 +1295,9 @@ load_cursor_sprite_gbm_buffer_for_gpu (MetaCursorRendererNative *native,
           return;
         }
 
-      buffer_gbm = meta_drm_buffer_gbm_new_take (device_file, bo, FALSE, &error);
+      flags = META_DRM_BUFFER_FLAG_DISABLE_MODIFIERS;
+      buffer_gbm = meta_drm_buffer_gbm_new_take (device_file, bo, flags,
+                                                 &error);
       if (!buffer_gbm)
         {
           meta_warning ("Failed to create DRM buffer wrapper: %s",
@@ -1584,6 +1591,7 @@ realize_cursor_sprite_from_wl_buffer_for_gpu (MetaCursorRenderer      *renderer,
       struct gbm_device *gbm_device;
       struct gbm_bo *bo;
       g_autoptr (GError) error = NULL;
+      MetaDrmBufferFlags flags;
       MetaDrmBufferGbm *buffer_gbm;
 
       device_file = meta_device_pool_open (device_pool,
@@ -1630,7 +1638,9 @@ realize_cursor_sprite_from_wl_buffer_for_gpu (MetaCursorRenderer      *renderer,
 
       unset_can_preprocess (cursor_sprite);
 
-      buffer_gbm = meta_drm_buffer_gbm_new_take (device_file, bo, FALSE, &error);
+      flags = META_DRM_BUFFER_FLAG_DISABLE_MODIFIERS;
+      buffer_gbm = meta_drm_buffer_gbm_new_take (device_file, bo, flags,
+                                                 &error);
       if (!buffer_gbm)
         {
           meta_warning ("Failed to create DRM buffer wrapper: %s",
diff --git a/src/backends/native/meta-device-pool.c b/src/backends/native/meta-device-pool.c
index 8bbbe3e34..e273917c2 100644
--- a/src/backends/native/meta-device-pool.c
+++ b/src/backends/native/meta-device-pool.c
@@ -24,7 +24,6 @@
 #include <fcntl.h>
 #include <gio/gunixfdlist.h>
 #include <sys/stat.h>
-#include <sys/stat.h>
 #include <sys/sysmacros.h>
 #include <sys/types.h>
 
diff --git a/src/backends/native/meta-drm-buffer-dumb.c b/src/backends/native/meta-drm-buffer-dumb.c
index d2fcad2f0..87ed4c9ce 100644
--- a/src/backends/native/meta-drm-buffer-dumb.c
+++ b/src/backends/native/meta-drm-buffer-dumb.c
@@ -25,6 +25,7 @@
 
 #include "backends/native/meta-drm-buffer-dumb.h"
 
+#include <drm_fourcc.h>
 #include <gio/gio.h>
 #include <xf86drm.h>
 #include <fcntl.h>
@@ -44,10 +45,20 @@ struct _MetaDrmBufferDumb
   int stride_bytes;
   uint32_t drm_format;
   int dmabuf_fd;
+  int offset;
 };
 
 G_DEFINE_TYPE (MetaDrmBufferDumb, meta_drm_buffer_dumb, META_TYPE_DRM_BUFFER)
 
+static int
+meta_drm_buffer_dumb_export_fd (MetaDrmBuffer  *buffer,
+                                GError        **error)
+{
+  g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
+               "Can't export fd for dumb buffer");
+  return -1;
+}
+
 static int
 meta_drm_buffer_dumb_get_width (MetaDrmBuffer *buffer)
 {
@@ -80,6 +91,84 @@ meta_drm_buffer_dumb_get_format (MetaDrmBuffer *buffer)
   return buffer_dumb->drm_format;
 }
 
+static int
+meta_drm_buffer_dumb_get_bpp (MetaDrmBuffer *buffer)
+{
+  MetaDrmBufferDumb *buffer_dumb = META_DRM_BUFFER_DUMB (buffer);
+
+  switch (buffer_dumb->drm_format)
+    {
+    case DRM_FORMAT_C8:
+    case DRM_FORMAT_R8:
+    case DRM_FORMAT_RGB332:
+    case DRM_FORMAT_BGR233:
+      return 8;
+    case DRM_FORMAT_GR88:
+    case DRM_FORMAT_XRGB4444:
+    case DRM_FORMAT_XBGR4444:
+    case DRM_FORMAT_RGBX4444:
+    case DRM_FORMAT_BGRX4444:
+    case DRM_FORMAT_ARGB4444:
+    case DRM_FORMAT_ABGR4444:
+    case DRM_FORMAT_RGBA4444:
+    case DRM_FORMAT_BGRA4444:
+    case DRM_FORMAT_XRGB1555:
+    case DRM_FORMAT_XBGR1555:
+    case DRM_FORMAT_RGBX5551:
+    case DRM_FORMAT_BGRX5551:
+    case DRM_FORMAT_ARGB1555:
+    case DRM_FORMAT_ABGR1555:
+    case DRM_FORMAT_RGBA5551:
+    case DRM_FORMAT_BGRA5551:
+    case DRM_FORMAT_RGB565:
+    case DRM_FORMAT_BGR565:
+      return 16;
+    case DRM_FORMAT_RGB888:
+    case DRM_FORMAT_BGR888:
+      return 24;
+    case DRM_FORMAT_XRGB8888:
+    case DRM_FORMAT_XBGR8888:
+    case DRM_FORMAT_RGBX8888:
+    case DRM_FORMAT_BGRX8888:
+    case DRM_FORMAT_ARGB8888:
+    case DRM_FORMAT_ABGR8888:
+    case DRM_FORMAT_RGBA8888:
+    case DRM_FORMAT_BGRA8888:
+    case DRM_FORMAT_XRGB2101010:
+    case DRM_FORMAT_XBGR2101010:
+    case DRM_FORMAT_RGBX1010102:
+    case DRM_FORMAT_BGRX1010102:
+    case DRM_FORMAT_ARGB2101010:
+    case DRM_FORMAT_ABGR2101010:
+    case DRM_FORMAT_RGBA1010102:
+    case DRM_FORMAT_BGRA1010102:
+      return 32;
+    case DRM_FORMAT_XBGR16161616F:
+    case DRM_FORMAT_ABGR16161616F:
+      return 64;
+    default:
+      g_warn_if_reached ();
+      return 0;
+    }
+}
+
+static int
+meta_drm_buffer_dumb_get_offset (MetaDrmBuffer *buffer,
+                                 int            plane)
+{
+  MetaDrmBufferDumb *buffer_dumb = META_DRM_BUFFER_DUMB (buffer);
+
+  g_warn_if_fail (plane == 0);
+
+  return buffer_dumb->offset;
+}
+
+static uint32_t
+meta_drm_buffer_dumb_get_modifier (MetaDrmBuffer *buffer)
+{
+  return DRM_FORMAT_MOD_LINEAR;
+}
+
 static int
 handle_to_dmabuf_fd (MetaDrmBufferDumb  *buffer_dumb,
                      GError            **error)
@@ -162,7 +251,7 @@ init_dumb_buffer (MetaDrmBufferDumb  *buffer_dumb,
     .handles = { create_arg.handle },
     .strides = { create_arg.pitch },
   };
-  if (!meta_drm_buffer_ensure_fb_id (buffer, FALSE, &fb_args, error))
+  if (!meta_drm_buffer_do_ensure_fb_id (buffer, &fb_args, error))
     goto err_add_fb;
 
   map_arg = (struct drm_mode_map_dumb) {
@@ -196,6 +285,7 @@ init_dumb_buffer (MetaDrmBufferDumb  *buffer_dumb,
   buffer_dumb->height = height;
   buffer_dumb->stride_bytes = create_arg.pitch;
   buffer_dumb->drm_format = format;
+  buffer_dumb->offset = map_arg.offset;
 
   return TRUE;
 
@@ -222,6 +312,7 @@ meta_drm_buffer_dumb_new (MetaDeviceFile  *device_file,
 
   buffer_dumb = g_object_new (META_TYPE_DRM_BUFFER_DUMB,
                               "device-file", device_file,
+                              "flags", META_DRM_BUFFER_FLAG_DISABLE_MODIFIERS,
                               NULL);
 
   if (!init_dumb_buffer (buffer_dumb, width, height, format, error))
@@ -280,8 +371,12 @@ meta_drm_buffer_dumb_class_init (MetaDrmBufferDumbClass *klass)
 
   object_class->finalize = meta_drm_buffer_dumb_finalize;
 
+  buffer_class->export_fd = meta_drm_buffer_dumb_export_fd;
   buffer_class->get_width = meta_drm_buffer_dumb_get_width;
   buffer_class->get_height = meta_drm_buffer_dumb_get_height;
   buffer_class->get_stride = meta_drm_buffer_dumb_get_stride;
+  buffer_class->get_bpp = meta_drm_buffer_dumb_get_bpp;
   buffer_class->get_format = meta_drm_buffer_dumb_get_format;
+  buffer_class->get_offset = meta_drm_buffer_dumb_get_offset;
+  buffer_class->get_modifier = meta_drm_buffer_dumb_get_modifier;
 }
diff --git a/src/backends/native/meta-drm-buffer-gbm.c b/src/backends/native/meta-drm-buffer-gbm.c
index f011afaca..30a8f5cbc 100644
--- a/src/backends/native/meta-drm-buffer-gbm.c
+++ b/src/backends/native/meta-drm-buffer-gbm.c
@@ -57,6 +57,24 @@ meta_drm_buffer_gbm_get_bo (MetaDrmBufferGbm *buffer_gbm)
   return buffer_gbm->bo;
 }
 
+static int
+meta_drm_buffer_gbm_export_fd (MetaDrmBuffer  *buffer,
+                               GError        **error)
+{
+  MetaDrmBufferGbm *buffer_gbm = META_DRM_BUFFER_GBM (buffer);
+  int fd;
+
+  fd = gbm_bo_get_fd (buffer_gbm->bo);
+  if (fd == -1)
+    {
+      g_set_error (error, G_IO_ERROR, g_io_error_from_errno (errno),
+                   "Failed to export buffer fd: %s", g_strerror (errno));
+      return -1;
+    }
+
+  return fd;
+}
+
 static int
 meta_drm_buffer_gbm_get_width (MetaDrmBuffer *buffer)
 {
@@ -81,6 +99,14 @@ meta_drm_buffer_gbm_get_stride (MetaDrmBuffer *buffer)
   return gbm_bo_get_stride (buffer_gbm->bo);
 }
 
+static int
+meta_drm_buffer_gbm_get_bpp (MetaDrmBuffer *buffer)
+{
+  MetaDrmBufferGbm *buffer_gbm = META_DRM_BUFFER_GBM (buffer);
+
+  return gbm_bo_get_bpp (buffer_gbm->bo);
+}
+
 static uint32_t
 meta_drm_buffer_gbm_get_format (MetaDrmBuffer *buffer)
 {
@@ -89,13 +115,30 @@ meta_drm_buffer_gbm_get_format (MetaDrmBuffer *buffer)
   return gbm_bo_get_format (buffer_gbm->bo);
 }
 
+static int
+meta_drm_buffer_gbm_get_offset (MetaDrmBuffer *buffer,
+                                int            plane)
+{
+  MetaDrmBufferGbm *buffer_gbm = META_DRM_BUFFER_GBM (buffer);
+
+  return gbm_bo_get_offset (buffer_gbm->bo, plane);
+}
+
+static uint32_t
+meta_drm_buffer_gbm_get_modifier (MetaDrmBuffer *buffer)
+{
+  MetaDrmBufferGbm *buffer_gbm = META_DRM_BUFFER_GBM (buffer);
+
+  return gbm_bo_get_modifier (buffer_gbm->bo);
+}
+
 static gboolean
-init_fb_id (MetaDrmBufferGbm  *buffer_gbm,
-            struct gbm_bo     *bo,
-            gboolean           use_modifiers,
-            GError           **error)
+meta_drm_buffer_gbm_ensure_fb_id (MetaDrmBuffer  *buffer,
+                                  GError        **error)
 {
+  MetaDrmBufferGbm *buffer_gbm = META_DRM_BUFFER_GBM (buffer);
   MetaDrmFbArgs fb_args = { 0, };
+  struct gbm_bo *bo = buffer_gbm->bo;
 
   if (gbm_bo_get_handle_for_plane (bo, 0).s32 == -1)
     {
@@ -122,8 +165,8 @@ init_fb_id (MetaDrmBufferGbm  *buffer_gbm,
   fb_args.height = gbm_bo_get_height (bo);
   fb_args.format = gbm_bo_get_format (bo);
 
-  if (!meta_drm_buffer_ensure_fb_id (META_DRM_BUFFER (buffer_gbm),
-                                     use_modifiers, &fb_args, error))
+  if (!meta_drm_buffer_do_ensure_fb_id (META_DRM_BUFFER (buffer_gbm),
+                                        &fb_args, error))
     return FALSE;
 
   return TRUE;
@@ -131,7 +174,6 @@ init_fb_id (MetaDrmBufferGbm  *buffer_gbm,
 
 static gboolean
 lock_front_buffer (MetaDrmBufferGbm  *buffer_gbm,
-                   gboolean           use_modifiers,
                    GError           **error)
 {
   buffer_gbm->bo = gbm_surface_lock_front_buffer (buffer_gbm->surface);
@@ -144,23 +186,24 @@ lock_front_buffer (MetaDrmBufferGbm  *buffer_gbm,
       return FALSE;
     }
 
-  return init_fb_id (buffer_gbm, buffer_gbm->bo, use_modifiers, error);
+  return meta_drm_buffer_gbm_ensure_fb_id (META_DRM_BUFFER (buffer_gbm), error);
 }
 
 MetaDrmBufferGbm *
 meta_drm_buffer_gbm_new_lock_front (MetaDeviceFile      *device_file,
                                     struct gbm_surface  *gbm_surface,
-                                    gboolean             use_modifiers,
+                                    MetaDrmBufferFlags   flags,
                                     GError             **error)
 {
   MetaDrmBufferGbm *buffer_gbm;
 
   buffer_gbm = g_object_new (META_TYPE_DRM_BUFFER_GBM,
                              "device-file", device_file,
+                             "flags", flags,
                              NULL);
   buffer_gbm->surface = gbm_surface;
 
-  if (!lock_front_buffer (buffer_gbm, use_modifiers, error))
+  if (!lock_front_buffer (buffer_gbm, error))
     {
       g_object_unref (buffer_gbm);
       return NULL;
@@ -170,23 +213,17 @@ meta_drm_buffer_gbm_new_lock_front (MetaDeviceFile      *device_file,
 }
 
 MetaDrmBufferGbm *
-meta_drm_buffer_gbm_new_take (MetaDeviceFile  *device_file,
-                              struct gbm_bo   *bo,
-                              gboolean         use_modifiers,
-                              GError         **error)
+meta_drm_buffer_gbm_new_take (MetaDeviceFile      *device_file,
+                              struct gbm_bo       *bo,
+                              MetaDrmBufferFlags   flags,
+                              GError             **error)
 {
   MetaDrmBufferGbm *buffer_gbm;
 
   buffer_gbm = g_object_new (META_TYPE_DRM_BUFFER_GBM,
                              "device-file", device_file,
+                             "flags", flags,
                              NULL);
-
-  if (!init_fb_id (buffer_gbm, bo, use_modifiers, error))
-    {
-      g_object_unref (buffer_gbm);
-      return NULL;
-    }
-
   buffer_gbm->bo = bo;
 
   return buffer_gbm;
@@ -466,9 +503,14 @@ meta_drm_buffer_gbm_class_init (MetaDrmBufferGbmClass *klass)
 
   object_class->finalize = meta_drm_buffer_gbm_finalize;
 
+  buffer_class->export_fd = meta_drm_buffer_gbm_export_fd;
+  buffer_class->ensure_fb_id = meta_drm_buffer_gbm_ensure_fb_id;
   buffer_class->get_width = meta_drm_buffer_gbm_get_width;
   buffer_class->get_height = meta_drm_buffer_gbm_get_height;
   buffer_class->get_stride = meta_drm_buffer_gbm_get_stride;
+  buffer_class->get_bpp = meta_drm_buffer_gbm_get_bpp;
   buffer_class->get_format = meta_drm_buffer_gbm_get_format;
+  buffer_class->get_offset = meta_drm_buffer_gbm_get_offset;
+  buffer_class->get_modifier = meta_drm_buffer_gbm_get_modifier;
   buffer_class->fill_timings = meta_drm_buffer_gbm_fill_timings;
 }
diff --git a/src/backends/native/meta-drm-buffer-gbm.h b/src/backends/native/meta-drm-buffer-gbm.h
index 0413c9fa2..ab994a25d 100644
--- a/src/backends/native/meta-drm-buffer-gbm.h
+++ b/src/backends/native/meta-drm-buffer-gbm.h
@@ -35,14 +35,14 @@ G_DECLARE_FINAL_TYPE (MetaDrmBufferGbm,
 
 MetaDrmBufferGbm * meta_drm_buffer_gbm_new_lock_front (MetaDeviceFile      *device_file,
                                                        struct gbm_surface  *gbm_surface,
-                                                       gboolean             use_modifiers,
+                                                       MetaDrmBufferFlags   flags,
                                                        GError             **error);
 
 
-MetaDrmBufferGbm * meta_drm_buffer_gbm_new_take (MetaDeviceFile  *device_file,
-                                                 struct gbm_bo   *gbm_bo,
-                                                 gboolean         use_modifiers,
-                                                 GError         **error);
+MetaDrmBufferGbm * meta_drm_buffer_gbm_new_take (MetaDeviceFile      *device_file,
+                                                 struct gbm_bo       *gbm_bo,
+                                                 MetaDrmBufferFlags   flags,
+                                                 GError             **error);
 
 struct gbm_bo * meta_drm_buffer_gbm_get_bo (MetaDrmBufferGbm *buffer_gbm);
 
diff --git a/src/backends/native/meta-drm-buffer-import.c b/src/backends/native/meta-drm-buffer-import.c
index 77cd138d2..698bbda08 100644
--- a/src/backends/native/meta-drm-buffer-import.c
+++ b/src/backends/native/meta-drm-buffer-import.c
@@ -44,6 +44,16 @@ struct _MetaDrmBufferImport
 G_DEFINE_TYPE (MetaDrmBufferImport, meta_drm_buffer_import,
                META_TYPE_DRM_BUFFER)
 
+static int
+meta_drm_buffer_import_export_fd (MetaDrmBuffer  *buffer,
+                                  GError        **error)
+{
+  MetaDrmBufferImport *buffer_import = META_DRM_BUFFER_IMPORT (buffer);
+
+  return meta_drm_buffer_export_fd (META_DRM_BUFFER (buffer_import->importee),
+                                    error);
+}
+
 static int
 meta_drm_buffer_import_get_width (MetaDrmBuffer *buffer)
 {
@@ -68,6 +78,14 @@ meta_drm_buffer_import_get_stride (MetaDrmBuffer *buffer)
   return meta_drm_buffer_get_stride (META_DRM_BUFFER (buffer_import->importee));
 }
 
+static int
+meta_drm_buffer_import_get_bpp (MetaDrmBuffer *buffer)
+{
+  MetaDrmBufferImport *buffer_import = META_DRM_BUFFER_IMPORT (buffer);
+
+  return meta_drm_buffer_get_bpp (META_DRM_BUFFER (buffer_import->importee));
+}
+
 static uint32_t
 meta_drm_buffer_import_get_format (MetaDrmBuffer *buffer)
 {
@@ -76,6 +94,25 @@ meta_drm_buffer_import_get_format (MetaDrmBuffer *buffer)
   return meta_drm_buffer_get_format (META_DRM_BUFFER (buffer_import->importee));
 }
 
+static int
+meta_drm_buffer_import_get_offset (MetaDrmBuffer *buffer,
+                                   int            offset)
+{
+  MetaDrmBufferImport *buffer_import = META_DRM_BUFFER_IMPORT (buffer);
+  MetaDrmBuffer *importee = META_DRM_BUFFER (buffer_import->importee);
+
+  return meta_drm_buffer_get_offset (importee, offset);
+}
+
+static uint32_t
+meta_drm_buffer_import_get_modifier (MetaDrmBuffer *buffer)
+{
+  MetaDrmBufferImport *buffer_import = META_DRM_BUFFER_IMPORT (buffer);
+  MetaDrmBuffer *importee = META_DRM_BUFFER (buffer_import->importee);
+
+  return meta_drm_buffer_get_modifier (importee);
+}
+
 static struct gbm_bo *
 dmabuf_to_gbm_bo (struct gbm_device *importer,
                   int                dmabuf_fd,
@@ -144,10 +181,9 @@ import_gbm_buffer (MetaDrmBufferImport  *buffer_import,
 
   fb_args.handles[0] = gbm_bo_get_handle (imported_bo).u32;
 
-  ret = meta_drm_buffer_ensure_fb_id (META_DRM_BUFFER (buffer_import),
-                                      FALSE /* use_modifiers */,
-                                      &fb_args,
-                                      error);
+  ret = meta_drm_buffer_do_ensure_fb_id (META_DRM_BUFFER (buffer_import),
+                                         &fb_args,
+                                         error);
 
   gbm_bo_destroy (imported_bo);
 
@@ -167,6 +203,7 @@ meta_drm_buffer_import_new (MetaDeviceFile     *device_file,
 
   buffer_import = g_object_new (META_TYPE_DRM_BUFFER_IMPORT,
                                 "device-file", device_file,
+                                "flags", META_DRM_BUFFER_FLAG_DISABLE_MODIFIERS,
                                 NULL);
   g_set_object (&buffer_import->importee, buffer_gbm);
 
@@ -202,8 +239,12 @@ meta_drm_buffer_import_class_init (MetaDrmBufferImportClass *klass)
 
   object_class->finalize = meta_drm_buffer_import_finalize;
 
+  buffer_class->export_fd = meta_drm_buffer_import_export_fd;
   buffer_class->get_width = meta_drm_buffer_import_get_width;
   buffer_class->get_height = meta_drm_buffer_import_get_height;
   buffer_class->get_stride = meta_drm_buffer_import_get_stride;
+  buffer_class->get_bpp = meta_drm_buffer_import_get_bpp;
   buffer_class->get_format = meta_drm_buffer_import_get_format;
+  buffer_class->get_offset = meta_drm_buffer_import_get_offset;
+  buffer_class->get_modifier = meta_drm_buffer_import_get_modifier;
 }
diff --git a/src/backends/native/meta-drm-buffer-private.h b/src/backends/native/meta-drm-buffer-private.h
index a54ce7c31..9b41379f1 100644
--- a/src/backends/native/meta-drm-buffer-private.h
+++ b/src/backends/native/meta-drm-buffer-private.h
@@ -39,10 +39,20 @@ struct _MetaDrmBufferClass
 {
   GObjectClass parent_class;
 
+  int (* export_fd) (MetaDrmBuffer  *buffer,
+                     GError        **error);
+
+  gboolean (* ensure_fb_id) (MetaDrmBuffer  *buffer,
+                             GError        **error);
+
   int (* get_width) (MetaDrmBuffer *buffer);
   int (* get_height) (MetaDrmBuffer *buffer);
   int (* get_stride) (MetaDrmBuffer *buffer);
+  int (* get_bpp) (MetaDrmBuffer *buffer);
   uint32_t (* get_format) (MetaDrmBuffer *buffer);
+  int (* get_offset) (MetaDrmBuffer *buffer,
+                      int            plane);
+  uint32_t (* get_modifier) (MetaDrmBuffer *buffer);
 
   gboolean (* fill_timings) (MetaDrmBuffer  *buffer,
                              CoglFrameInfo  *info,
@@ -51,14 +61,8 @@ struct _MetaDrmBufferClass
 
 MetaDeviceFile * meta_drm_buffer_get_device_file (MetaDrmBuffer *buffer);
 
-gboolean meta_drm_buffer_ensure_fb_id (MetaDrmBuffer        *buffer,
-                                       gboolean              use_modifiers,
-                                       const MetaDrmFbArgs  *fb_args,
-                                       GError              **error);
-
-gboolean meta_drm_buffer_ensure_fb_in_impl (MetaDrmBuffer        *buffer,
-                                            gboolean              use_modifiers,
-                                            const MetaDrmFbArgs  *fb_args,
-                                            GError              **error);
+gboolean meta_drm_buffer_do_ensure_fb_id (MetaDrmBuffer        *buffer,
+                                          const MetaDrmFbArgs  *fb_args,
+                                          GError              **error);
 
 #endif /* META_DRM_BUFFER_PRIVATE_H */
diff --git a/src/backends/native/meta-drm-buffer.c b/src/backends/native/meta-drm-buffer.c
index 1da622037..c526263f7 100644
--- a/src/backends/native/meta-drm-buffer.c
+++ b/src/backends/native/meta-drm-buffer.c
@@ -31,6 +31,8 @@
 #include "backends/native/meta-device-pool.h"
 #include "backends/native/meta-kms-utils.h"
 
+#include "meta-private-enum-types.h"
+
 #define INVALID_FB_ID 0U
 
 enum
@@ -38,6 +40,7 @@ enum
   PROP_0,
 
   PROP_DEVICE_FILE,
+  PROP_FLAGS,
 
   N_PROPS
 };
@@ -47,6 +50,8 @@ static GParamSpec *obj_props[N_PROPS];
 typedef struct _MetaDrmBufferPrivate
 {
   MetaDeviceFile *device_file;
+  MetaDrmBufferFlags flags;
+
   uint32_t fb_id;
 } MetaDrmBufferPrivate;
 
@@ -62,10 +67,21 @@ meta_drm_buffer_get_device_file (MetaDrmBuffer *buffer)
 }
 
 gboolean
-meta_drm_buffer_ensure_fb_id (MetaDrmBuffer        *buffer,
-                              gboolean              use_modifiers,
-                              const MetaDrmFbArgs  *fb_args,
-                              GError              **error)
+meta_drm_buffer_ensure_fb_id (MetaDrmBuffer  *buffer,
+                              GError        **error)
+{
+  MetaDrmBufferPrivate *priv = meta_drm_buffer_get_instance_private (buffer);
+
+  if (priv->fb_id)
+    return TRUE;
+
+  return META_DRM_BUFFER_GET_CLASS (buffer)->ensure_fb_id (buffer, error);
+}
+
+gboolean
+meta_drm_buffer_do_ensure_fb_id (MetaDrmBuffer        *buffer,
+                                 const MetaDrmFbArgs  *fb_args,
+                                 GError              **error)
 {
   MetaDrmBufferPrivate *priv = meta_drm_buffer_get_instance_private (buffer);
   int fd;
@@ -74,7 +90,8 @@ meta_drm_buffer_ensure_fb_id (MetaDrmBuffer        *buffer,
 
   fd = meta_device_file_get_fd (priv->device_file);
 
-  if (use_modifiers && fb_args->modifiers[0] != DRM_FORMAT_MOD_INVALID)
+  if (!(priv->flags & META_DRM_BUFFER_FLAG_DISABLE_MODIFIERS) &&
+      fb_args->modifiers[0] != DRM_FORMAT_MOD_INVALID)
     {
       if (drmModeAddFB2WithModifiers (fd,
                                       fb_args->width,
@@ -153,6 +170,13 @@ meta_drm_buffer_release_fb_id (MetaDrmBuffer *buffer)
   priv->fb_id = 0;
 }
 
+int
+meta_drm_buffer_export_fd (MetaDrmBuffer  *buffer,
+                           GError        **error)
+{
+  return META_DRM_BUFFER_GET_CLASS (buffer)->export_fd (buffer, error);
+}
+
 uint32_t
 meta_drm_buffer_get_fb_id (MetaDrmBuffer *buffer)
 {
@@ -179,12 +203,31 @@ meta_drm_buffer_get_stride (MetaDrmBuffer *buffer)
   return META_DRM_BUFFER_GET_CLASS (buffer)->get_stride (buffer);
 }
 
+int
+meta_drm_buffer_get_bpp (MetaDrmBuffer *buffer)
+{
+  return META_DRM_BUFFER_GET_CLASS (buffer)->get_bpp (buffer);
+}
+
 uint32_t
 meta_drm_buffer_get_format (MetaDrmBuffer *buffer)
 {
   return META_DRM_BUFFER_GET_CLASS (buffer)->get_format (buffer);
 }
 
+int
+meta_drm_buffer_get_offset (MetaDrmBuffer *buffer,
+                            int            plane)
+{
+  return META_DRM_BUFFER_GET_CLASS (buffer)->get_offset (buffer, plane);
+}
+
+uint32_t
+meta_drm_buffer_get_modifier (MetaDrmBuffer *buffer)
+{
+  return META_DRM_BUFFER_GET_CLASS (buffer)->get_modifier (buffer);
+}
+
 gboolean
 meta_drm_buffer_supports_fill_timings (MetaDrmBuffer *buffer)
 {
@@ -220,6 +263,9 @@ meta_drm_buffer_get_property (GObject    *object,
     case PROP_DEVICE_FILE:
       g_value_set_pointer (value, priv->device_file);
       break;
+    case PROP_FLAGS:
+      g_value_set_flags (value, priv->flags);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -240,6 +286,9 @@ meta_drm_buffer_set_property (GObject      *object,
     case PROP_DEVICE_FILE:
       priv->device_file = g_value_get_pointer (value);
       break;
+    case PROP_FLAGS:
+      priv->flags = g_value_get_flags (value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -292,5 +341,14 @@ meta_drm_buffer_class_init (MetaDrmBufferClass *klass)
                           G_PARAM_READWRITE |
                           G_PARAM_CONSTRUCT_ONLY |
                           G_PARAM_STATIC_STRINGS);
+  obj_props[PROP_FLAGS] =
+    g_param_spec_flags ("flags",
+                        "flags",
+                        "MetaDrmBufferFlags",
+                        META_TYPE_DRM_BUFFER_FLAGS,
+                        META_DRM_BUFFER_FLAG_NONE,
+                        G_PARAM_READWRITE |
+                        G_PARAM_CONSTRUCT_ONLY |
+                        G_PARAM_STATIC_STRINGS);
   g_object_class_install_properties (object_class, N_PROPS, obj_props);
 }
diff --git a/src/backends/native/meta-drm-buffer.h b/src/backends/native/meta-drm-buffer.h
index d32135591..441473aca 100644
--- a/src/backends/native/meta-drm-buffer.h
+++ b/src/backends/native/meta-drm-buffer.h
@@ -28,12 +28,24 @@
 
 #include "cogl/cogl.h"
 
+typedef enum _MetaDrmBufferFlags
+{
+  META_DRM_BUFFER_FLAG_NONE = 0,
+  META_DRM_BUFFER_FLAG_DISABLE_MODIFIERS = 1 << 0,
+} MetaDrmBufferFlags;
+
 #define META_TYPE_DRM_BUFFER (meta_drm_buffer_get_type ())
 G_DECLARE_DERIVABLE_TYPE (MetaDrmBuffer,
                           meta_drm_buffer,
                           META, DRM_BUFFER,
                           GObject)
 
+int meta_drm_buffer_export_fd (MetaDrmBuffer  *buffer,
+                               GError        **error);
+
+gboolean meta_drm_buffer_ensure_fb_id (MetaDrmBuffer  *buffer,
+                                       GError        **error);
+
 uint32_t meta_drm_buffer_get_fb_id (MetaDrmBuffer *buffer);
 
 int meta_drm_buffer_get_width (MetaDrmBuffer *buffer);
@@ -42,8 +54,15 @@ int meta_drm_buffer_get_height (MetaDrmBuffer *buffer);
 
 int meta_drm_buffer_get_stride (MetaDrmBuffer *buffer);
 
+int meta_drm_buffer_get_bpp (MetaDrmBuffer *buffer);
+
 uint32_t meta_drm_buffer_get_format (MetaDrmBuffer *buffer);
 
+int meta_drm_buffer_get_offset (MetaDrmBuffer *buffer,
+                                int            plane);
+
+uint32_t meta_drm_buffer_get_modifier (MetaDrmBuffer *buffer);
+
 gboolean meta_drm_buffer_supports_fill_timings (MetaDrmBuffer *buffer);
 
 gboolean meta_drm_buffer_fill_timings (MetaDrmBuffer  *buffer,
diff --git a/src/backends/native/meta-kms-impl-device-atomic.c b/src/backends/native/meta-kms-impl-device-atomic.c
index e1adf20b3..bcb41e8ad 100644
--- a/src/backends/native/meta-kms-impl-device-atomic.c
+++ b/src/backends/native/meta-kms-impl-device-atomic.c
@@ -421,6 +421,9 @@ process_plane_assignment (MetaKmsImplDevice  *impl_device,
 
   buffer = plane_assignment->buffer;
 
+  if (buffer && !meta_drm_buffer_ensure_fb_id (buffer, error))
+    return FALSE;
+
   meta_topic (META_DEBUG_KMS,
               "[atomic] Assigning %s plane (%u, %s) to %u, "
               "%hdx%hd+%hd+%hd -> %dx%d+%d+%d",
@@ -782,6 +785,8 @@ commit_flags_string (uint32_t commit_flags)
     commit_flag_strings[i++] = "ATOMIC_ALLOW_MODESET";
   if (commit_flags & DRM_MODE_PAGE_FLIP_EVENT)
     commit_flag_strings[i++] = "PAGE_FLIP_EVENT";
+  if (commit_flags & DRM_MODE_ATOMIC_TEST_ONLY)
+    commit_flag_strings[i++] = "TEST_ONLY";
 
   commit_flags_string = g_strjoinv ("|", (char **) commit_flag_strings);
   strncpy (static_commit_flags_string, commit_flags_string,
@@ -993,6 +998,9 @@ meta_kms_impl_device_atomic_process_update (MetaKmsImplDevice *impl_device,
   if (meta_kms_update_get_page_flip_listeners (update))
     commit_flags |= DRM_MODE_PAGE_FLIP_EVENT;
 
+  if (flags & META_KMS_UPDATE_FLAG_TEST_ONLY)
+    commit_flags |= DRM_MODE_ATOMIC_TEST_ONLY;
+
 commit:
   meta_topic (META_DEBUG_KMS,
               "[atomic] Committing update %" G_GUINT64_FORMAT ", flags: %s",
diff --git a/src/backends/native/meta-kms-impl-device-simple.c b/src/backends/native/meta-kms-impl-device-simple.c
index 28d512720..5017d86bf 100644
--- a/src/backends/native/meta-kms-impl-device-simple.c
+++ b/src/backends/native/meta-kms-impl-device-simple.c
@@ -41,6 +41,12 @@ typedef struct _CachedModeSet
 {
   GList *connectors;
   drmModeModeInfo *drm_mode;
+
+  int width;
+  int height;
+  int stride;
+  uint32_t format;
+  uint64_t modifier;
 } CachedModeSet;
 
 struct _MetaKmsImplDeviceSimple
@@ -259,14 +265,21 @@ process_connector_update (MetaKmsImplDevice  *impl_device,
 
 static CachedModeSet *
 cached_mode_set_new (GList                 *connectors,
-                     const drmModeModeInfo *drm_mode)
+                     const drmModeModeInfo *drm_mode,
+                     MetaDrmBuffer         *buffer)
 {
   CachedModeSet *cached_mode_set;
 
+
   cached_mode_set = g_new0 (CachedModeSet, 1);
   *cached_mode_set = (CachedModeSet) {
     .connectors = g_list_copy (connectors),
     .drm_mode = g_memdup2 (drm_mode, sizeof *drm_mode),
+    .width = meta_drm_buffer_get_width (buffer),
+    .height = meta_drm_buffer_get_height (buffer),
+    .stride = meta_drm_buffer_get_stride (buffer),
+    .format = meta_drm_buffer_get_format (buffer),
+    .modifier = meta_drm_buffer_get_modifier (buffer),
   };
 
   return cached_mode_set;
@@ -353,6 +366,7 @@ process_mode_set (MetaKmsImplDevice  *impl_device,
   g_autofree uint32_t *connectors = NULL;
   int n_connectors;
   MetaKmsPlaneAssignment *plane_assignment;
+  MetaDrmBuffer *buffer;
   drmModeModeInfo *drm_mode;
   uint32_t x, y;
   uint32_t fb_id;
@@ -363,7 +377,6 @@ process_mode_set (MetaKmsImplDevice  *impl_device,
 
   if (mode_set->mode)
     {
-      MetaDrmBuffer *buffer;
       GList *l;
 
       drm_mode = g_alloca (sizeof *drm_mode);
@@ -396,6 +409,9 @@ process_mode_set (MetaKmsImplDevice  *impl_device,
         }
 
       buffer = plane_assignment->buffer;
+      if (!meta_drm_buffer_ensure_fb_id (buffer, error))
+        return FALSE;
+
       fb_id = meta_drm_buffer_get_fb_id (buffer);
 
       for (l = mode_set->connectors; l; l = l->next)
@@ -434,6 +450,7 @@ process_mode_set (MetaKmsImplDevice  *impl_device,
     }
   else
     {
+      buffer = NULL;
       drm_mode = NULL;
       x = y = 0;
       n_connectors = 0;
@@ -468,7 +485,8 @@ process_mode_set (MetaKmsImplDevice  *impl_device,
       g_hash_table_replace (impl_device_simple->cached_mode_sets,
                             crtc,
                             cached_mode_set_new (mode_set->connectors,
-                                                 drm_mode));
+                                                 drm_mode,
+                                                 buffer));
     }
   else
     {
@@ -822,6 +840,9 @@ mode_set_fallback (MetaKmsImplDeviceSimple  *impl_device_simple,
       return FALSE;
     }
 
+  if (!meta_drm_buffer_ensure_fb_id (plane_assignment->buffer, error))
+    return FALSE;
+
   fill_connector_ids_array (cached_mode_set->connectors,
                             &connectors,
                             &n_connectors);
@@ -926,6 +947,10 @@ dispatch_page_flip (MetaKmsImplDevice    *impl_device,
       return TRUE;
     }
 
+  if (plane_assignment && plane_assignment->buffer &&
+      !meta_drm_buffer_ensure_fb_id (plane_assignment->buffer, error))
+    return FALSE;
+
   fd = meta_kms_impl_device_get_fd (impl_device);
   if (custom_page_flip)
     {
@@ -1387,6 +1412,71 @@ meta_kms_impl_device_simple_setup_drm_event_context (MetaKmsImplDevice *impl_dev
   drm_event_context->page_flip_handler = page_flip_handler;
 }
 
+static MetaKmsFeedback *
+perform_update_test (MetaKmsImplDevice *impl_device,
+                     MetaKmsUpdate     *update)
+{
+  MetaKmsImplDeviceSimple *impl_device_simple =
+    META_KMS_IMPL_DEVICE_SIMPLE (impl_device);
+  GList *failed_planes = NULL;
+  GList *l;
+
+  for (l = meta_kms_update_get_plane_assignments (update); l; l = l->next)
+    {
+      MetaKmsPlaneAssignment *plane_assignment = l->data;
+      MetaKmsPlane *plane = plane_assignment->plane;
+      MetaKmsCrtc *crtc = plane_assignment->crtc;
+      MetaDrmBuffer *buffer = plane_assignment->buffer;
+      CachedModeSet *cached_mode_set;
+
+      if (!plane_assignment->crtc ||
+          !plane_assignment->buffer)
+        continue;
+
+      cached_mode_set = get_cached_mode_set (impl_device_simple,
+                                             plane_assignment->crtc);
+      if (!cached_mode_set)
+        {
+          MetaKmsPlaneFeedback *plane_feedback;
+
+          plane_feedback =
+            meta_kms_plane_feedback_new_failed (plane, crtc,
+                                                "No existing mode set");
+          failed_planes = g_list_append (failed_planes, plane_feedback);
+          continue;
+        }
+
+      if (meta_drm_buffer_get_width (buffer) != cached_mode_set->width ||
+          meta_drm_buffer_get_height (buffer) != cached_mode_set->height ||
+          meta_drm_buffer_get_stride (buffer) != cached_mode_set->stride ||
+          meta_drm_buffer_get_format (buffer) != cached_mode_set->format ||
+          meta_drm_buffer_get_modifier (buffer) != cached_mode_set->modifier)
+        {
+          MetaKmsPlaneFeedback *plane_feedback;
+
+          plane_feedback =
+            meta_kms_plane_feedback_new_failed (plane, crtc,
+                                                "Incompatible buffer");
+          failed_planes = g_list_append (failed_planes, plane_feedback);
+          continue;
+        }
+    }
+
+  if (failed_planes)
+    {
+      GError *error;
+
+      error = g_error_new_literal (G_IO_ERROR,
+                                   G_IO_ERROR_FAILED,
+                                   "One or more buffers incompatible");
+      return meta_kms_feedback_new_failed (failed_planes, error);
+    }
+  else
+    {
+      return meta_kms_feedback_new_passed (NULL);
+    }
+}
+
 static MetaKmsFeedback *
 meta_kms_impl_device_simple_process_update (MetaKmsImplDevice *impl_device,
                                             MetaKmsUpdate     *update,
@@ -1399,6 +1489,9 @@ meta_kms_impl_device_simple_process_update (MetaKmsImplDevice *impl_device,
               "[simple] Processing update %" G_GUINT64_FORMAT,
               meta_kms_update_get_sequence_number (update));
 
+  if (flags & META_KMS_UPDATE_FLAG_TEST_ONLY)
+    return perform_update_test (impl_device, update);
+
   if (meta_kms_update_is_power_save (update))
     {
       if (!process_power_save (impl_device, &error))
diff --git a/src/backends/native/meta-kms-update-private.h b/src/backends/native/meta-kms-update-private.h
index c89622d09..c375f7ead 100644
--- a/src/backends/native/meta-kms-update-private.h
+++ b/src/backends/native/meta-kms-update-private.h
@@ -106,6 +106,10 @@ MetaKmsPlaneFeedback * meta_kms_plane_feedback_new_take_error (MetaKmsPlane *pla
                                                                MetaKmsCrtc  *crtc,
                                                                GError       *error);
 
+MetaKmsPlaneFeedback * meta_kms_plane_feedback_new_failed (MetaKmsPlane *plane,
+                                                           MetaKmsCrtc  *crtc,
+                                                           const char   *error_message);
+
 MetaKmsFeedback * meta_kms_feedback_new_passed (GList *failed_planes);
 
 MetaKmsFeedback * meta_kms_feedback_new_failed (GList  *failed_planes,
diff --git a/src/backends/native/meta-kms-update.c b/src/backends/native/meta-kms-update.c
index 71e5b423f..98fbdb67a 100644
--- a/src/backends/native/meta-kms-update.c
+++ b/src/backends/native/meta-kms-update.c
@@ -72,6 +72,17 @@ meta_kms_plane_feedback_new_take_error (MetaKmsPlane *plane,
   return plane_feedback;
 }
 
+MetaKmsPlaneFeedback *
+meta_kms_plane_feedback_new_failed (MetaKmsPlane *plane,
+                                    MetaKmsCrtc  *crtc,
+                                    const char   *error_message)
+{
+  GError *error;
+
+  error = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, error_message);
+  return meta_kms_plane_feedback_new_take_error (plane, crtc, error);
+}
+
 MetaKmsFeedback *
 meta_kms_feedback_new_passed (GList *failed_planes)
 {
diff --git a/src/backends/native/meta-kms.c b/src/backends/native/meta-kms.c
index e1ff91568..5f65e75d0 100644
--- a/src/backends/native/meta-kms.c
+++ b/src/backends/native/meta-kms.c
@@ -181,12 +181,6 @@ struct _MetaKms
 
 G_DEFINE_TYPE (MetaKms, meta_kms, G_TYPE_OBJECT)
 
-void
-meta_kms_discard_pending_updates (MetaKms *kms)
-{
-  g_clear_list (&kms->pending_updates, (GDestroyNotify) meta_kms_update_free);
-}
-
 static void
 meta_kms_add_pending_update (MetaKms       *kms,
                              MetaKmsUpdate *update)
@@ -263,8 +257,13 @@ meta_kms_process_update_in_impl (MetaKmsImpl  *impl,
   MetaKmsFeedback *feedback;
 
   feedback = meta_kms_impl_process_update (impl, data->update, data->flags);
-  meta_kms_device_predict_states_in_impl (meta_kms_update_get_device (update),
-                                          update);
+
+  if (!(data->flags & META_KMS_UPDATE_FLAG_TEST_ONLY))
+    {
+      MetaKmsDevice *device = meta_kms_update_get_device (update);
+
+      meta_kms_device_predict_states_in_impl (device, update);
+    }
 
   return feedback;
 }
@@ -335,6 +334,34 @@ meta_kms_post_pending_update_sync (MetaKms           *kms,
   return feedback;
 }
 
+static gpointer
+meta_kms_test_update_in_impl (MetaKmsImpl  *impl,
+                              gpointer      user_data,
+                              GError      **error)
+{
+  MetaKmsUpdate *update = user_data;
+  MetaKmsUpdateFlag flags;
+
+  flags = META_KMS_UPDATE_FLAG_TEST_ONLY;
+  return meta_kms_impl_process_update (impl, update, flags);
+}
+
+MetaKmsFeedback *
+meta_kms_post_test_update_sync (MetaKms       *kms,
+                                MetaKmsUpdate *update)
+{
+  g_assert (!meta_kms_update_get_page_flip_listeners (update));
+  g_assert (!meta_kms_update_get_mode_sets (update));
+  g_assert (!meta_kms_update_get_connector_updates (update));
+
+  meta_kms_update_lock (update);
+
+  return meta_kms_run_impl_task_sync (kms,
+                                      meta_kms_test_update_in_impl,
+                                      update,
+                                      NULL);
+}
+
 static gpointer
 meta_kms_discard_pending_page_flips_in_impl (MetaKmsImpl  *impl,
                                              gpointer      user_data,
diff --git a/src/backends/native/meta-kms.h b/src/backends/native/meta-kms.h
index e39f0bfb8..e8a129e4b 100644
--- a/src/backends/native/meta-kms.h
+++ b/src/backends/native/meta-kms.h
@@ -35,13 +35,12 @@ typedef enum _MetaKmsUpdateFlag
 {
   META_KMS_UPDATE_FLAG_NONE = 0,
   META_KMS_UPDATE_FLAG_PRESERVE_ON_ERROR = 1 << 0,
+  META_KMS_UPDATE_FLAG_TEST_ONLY = 1 << 1,
 } MetaKmsUpdateFlag;
 
 #define META_TYPE_KMS (meta_kms_get_type ())
 G_DECLARE_FINAL_TYPE (MetaKms, meta_kms, META, KMS, GObject)
 
-void meta_kms_discard_pending_updates (MetaKms *kms);
-
 MetaKmsUpdate * meta_kms_ensure_pending_update (MetaKms       *kms,
                                                 MetaKmsDevice *device);
 
@@ -52,6 +51,9 @@ MetaKmsFeedback * meta_kms_post_pending_update_sync (MetaKms           *kms,
                                                      MetaKmsDevice     *device,
                                                      MetaKmsUpdateFlag  flags);
 
+MetaKmsFeedback * meta_kms_post_test_update_sync (MetaKms       *kms,
+                                                  MetaKmsUpdate *update);
+
 void meta_kms_discard_pending_page_flips (MetaKms *kms);
 
 void meta_kms_notify_modes_set (MetaKms *kms);
diff --git a/src/backends/native/meta-onscreen-native.c b/src/backends/native/meta-onscreen-native.c
index f56c6b13e..372368ef4 100644
--- a/src/backends/native/meta-onscreen-native.c
+++ b/src/backends/native/meta-onscreen-native.c
@@ -43,6 +43,8 @@
 #include "backends/native/meta-kms-utils.h"
 #include "backends/native/meta-kms.h"
 #include "backends/native/meta-output-kms.h"
+#include "backends/native/meta-render-device-gbm.h"
+#include "backends/native/meta-render-device.h"
 #include "backends/native/meta-renderer-native-gles3.h"
 #include "backends/native/meta-renderer-native-private.h"
 
@@ -226,8 +228,6 @@ notify_view_crtc_presented (MetaRendererView *view,
 
   frame_info = cogl_onscreen_peek_head_frame_info (onscreen);
 
-  g_return_if_fail (frame_info != NULL);
-
   crtc = META_CRTC (meta_crtc_kms_from_kms_crtc (kms_crtc));
   maybe_update_frame_info (crtc, frame_info, time_us, flags, sequence);
 
@@ -371,6 +371,7 @@ custom_egl_stream_page_flip (gpointer custom_page_flip_data,
   MetaRendererView *view = user_data;
   MetaEgl *egl = meta_onscreen_native_get_egl (onscreen_native);
   MetaRendererNativeGpuData *renderer_gpu_data;
+  MetaRenderDevice *render_device;
   EGLDisplay *egl_display;
   EGLAttrib *acquire_attribs;
   g_autoptr (GError) error = NULL;
@@ -384,8 +385,9 @@ custom_egl_stream_page_flip (gpointer custom_page_flip_data,
   renderer_gpu_data =
     meta_renderer_native_get_gpu_data (onscreen_native->renderer_native,
                                        onscreen_native->render_gpu);
+  render_device = renderer_gpu_data->render_device;
 
-  egl_display = renderer_gpu_data->egl_display;
+  egl_display = meta_render_device_get_egl_display (render_device);
   if (!meta_egl_stream_consumer_acquire_attrib (egl,
                                                 egl_display,
                                                 onscreen_native->egl.stream,
@@ -550,10 +552,14 @@ secondary_gpu_state_free (MetaOnscreenNativeSecondaryGpuState *secondary_gpu_sta
   if (secondary_gpu_state->egl_surface != EGL_NO_SURFACE)
     {
       MetaRendererNativeGpuData *renderer_gpu_data;
+      MetaRenderDevice *render_device;
+      EGLDisplay egl_display;
 
       renderer_gpu_data = secondary_gpu_state->renderer_gpu_data;
+      render_device = renderer_gpu_data->render_device;
+      egl_display = meta_render_device_get_egl_display (render_device);
       meta_egl_destroy_surface (egl,
-                                renderer_gpu_data->egl_display,
+                                egl_display,
                                 secondary_gpu_state->egl_surface,
                                 NULL);
     }
@@ -572,28 +578,21 @@ import_shared_framebuffer (CoglOnscreen                        *onscreen,
                            MetaOnscreenNativeSecondaryGpuState *secondary_gpu_state)
 {
   MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
-  MetaGpuKms *gpu_kms;
-  MetaDeviceFile *device_file;
-  struct gbm_device *gbm_device;
-  MetaDrmBufferGbm *buffer_gbm;
-  MetaDrmBufferImport *buffer_import;
+  MetaRenderDevice *render_device;
   g_autoptr (GError) error = NULL;
-
-  buffer_gbm = META_DRM_BUFFER_GBM (onscreen_native->gbm.next_fb);
-
-  gpu_kms = secondary_gpu_state->gpu_kms;
-  device_file = secondary_gpu_state->renderer_gpu_data->device_file;
-  gbm_device = meta_gbm_device_from_gpu (gpu_kms);
-  buffer_import = meta_drm_buffer_import_new (device_file,
-                                              gbm_device,
-                                              buffer_gbm,
-                                              &error);
-  if (!buffer_import)
+  MetaDrmBuffer *imported_buffer;
+
+  render_device = secondary_gpu_state->renderer_gpu_data->render_device;
+  imported_buffer =
+    meta_render_device_import_dma_buf (render_device,
+                                       onscreen_native->gbm.next_fb,
+                                       &error);
+  if (!imported_buffer)
     {
       meta_topic (META_DEBUG_KMS,
                   "Zero-copy disabled for %s, "
                   "meta_drm_buffer_import_new failed: %s",
-                  meta_device_file_get_path (device_file),
+                  meta_render_device_get_name (render_device),
                   error->message);
 
       g_warn_if_fail (secondary_gpu_state->import_status ==
@@ -622,7 +621,7 @@ import_shared_framebuffer (CoglOnscreen                        *onscreen,
    * when we are sure to succeed.
    */
   g_clear_object (&secondary_gpu_state->gbm.next_fb);
-  secondary_gpu_state->gbm.next_fb = META_DRM_BUFFER (buffer_import);
+  secondary_gpu_state->gbm.next_fb = imported_buffer;
 
   if (secondary_gpu_state->import_status ==
       META_SHARED_FRAMEBUFFER_IMPORT_STATUS_NONE)
@@ -635,7 +634,7 @@ import_shared_framebuffer (CoglOnscreen                        *onscreen,
 
       meta_topic (META_DEBUG_KMS,
                   "Using zero-copy for %s succeeded once.",
-                  meta_device_file_get_path (device_file));
+                  meta_render_device_get_name (render_device));
     }
 
   secondary_gpu_state->import_status =
@@ -653,9 +652,12 @@ copy_shared_framebuffer_gpu (CoglOnscreen                        *onscreen,
   MetaRendererNative *renderer_native = renderer_gpu_data->renderer_native;
   MetaEgl *egl = meta_renderer_native_get_egl (renderer_native);
   MetaGles3 *gles3 = meta_renderer_native_get_gles3 (renderer_native);
+  MetaRenderDevice *render_device;
+  EGLDisplay egl_display;
   GError *error = NULL;
   gboolean use_modifiers;
   MetaDeviceFile *device_file;
+  MetaDrmBufferFlags flags;
   MetaDrmBufferGbm *buffer_gbm;
   struct gbm_bo *bo;
 
@@ -665,8 +667,11 @@ copy_shared_framebuffer_gpu (CoglOnscreen                        *onscreen,
   g_warn_if_fail (secondary_gpu_state->gbm.next_fb == NULL);
   g_clear_object (&secondary_gpu_state->gbm.next_fb);
 
+  render_device = renderer_gpu_data->render_device;
+  egl_display = meta_render_device_get_egl_display (render_device);
+
   if (!meta_egl_make_current (egl,
-                              renderer_gpu_data->egl_display,
+                              egl_display,
                               secondary_gpu_state->egl_surface,
                               secondary_gpu_state->egl_surface,
                               renderer_gpu_data->secondary.egl_context,
@@ -684,7 +689,7 @@ copy_shared_framebuffer_gpu (CoglOnscreen                        *onscreen,
   bo = meta_drm_buffer_gbm_get_bo (buffer_gbm);
   if (!meta_renderer_native_gles3_blit_shared_bo (egl,
                                                   gles3,
-                                                  renderer_gpu_data->egl_display,
+                                                  egl_display,
                                                   renderer_gpu_data->secondary.egl_context,
                                                   secondary_gpu_state->egl_surface,
                                                   bo,
@@ -696,7 +701,7 @@ copy_shared_framebuffer_gpu (CoglOnscreen                        *onscreen,
     }
 
   if (!meta_egl_swap_buffers (egl,
-                              renderer_gpu_data->egl_display,
+                              egl_display,
                               secondary_gpu_state->egl_surface,
                               &error))
     {
@@ -706,11 +711,16 @@ copy_shared_framebuffer_gpu (CoglOnscreen                        *onscreen,
     }
 
   use_modifiers = meta_renderer_native_use_modifiers (renderer_native);
-  device_file = secondary_gpu_state->renderer_gpu_data->device_file;
+  device_file = meta_render_device_get_device_file (render_device);
+
+  flags = META_DRM_BUFFER_FLAG_NONE;
+  if (!use_modifiers)
+    flags |= META_DRM_BUFFER_FLAG_DISABLE_MODIFIERS;
+
   buffer_gbm =
     meta_drm_buffer_gbm_new_lock_front (device_file,
                                         secondary_gpu_state->gbm.surface,
-                                        use_modifiers,
+                                        flags,
                                         &error);
   if (!buffer_gbm)
     {
@@ -918,10 +928,10 @@ update_secondary_gpu_state_pre_swap_buffers (CoglOnscreen *onscreen,
   if (secondary_gpu_state)
     {
       MetaRendererNativeGpuData *renderer_gpu_data;
-      MetaDeviceFile *device_file;
+      MetaRenderDevice *render_device;
 
       renderer_gpu_data = secondary_gpu_state->renderer_gpu_data;
-      device_file = renderer_gpu_data->device_file;
+      render_device = renderer_gpu_data->render_device;
       switch (renderer_gpu_data->secondary.copy_mode)
         {
         case META_SHARED_FRAMEBUFFER_COPY_MODE_SECONDARY_GPU:
@@ -944,7 +954,7 @@ update_secondary_gpu_state_pre_swap_buffers (CoglOnscreen *onscreen,
                 {
                   meta_topic (META_DEBUG_KMS,
                               "Using primary GPU to copy for %s failed once.",
-                              meta_device_file_get_path (device_file));
+                              meta_render_device_get_name (render_device));
                   secondary_gpu_state->noted_primary_gpu_copy_failed = TRUE;
                 }
 
@@ -956,7 +966,7 @@ update_secondary_gpu_state_pre_swap_buffers (CoglOnscreen *onscreen,
             {
               meta_topic (META_DEBUG_KMS,
                           "Using primary GPU to copy for %s succeeded once.",
-                          meta_device_file_get_path (device_file));
+                          meta_render_device_get_name (render_device));
               secondary_gpu_state->noted_primary_gpu_copy_ok = TRUE;
             }
           break;
@@ -1046,9 +1056,9 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen  *onscreen,
   ClutterFrame *frame = user_data;
   CoglOnscreenClass *parent_class;
   gboolean egl_context_changed = FALSE;
-  gboolean use_modifiers;
   MetaPowerSave power_save_mode;
   g_autoptr (GError) error = NULL;
+  MetaDrmBufferFlags buffer_flags;
   MetaDrmBufferGbm *buffer_gbm;
   MetaKmsCrtc *kms_crtc;
   MetaKmsDevice *kms_device;
@@ -1072,18 +1082,22 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen  *onscreen,
 
   renderer_gpu_data = meta_renderer_native_get_gpu_data (renderer_native,
                                                          render_gpu);
-  render_device_file = renderer_gpu_data->device_file;
+  render_device_file =
+    meta_render_device_get_device_file (renderer_gpu_data->render_device);
   switch (renderer_gpu_data->mode)
     {
     case META_RENDERER_NATIVE_MODE_GBM:
       g_warn_if_fail (onscreen_native->gbm.next_fb == NULL);
       g_clear_object (&onscreen_native->gbm.next_fb);
 
-      use_modifiers = meta_renderer_native_use_modifiers (renderer_native);
+      buffer_flags = META_DRM_BUFFER_FLAG_NONE;
+      if (!meta_renderer_native_use_modifiers (renderer_native))
+        buffer_flags |= META_DRM_BUFFER_FLAG_DISABLE_MODIFIERS;
+
       buffer_gbm =
         meta_drm_buffer_gbm_new_lock_front (render_device_file,
                                             onscreen_native->gbm.surface,
-                                            use_modifiers,
+                                            buffer_flags,
                                             &error);
       if (!buffer_gbm)
         {
@@ -1212,46 +1226,30 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen  *onscreen,
 }
 
 gboolean
-meta_onscreen_native_is_buffer_scanout_compatible (CoglOnscreen *onscreen,
-                                                   uint32_t      drm_format,
-                                                   uint64_t      drm_modifier,
-                                                   uint32_t      stride)
+meta_onscreen_native_is_buffer_scanout_compatible (CoglOnscreen  *onscreen,
+                                                   MetaDrmBuffer *fb)
 {
   MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
-  const MetaCrtcConfig *crtc_config;
-  MetaDrmBuffer *fb;
-  struct gbm_bo *gbm_bo;
-
-  crtc_config = meta_crtc_get_config (onscreen_native->crtc);
-  if (crtc_config->transform != META_MONITOR_TRANSFORM_NORMAL)
-    return FALSE;
-
-  if (onscreen_native->secondary_gpu_state)
-    return FALSE;
-
-  if (!onscreen_native->gbm.surface)
-    return FALSE;
-
-  fb = onscreen_native->gbm.current_fb ? onscreen_native->gbm.current_fb
-                                       : onscreen_native->gbm.next_fb;
-  if (!fb)
-    return FALSE;
-
-  if (!META_IS_DRM_BUFFER_GBM (fb))
-    return FALSE;
-
-  gbm_bo = meta_drm_buffer_gbm_get_bo (META_DRM_BUFFER_GBM (fb));
-
-  if (gbm_bo_get_format (gbm_bo) != drm_format)
-    return FALSE;
+  MetaCrtc *crtc = onscreen_native->crtc;
+  MetaCrtcKms *crtc_kms = META_CRTC_KMS (crtc);
+  MetaGpuKms *gpu_kms;
+  MetaKmsDevice *kms_device;
+  MetaKms *kms;
+  MetaKmsUpdate *test_update;
+  g_autoptr (MetaKmsFeedback) kms_feedback = NULL;
+  MetaKmsFeedbackResult result;
 
-  if (gbm_bo_get_modifier (gbm_bo) != drm_modifier)
-    return FALSE;
+  gpu_kms = META_GPU_KMS (meta_crtc_get_gpu (crtc));
+  kms_device = meta_gpu_kms_get_kms_device (gpu_kms);
+  kms = meta_kms_device_get_kms (kms_device);
+  test_update = meta_kms_update_new (kms_device);
 
-  if (gbm_bo_get_stride (gbm_bo) != stride)
-    return FALSE;
+  meta_crtc_kms_assign_primary_plane (crtc_kms, fb, test_update);
+  kms_feedback = meta_kms_post_test_update_sync (kms, test_update);
+  meta_kms_update_free (test_update);
 
-  return TRUE;
+  result = meta_kms_feedback_get_result (kms_feedback);
+  return result == META_KMS_FEEDBACK_PASSED;
 }
 
 static gboolean
@@ -1522,6 +1520,8 @@ get_supported_egl_modifiers (CoglOnscreen *onscreen,
   MetaEgl *egl = meta_onscreen_native_get_egl (onscreen_native);
   MetaGpu *gpu;
   MetaRendererNativeGpuData *renderer_gpu_data;
+  MetaRenderDevice *render_device;
+  EGLDisplay egl_display;
   EGLint num_modifiers;
   GArray *modifiers;
   GError *error = NULL;
@@ -1530,13 +1530,15 @@ get_supported_egl_modifiers (CoglOnscreen *onscreen,
   gpu = meta_crtc_get_gpu (META_CRTC (crtc_kms));
   renderer_gpu_data = meta_renderer_native_get_gpu_data (renderer_native,
                                                          META_GPU_KMS (gpu));
+  render_device = renderer_gpu_data->render_device;
+  egl_display = meta_render_device_get_egl_display (render_device);
 
-  if (!meta_egl_has_extensions (egl, renderer_gpu_data->egl_display, NULL,
+  if (!meta_egl_has_extensions (egl, egl_display, NULL,
                                 "EGL_EXT_image_dma_buf_import_modifiers",
                                 NULL))
     return NULL;
 
-  ret = meta_egl_query_dma_buf_modifiers (egl, renderer_gpu_data->egl_display,
+  ret = meta_egl_query_dma_buf_modifiers (egl, egl_display,
                                           format, 0, NULL, NULL,
                                           &num_modifiers, NULL);
   if (!ret || num_modifiers == 0)
@@ -1544,7 +1546,7 @@ get_supported_egl_modifiers (CoglOnscreen *onscreen,
 
   modifiers = g_array_sized_new (FALSE, FALSE, sizeof (uint64_t),
                                  num_modifiers);
-  ret = meta_egl_query_dma_buf_modifiers (egl, renderer_gpu_data->egl_display,
+  ret = meta_egl_query_dma_buf_modifiers (egl, egl_display,
                                           format, num_modifiers,
                                           (EGLuint64KHR *) modifiers->data, NULL,
                                           &num_modifiers, &error);
@@ -1605,6 +1607,8 @@ create_surfaces_gbm (CoglOnscreen        *onscreen,
   CoglRenderer *cogl_renderer = cogl_display->renderer;
   CoglRendererEGL *cogl_renderer_egl = cogl_renderer->winsys;
   MetaRendererNativeGpuData *renderer_gpu_data = cogl_renderer_egl->platform;
+  MetaRenderDeviceGbm *render_device_gbm;
+  struct gbm_device *gbm_device;
   struct gbm_surface *new_gbm_surface = NULL;
   EGLNativeWindowType egl_native_window;
   EGLSurface new_egl_surface;
@@ -1614,6 +1618,8 @@ create_surfaces_gbm (CoglOnscreen        *onscreen,
   renderer_gpu_data =
     meta_renderer_native_get_gpu_data (renderer_native,
                                        onscreen_native->render_gpu);
+  render_device_gbm = META_RENDER_DEVICE_GBM (renderer_gpu_data->render_device);
+  gbm_device = meta_render_device_gbm_get_gbm_device (render_device_gbm);
 
   format = get_gbm_format_from_egl (egl,
                                     cogl_renderer_egl->edpy,
@@ -1627,7 +1633,7 @@ create_surfaces_gbm (CoglOnscreen        *onscreen,
   if (modifiers)
     {
       new_gbm_surface =
-        gbm_surface_create_with_modifiers (renderer_gpu_data->gbm.device,
+        gbm_surface_create_with_modifiers (gbm_device,
                                            width, height, format,
                                            (uint64_t *) modifiers->data,
                                            modifiers->len);
@@ -1641,7 +1647,7 @@ create_surfaces_gbm (CoglOnscreen        *onscreen,
       if (should_surface_be_sharable (onscreen))
         flags |= GBM_BO_USE_LINEAR;
 
-      new_gbm_surface = gbm_surface_create (renderer_gpu_data->gbm.device,
+      new_gbm_surface = gbm_surface_create (gbm_device,
                                             width, height,
                                             format,
                                             flags);
@@ -1692,9 +1698,10 @@ create_surfaces_egl_device (CoglOnscreen  *onscreen,
   CoglRenderer *cogl_renderer = cogl_display->renderer;
   CoglRendererEGL *cogl_renderer_egl = cogl_renderer->winsys;
   MetaRendererNativeGpuData *renderer_gpu_data = cogl_renderer_egl->platform;
+  MetaRenderDevice *render_device;
   MetaEgl *egl =
     meta_renderer_native_get_egl (renderer_gpu_data->renderer_native);
-  EGLDisplay egl_display = renderer_gpu_data->egl_display;
+  EGLDisplay egl_display;
   EGLConfig egl_config;
   EGLStreamKHR egl_stream;
   EGLSurface egl_surface;
@@ -1712,6 +1719,8 @@ create_surfaces_egl_device (CoglOnscreen  *onscreen,
     EGL_NONE
   };
 
+  render_device = renderer_gpu_data->render_device;
+  egl_display = meta_render_device_get_egl_display (render_device);
   egl_stream = meta_egl_create_stream (egl, egl_display, stream_attribs, error);
   if (egl_stream == EGL_NO_STREAM_KHR)
     return FALSE;
@@ -1787,7 +1796,8 @@ meta_onscreen_native_allocate (CoglFramebuffer  *framebuffer,
   int width;
   int height;
 #ifdef HAVE_EGL_DEVICE
-  MetaDeviceFile *render_device_file;
+  MetaRenderDevice *render_device;
+  MetaDrmBuffer *dumb_buffer;
   EGLStreamKHR egl_stream;
 #endif
   CoglFramebufferClass *parent_class;
@@ -1824,15 +1834,16 @@ meta_onscreen_native_allocate (CoglFramebuffer  *framebuffer,
       break;
 #ifdef HAVE_EGL_DEVICE
     case META_RENDERER_NATIVE_MODE_EGL_DEVICE:
-      render_device_file = renderer_gpu_data->device_file;
-      onscreen_native->egl.dumb_fb =
-        meta_drm_buffer_dumb_new (render_device_file,
-                                  width, height,
-                                  DRM_FORMAT_XRGB8888,
-                                  error);
-      if (!onscreen_native->egl.dumb_fb)
+      render_device = renderer_gpu_data->render_device;
+      dumb_buffer = meta_render_device_allocate_dumb_buf (render_device,
+                                                          width, height,
+                                                          DRM_FORMAT_XRGB8888,
+                                                          error);
+      if (!dumb_buffer)
         return FALSE;
 
+      onscreen_native->egl.dumb_fb = META_DRM_BUFFER_DUMB (dumb_buffer);
+
       if (!create_surfaces_egl_device (onscreen,
                                        width, height,
                                        &egl_stream,
@@ -1859,6 +1870,10 @@ init_secondary_gpu_state_gpu_copy_mode (MetaRendererNative         *renderer_nat
   CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
   MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
   MetaEgl *egl = meta_onscreen_native_get_egl (onscreen_native);
+  MetaRenderDevice *render_device;
+  MetaRenderDeviceGbm *render_device_gbm;
+  struct gbm_device *gbm_device;
+  EGLDisplay egl_display;
   int width, height;
   EGLNativeWindowType egl_native_window;
   struct gbm_surface *gbm_surface;
@@ -1867,13 +1882,17 @@ init_secondary_gpu_state_gpu_copy_mode (MetaRendererNative         *renderer_nat
   MetaGpuKms *gpu_kms;
   uint32_t format;
 
+  render_device = renderer_gpu_data->render_device;
+  egl_display = meta_render_device_get_egl_display (render_device);
   width = cogl_framebuffer_get_width (framebuffer);
   height = cogl_framebuffer_get_height (framebuffer);
   format = get_gbm_format_from_egl (egl,
-                                    renderer_gpu_data->egl_display,
+                                    egl_display,
                                     renderer_gpu_data->secondary.egl_config);
 
-  gbm_surface = gbm_surface_create (renderer_gpu_data->gbm.device,
+  render_device_gbm = META_RENDER_DEVICE_GBM (render_device);
+  gbm_device = meta_render_device_gbm_get_gbm_device (render_device_gbm);
+  gbm_surface = gbm_surface_create (gbm_device,
                                     width, height,
                                     format,
                                     GBM_BO_USE_SCANOUT | GBM_BO_USE_RENDERING);
@@ -1887,7 +1906,7 @@ init_secondary_gpu_state_gpu_copy_mode (MetaRendererNative         *renderer_nat
   egl_native_window = (EGLNativeWindowType) gbm_surface;
   egl_surface =
     meta_egl_create_window_surface (egl,
-                                    renderer_gpu_data->egl_display,
+                                    egl_display,
                                     renderer_gpu_data->secondary.egl_config,
                                     egl_native_window,
                                     NULL,
@@ -1981,8 +2000,8 @@ init_secondary_gpu_state_cpu_copy_mode (MetaRendererNative         *renderer_nat
   CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
   MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
   MetaOnscreenNativeSecondaryGpuState *secondary_gpu_state;
+  MetaRenderDevice *render_device;
   MetaGpuKms *gpu_kms;
-  MetaDeviceFile *device_file;
   int width, height;
   unsigned int i;
   uint32_t drm_format;
@@ -2000,10 +2019,10 @@ init_secondary_gpu_state_cpu_copy_mode (MetaRendererNative         *renderer_nat
   height = cogl_framebuffer_get_height (framebuffer);
 
   gpu_kms = META_GPU_KMS (meta_crtc_get_gpu (onscreen_native->crtc));
-  device_file = renderer_gpu_data->device_file;
+  render_device = renderer_gpu_data->render_device;
   meta_topic (META_DEBUG_KMS,
               "Secondary GPU %s using DRM format '%s' (0x%x) for a %dx%d output.",
-              meta_device_file_get_path (device_file),
+              meta_render_device_get_name (render_device),
               meta_drm_format_to_string (&tmp, drm_format),
               drm_format,
               width, height);
@@ -2015,16 +2034,19 @@ init_secondary_gpu_state_cpu_copy_mode (MetaRendererNative         *renderer_nat
 
   for (i = 0; i < G_N_ELEMENTS (secondary_gpu_state->cpu.dumb_fbs); i++)
     {
-      secondary_gpu_state->cpu.dumb_fbs[i] =
-        meta_drm_buffer_dumb_new (device_file,
-                                  width, height,
-                                  drm_format,
-                                  error);
-      if (!secondary_gpu_state->cpu.dumb_fbs[i])
+      MetaDrmBuffer *dumb_buffer;
+
+      dumb_buffer = meta_render_device_allocate_dumb_buf (render_device,
+                                                          width, height,
+                                                          drm_format,
+                                                          error);
+      if (!dumb_buffer)
         {
           secondary_gpu_state_free (secondary_gpu_state);
           return FALSE;
         }
+
+      secondary_gpu_state->cpu.dumb_fbs[i] = META_DRM_BUFFER_DUMB (dumb_buffer);
     }
 
   /*
@@ -2124,7 +2146,10 @@ meta_onscreen_native_dispose (GObject *object)
   switch (renderer_gpu_data->mode)
     {
     case META_RENDERER_NATIVE_MODE_GBM:
-      g_clear_object (&onscreen_native->gbm.next_fb);
+      /* flip state takes a reference on the onscreen so there should
+       * never be outstanding flips when we reach here. */
+      g_warn_if_fail (onscreen_native->gbm.next_fb == NULL);
+
       free_current_bo (onscreen);
       break;
     case META_RENDERER_NATIVE_MODE_SURFACELESS:
diff --git a/src/backends/native/meta-onscreen-native.h b/src/backends/native/meta-onscreen-native.h
index 5c99181d3..3a85ace26 100644
--- a/src/backends/native/meta-onscreen-native.h
+++ b/src/backends/native/meta-onscreen-native.h
@@ -40,10 +40,8 @@ void meta_onscreen_native_finish_frame (CoglOnscreen *onscreen,
 
 void meta_onscreen_native_dummy_power_save_page_flip (CoglOnscreen *onscreen);
 
-gboolean meta_onscreen_native_is_buffer_scanout_compatible (CoglOnscreen *onscreen,
-                                                            uint32_t      drm_format,
-                                                            uint64_t      drm_modifier,
-                                                            uint32_t      stride);
+gboolean meta_onscreen_native_is_buffer_scanout_compatible (CoglOnscreen  *onscreen,
+                                                            MetaDrmBuffer *fb);
 
 void meta_onscreen_native_set_view (CoglOnscreen     *onscreen,
                                     MetaRendererView *view);
diff --git a/src/backends/native/meta-output-kms.c b/src/backends/native/meta-output-kms.c
index f35cdf04e..4359b1161 100644
--- a/src/backends/native/meta-output-kms.c
+++ b/src/backends/native/meta-output-kms.c
@@ -132,7 +132,6 @@ add_common_modes (MetaOutputInfo *output_info,
 {
   MetaCrtcMode *crtc_mode;
   GPtrArray *array;
-  float refresh_rate;
   unsigned i;
   unsigned max_hdisplay = 0;
   unsigned max_vdisplay = 0;
@@ -144,17 +143,15 @@ add_common_modes (MetaOutputInfo *output_info,
 
   for (i = 0; i < output_info->n_modes; i++)
     {
-      MetaCrtcMode *crtc_mode = output_info->modes[i];
-      MetaCrtcModeKms *crtc_mode_kms = META_CRTC_MODE_KMS (crtc_mode);
-      MetaKmsMode *kms_mode = meta_crtc_mode_kms_get_kms_mode (crtc_mode_kms);
-      const drmModeModeInfo *drm_mode = meta_kms_mode_get_drm_mode (kms_mode);
+      const MetaCrtcModeInfo *crtc_mode_info =
+        meta_crtc_mode_get_info (output_info->modes[i]);
       float bandwidth;
 
-      refresh_rate = meta_calculate_drm_mode_refresh_rate (drm_mode);
-      bandwidth = refresh_rate * drm_mode->hdisplay * drm_mode->vdisplay;
-      max_hdisplay = MAX (max_hdisplay, drm_mode->hdisplay);
-      max_vdisplay = MAX (max_vdisplay, drm_mode->vdisplay);
-      max_refresh_rate = MAX (max_refresh_rate, refresh_rate);
+      bandwidth = crtc_mode_info->refresh_rate * crtc_mode_info->width *
+                  crtc_mode_info->height;
+      max_hdisplay = MAX (max_hdisplay, crtc_mode_info->width);
+      max_vdisplay = MAX (max_vdisplay, crtc_mode_info->height);
+      max_refresh_rate = MAX (max_refresh_rate, crtc_mode_info->refresh_rate);
       max_bandwidth = MAX (max_bandwidth, bandwidth);
     }
 
@@ -175,6 +172,8 @@ add_common_modes (MetaOutputInfo *output_info,
       MetaKmsMode *fallback_mode = l->data;
       const drmModeModeInfo *drm_mode;
       float bandwidth;
+      float refresh_rate;
+      gboolean is_duplicate = FALSE;
 
       if (!(meta_kms_mode_get_flags (fallback_mode) & flag_filter))
         continue;
@@ -188,6 +187,23 @@ add_common_modes (MetaOutputInfo *output_info,
           bandwidth > max_bandwidth)
         continue;
 
+      for (i = 0; i < output_info->n_modes; i++)
+        {
+          const MetaCrtcModeInfo *crtc_mode_info =
+            meta_crtc_mode_get_info (output_info->modes[i]);
+
+          if (drm_mode->hdisplay == crtc_mode_info->width &&
+              drm_mode->vdisplay == crtc_mode_info->height &&
+              fabs (1 - (refresh_rate / crtc_mode_info->refresh_rate)) <
+              SYNC_TOLERANCE)
+            {
+              is_duplicate = TRUE;
+              break;
+            }
+        }
+      if (is_duplicate)
+        continue;
+
       crtc_mode = meta_gpu_kms_get_mode_from_kms_mode (gpu_kms, fallback_mode);
       g_ptr_array_add (array, crtc_mode);
     }
diff --git a/src/backends/native/meta-render-device-egl-stream.c b/src/backends/native/meta-render-device-egl-stream.c
new file mode 100644
index 000000000..fa287a66d
--- /dev/null
+++ b/src/backends/native/meta-render-device-egl-stream.c
@@ -0,0 +1,286 @@
+/*
+ * Copyright (C) 2016-2021 Red Hat Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include "backends/native/meta-render-device-egl-stream.h"
+
+#include "backends/meta-backend-private.h"
+
+struct _MetaRenderDeviceEglStream
+{
+  MetaRenderDevice parent;
+
+  EGLDeviceEXT egl_device;
+};
+
+static GInitableIface *initable_parent_iface;
+
+static void
+initable_iface_init (GInitableIface *initable_iface);
+
+G_DEFINE_TYPE_WITH_CODE (MetaRenderDeviceEglStream, meta_render_device_egl_stream,
+                         META_TYPE_RENDER_DEVICE,
+                         G_IMPLEMENT_INTERFACE (G_TYPE_INITABLE,
+                                                initable_iface_init))
+
+static EGLDisplay
+get_egl_device_display (MetaRenderDevice  *render_device,
+                        EGLDeviceEXT       egl_device,
+                        GError           **error)
+{
+  MetaBackend *backend = meta_render_device_get_backend (render_device);
+  MetaEgl *egl = meta_backend_get_egl (backend);
+  MetaDeviceFile *device_file =
+    meta_render_device_get_device_file (render_device);
+  int kms_fd = meta_device_file_get_fd (device_file);
+  EGLint platform_attribs[] = {
+    EGL_DRM_MASTER_FD_EXT, kms_fd,
+    EGL_NONE
+  };
+
+  return meta_egl_get_platform_display (egl, EGL_PLATFORM_DEVICE_EXT,
+                                        (void *) egl_device,
+                                        platform_attribs,
+                                        error);
+}
+
+static int
+count_mode_setting_devices (MetaBackend *backend)
+{
+  return g_list_length (meta_backend_get_gpus (backend));
+}
+
+static const char *
+get_drm_device_file (MetaEgl     *egl,
+                     EGLDeviceEXT device,
+                     GError     **error)
+{
+  if (!meta_egl_egl_device_has_extensions (egl, device,
+                                           NULL,
+                                           "EGL_EXT_device_drm",
+                                           NULL))
+    {
+      g_set_error (error, G_IO_ERROR,
+                   G_IO_ERROR_FAILED,
+                   "Missing required EGLDevice extension EGL_EXT_device_drm");
+      return NULL;
+    }
+
+  return meta_egl_query_device_string (egl, device,
+                                       EGL_DRM_DEVICE_FILE_EXT,
+                                       error);
+}
+
+static EGLDeviceEXT
+find_egl_device (MetaRenderDevice  *render_device,
+                 GError           **error)
+{
+  MetaBackend *backend = meta_render_device_get_backend (render_device);
+  MetaEgl *egl = meta_backend_get_egl (backend);
+  g_autofree const char **missing_extensions = NULL;
+  MetaDeviceFile *device_file =
+    meta_render_device_get_device_file (render_device);
+  EGLint num_devices;
+  g_autofree EGLDeviceEXT *devices = NULL;
+  const char *device_file_path;
+  EGLDeviceEXT device;
+  EGLint i;
+
+  if (!meta_egl_has_extensions (egl,
+                                EGL_NO_DISPLAY,
+                                &missing_extensions,
+                                "EGL_EXT_device_base",
+                                NULL))
+    {
+      g_autofree char *missing_extensions_str = NULL;
+
+      missing_extensions_str = g_strjoinv (", ", (char **) missing_extensions);
+      g_set_error (error, G_IO_ERROR,
+                   G_IO_ERROR_FAILED,
+                   "Missing EGL extensions required for EGLDevice renderer: %s",
+                   missing_extensions_str);
+      return EGL_NO_DEVICE_EXT;
+    }
+
+  if (!meta_egl_query_devices (egl, 0, NULL, &num_devices, error))
+    return EGL_NO_DEVICE_EXT;
+
+  devices = g_new0 (EGLDeviceEXT, num_devices);
+  if (!meta_egl_query_devices (egl, num_devices, devices, &num_devices,
+                               error))
+    return EGL_NO_DEVICE_EXT;
+
+  device_file_path = meta_device_file_get_path (device_file);
+
+  device = EGL_NO_DEVICE_EXT;
+  for (i = 0; i < num_devices; i++)
+    {
+      const char *egl_device_drm_path;
+
+      g_clear_error (error);
+
+      egl_device_drm_path = get_drm_device_file (egl, devices[i], error);
+      if (!egl_device_drm_path)
+        continue;
+
+      if (g_str_equal (egl_device_drm_path, device_file_path))
+        {
+          device = devices[i];
+          break;
+        }
+    }
+
+  if (device == EGL_NO_DEVICE_EXT)
+    {
+      if (!*error)
+        g_set_error (error, G_IO_ERROR,
+                     G_IO_ERROR_FAILED,
+                     "Failed to find matching EGLDeviceEXT");
+      return EGL_NO_DEVICE_EXT;
+    }
+
+  return device;
+}
+
+static gboolean
+meta_render_device_egl_stream_initable_init (GInitable     *initable,
+                                             GCancellable  *cancellable,
+                                             GError       **error)
+{
+  MetaRenderDevice *render_device = META_RENDER_DEVICE (initable);
+  MetaRenderDeviceEglStream *render_device_egl_stream =
+    META_RENDER_DEVICE_EGL_STREAM (initable);
+  MetaBackend *backend = meta_render_device_get_backend (render_device);
+  EGLDeviceEXT egl_device;
+  EGLDisplay egl_display;
+  g_autofree const char **missing_extensions = NULL;
+
+  if (count_mode_setting_devices (backend) != 1)
+    {
+      g_set_error (error, G_IO_ERROR,
+                   G_IO_ERROR_FAILED,
+                   "EGLDevice currently only works with single GPU systems");
+      return FALSE;
+    }
+
+  egl_device = find_egl_device (render_device, error);
+  if (egl_device == EGL_NO_DEVICE_EXT)
+    return FALSE;
+
+  render_device_egl_stream->egl_device = egl_device;
+
+  if (!initable_parent_iface->init (initable, cancellable, error))
+    return FALSE;
+
+  egl_display = meta_render_device_get_egl_display (render_device);
+  if (egl_display == EGL_NO_DISPLAY)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "EGLStream render device requires an EGL display");
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+static void
+initable_iface_init (GInitableIface *initable_iface)
+{
+  initable_parent_iface = g_type_interface_peek_parent (initable_iface);
+
+  initable_iface->init = meta_render_device_egl_stream_initable_init;
+}
+
+static EGLDisplay
+meta_render_device_egl_stream_create_egl_display (MetaRenderDevice  *render_device,
+                                                  GError           **error)
+{
+  MetaRenderDeviceEglStream *render_device_egl_stream =
+    META_RENDER_DEVICE_EGL_STREAM (render_device);
+  EGLDeviceEXT egl_device = render_device_egl_stream->egl_device;
+  MetaBackend *backend = meta_render_device_get_backend (render_device);
+  MetaEgl *egl = meta_backend_get_egl (backend);
+  EGLDisplay egl_display;
+  g_autofree const char **missing_extensions = NULL;
+
+  egl_display = get_egl_device_display (render_device, egl_device, error);
+  if (egl_display == EGL_NO_DISPLAY)
+    return EGL_NO_DISPLAY;
+
+  if (!meta_egl_initialize (egl, egl_display, error))
+    {
+      meta_egl_terminate (egl, egl_display, NULL);
+      return EGL_NO_DISPLAY;
+    }
+
+  if (!meta_egl_has_extensions (egl,
+                                egl_display,
+                                &missing_extensions,
+                                "EGL_NV_output_drm_flip_event",
+                                "EGL_EXT_output_base",
+                                "EGL_EXT_output_drm",
+                                "EGL_KHR_stream",
+                                "EGL_KHR_stream_producer_eglsurface",
+                                "EGL_EXT_stream_consumer_egloutput",
+                                "EGL_EXT_stream_acquire_mode",
+                                NULL))
+    {
+      g_autofree char *missing_extensions_str = NULL;
+
+      meta_egl_terminate (egl, egl_display, NULL);
+
+      missing_extensions_str = g_strjoinv (", ", (char **) missing_extensions);
+      g_set_error (error, G_IO_ERROR,
+                   G_IO_ERROR_FAILED,
+                   "Missing EGL extensions required for EGLDevice renderer: %s",
+                   missing_extensions_str);
+      meta_egl_terminate (egl, egl_display, NULL);
+      return EGL_NO_DISPLAY;
+    }
+
+  return egl_display;
+}
+
+static void
+meta_render_device_egl_stream_class_init (MetaRenderDeviceEglStreamClass *klass)
+{
+  MetaRenderDeviceClass *render_device_class = META_RENDER_DEVICE_CLASS (klass);
+
+  render_device_class->create_egl_display =
+    meta_render_device_egl_stream_create_egl_display;
+}
+
+static void
+meta_render_device_egl_stream_init (MetaRenderDeviceEglStream *render_device_egl_stream)
+{
+}
+
+MetaRenderDeviceEglStream *
+meta_render_device_egl_stream_new (MetaBackend     *backend,
+                                   MetaDeviceFile  *device_file,
+                                   GError         **error)
+{
+  return g_initable_new (META_TYPE_RENDER_DEVICE_EGL_STREAM,
+                         NULL, error,
+                         "backend", backend,
+                         "device-file", device_file,
+                         NULL);
+}
diff --git a/src/backends/native/meta-render-device-egl-stream.h b/src/backends/native/meta-render-device-egl-stream.h
new file mode 100644
index 000000000..b4b66b8b1
--- /dev/null
+++ b/src/backends/native/meta-render-device-egl-stream.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2021 Red Hat Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ */
+
+#ifndef META_RENDER_DEVICE_EGL_STREAM_H
+#define META_RENDER_DEVICE_EGL_STREAM_H
+
+#include "backends/native/meta-render-device-private.h"
+
+#define META_TYPE_RENDER_DEVICE_EGL_STREAM (meta_render_device_egl_stream_get_type ())
+G_DECLARE_FINAL_TYPE (MetaRenderDeviceEglStream, meta_render_device_egl_stream,
+                      META, RENDER_DEVICE_EGL_STREAM,
+                      MetaRenderDevice)
+
+MetaRenderDeviceEglStream * meta_render_device_egl_stream_new (MetaBackend     *backend,
+                                                               MetaDeviceFile  *device_file,
+                                                               GError         **error);
+
+#endif /* META_RENDER_DEVICE_EGL_STREAM_H */
diff --git a/src/backends/native/meta-render-device-gbm.c b/src/backends/native/meta-render-device-gbm.c
new file mode 100644
index 000000000..05f212bf2
--- /dev/null
+++ b/src/backends/native/meta-render-device-gbm.c
@@ -0,0 +1,227 @@
+/*
+ * Copyright (C) 2016-2021 Red Hat Inc.
+ * Copyright (c) 2018-2019 DisplayLink (UK) Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include "backends/native/meta-render-device-gbm.h"
+
+#include <gbm.h>
+
+#include "backends/meta-backend-private.h"
+#include "backends/native/meta-drm-buffer-gbm.h"
+#include "backends/native/meta-drm-buffer-import.h"
+
+struct _MetaRenderDeviceGbm
+{
+  MetaRenderDevice parent;
+
+  struct gbm_device *gbm_device;
+};
+
+static GInitableIface *initable_parent_iface;
+
+static void
+initable_iface_init (GInitableIface *initable_iface);
+
+G_DEFINE_TYPE_WITH_CODE (MetaRenderDeviceGbm, meta_render_device_gbm,
+                         META_TYPE_RENDER_DEVICE,
+                         G_IMPLEMENT_INTERFACE (G_TYPE_INITABLE,
+                                                initable_iface_init))
+
+static gboolean
+meta_render_device_gbm_initable_init (GInitable     *initable,
+                                      GCancellable  *cancellable,
+                                      GError       **error)
+{
+  MetaRenderDevice *render_device = META_RENDER_DEVICE (initable);
+  MetaRenderDeviceGbm *render_device_gbm = META_RENDER_DEVICE_GBM (initable);
+  MetaDeviceFile *device_file =
+    meta_render_device_get_device_file (render_device);
+  struct gbm_device *gbm_device;
+
+  gbm_device = gbm_create_device (meta_device_file_get_fd (device_file));
+  if (!gbm_device)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "Failed to create gbm device: %s", g_strerror (errno));
+      return FALSE;
+    }
+
+  render_device_gbm->gbm_device = gbm_device;
+
+  return initable_parent_iface->init (initable, cancellable, error);
+}
+
+static void
+initable_iface_init (GInitableIface *initable_iface)
+{
+  initable_parent_iface = g_type_interface_peek_parent (initable_iface);
+
+  initable_iface->init = meta_render_device_gbm_initable_init;
+}
+
+static MetaDrmBuffer *
+meta_render_device_gbm_import_dma_buf (MetaRenderDevice  *render_device,
+                                       MetaDrmBuffer     *buffer,
+                                       GError           **error)
+{
+  MetaRenderDeviceGbm *render_device_gbm =
+    META_RENDER_DEVICE_GBM (render_device);
+  MetaDeviceFile *device_file;
+  MetaDrmBufferGbm *buffer_gbm;
+  MetaDrmBufferImport *buffer_import;
+
+  if (!META_IS_DRM_BUFFER_GBM (buffer))
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
+                   "Can only import gbm backed DMA buffers");
+      return NULL;
+    }
+
+  device_file = meta_render_device_get_device_file (render_device);
+  buffer_gbm = META_DRM_BUFFER_GBM (buffer);
+  buffer_import = meta_drm_buffer_import_new (device_file,
+                                              render_device_gbm->gbm_device,
+                                              buffer_gbm,
+                                              error);
+  if (!buffer_import)
+    return NULL;
+
+  return META_DRM_BUFFER (buffer_import);
+}
+
+static EGLDisplay
+meta_render_device_gbm_create_egl_display (MetaRenderDevice  *render_device,
+                                           GError           **error)
+{
+  MetaRenderDeviceGbm *render_device_gbm =
+    META_RENDER_DEVICE_GBM (render_device);
+  MetaBackend *backend = meta_render_device_get_backend (render_device);
+  MetaEgl *egl = meta_backend_get_egl (backend);
+  EGLDisplay egl_display;
+
+  if (!meta_egl_has_extensions (egl, EGL_NO_DISPLAY, NULL,
+                                "EGL_MESA_platform_gbm",
+                                NULL) &&
+      !meta_egl_has_extensions (egl, EGL_NO_DISPLAY, NULL,
+                                "EGL_KHR_platform_gbm",
+                                NULL))
+    {
+      g_set_error (error, G_IO_ERROR,
+                   G_IO_ERROR_FAILED,
+                   "Missing extension for GBM renderer: EGL_KHR_platform_gbm");
+      return EGL_NO_DISPLAY;
+    }
+
+  egl_display = meta_egl_get_platform_display (egl,
+                                               EGL_PLATFORM_GBM_KHR,
+                                               render_device_gbm->gbm_device,
+                                               NULL, error);
+  if (egl_display == EGL_NO_DISPLAY)
+    return EGL_NO_DISPLAY;
+
+  if (!meta_egl_initialize (egl, egl_display, error))
+    {
+      meta_egl_terminate (egl, egl_display, NULL);
+      return EGL_NO_DISPLAY;
+    }
+
+  return egl_display;
+}
+
+static MetaDrmBuffer *
+meta_render_device_gbm_allocate_dma_buf (MetaRenderDevice    *render_device,
+                                         int                  width,
+                                         int                  height,
+                                         uint32_t             format,
+                                         MetaDrmBufferFlags   flags,
+                                         GError             **error)
+{
+  MetaRenderDeviceGbm *render_device_gbm =
+    META_RENDER_DEVICE_GBM (render_device);
+  MetaDeviceFile *device_file;
+  struct gbm_bo *gbm_bo;
+  MetaDrmBufferGbm *buffer_gbm;
+
+  gbm_bo = gbm_bo_create (render_device_gbm->gbm_device,
+                          width, height, format,
+                          GBM_BO_USE_RENDERING | GBM_BO_USE_LINEAR);
+  if (!gbm_bo)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "Failed to gbm_bo: %s", g_strerror (errno));
+      return NULL;
+    }
+
+  device_file = meta_render_device_get_device_file (render_device);
+  buffer_gbm = meta_drm_buffer_gbm_new_take (device_file, gbm_bo, flags,
+                                             error);
+  return META_DRM_BUFFER (buffer_gbm);
+}
+
+static void
+meta_render_device_gbm_finalize (GObject *object)
+{
+  MetaRenderDeviceGbm *render_device_gbm = META_RENDER_DEVICE_GBM (object);
+
+  g_clear_pointer (&render_device_gbm->gbm_device, gbm_device_destroy);
+
+  G_OBJECT_CLASS (meta_render_device_gbm_parent_class)->finalize (object);
+}
+
+static void
+meta_render_device_gbm_class_init (MetaRenderDeviceGbmClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+  MetaRenderDeviceClass *render_device_class = META_RENDER_DEVICE_CLASS (klass);
+
+  object_class->finalize = meta_render_device_gbm_finalize;
+
+  render_device_class->create_egl_display =
+    meta_render_device_gbm_create_egl_display;
+  render_device_class->allocate_dma_buf =
+    meta_render_device_gbm_allocate_dma_buf;
+  render_device_class->import_dma_buf =
+    meta_render_device_gbm_import_dma_buf;
+}
+
+static void
+meta_render_device_gbm_init (MetaRenderDeviceGbm *render_device_gbm)
+{
+}
+
+MetaRenderDeviceGbm *
+meta_render_device_gbm_new (MetaBackend     *backend,
+                            MetaDeviceFile  *device_file,
+                            GError         **error)
+{
+  return g_initable_new (META_TYPE_RENDER_DEVICE_GBM,
+                         NULL, error,
+                         "backend", backend,
+                         "device-file", device_file,
+                         NULL);
+}
+
+struct gbm_device *
+meta_render_device_gbm_get_gbm_device (MetaRenderDeviceGbm *render_device_gbm)
+{
+  return render_device_gbm->gbm_device;
+}
diff --git a/src/backends/native/meta-render-device-gbm.h b/src/backends/native/meta-render-device-gbm.h
new file mode 100644
index 000000000..4c8b0516c
--- /dev/null
+++ b/src/backends/native/meta-render-device-gbm.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2021 Red Hat Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ */
+
+#ifndef META_RENDER_DEVICE_GBM_H
+#define META_RENDER_DEVICE_GBM_H
+
+#include "backends/native/meta-render-device-private.h"
+
+#define META_TYPE_RENDER_DEVICE_GBM (meta_render_device_gbm_get_type ())
+G_DECLARE_FINAL_TYPE (MetaRenderDeviceGbm, meta_render_device_gbm,
+                      META, RENDER_DEVICE_GBM,
+                      MetaRenderDevice)
+
+MetaRenderDeviceGbm * meta_render_device_gbm_new (MetaBackend     *backend,
+                                                  MetaDeviceFile  *device_file,
+                                                  GError         **error);
+
+struct gbm_device * meta_render_device_gbm_get_gbm_device (MetaRenderDeviceGbm *render_device_gbm);
+
+#endif /* META_RENDER_DEVICE_GBM_H */
diff --git a/src/backends/native/meta-render-device-private.h b/src/backends/native/meta-render-device-private.h
new file mode 100644
index 000000000..564be4fae
--- /dev/null
+++ b/src/backends/native/meta-render-device-private.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2021 Red Hat Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ */
+
+#ifndef META_RENDER_DEVICE_PRIVATE_H
+#define META_RENDER_DEVICE_PRIVATE_H
+
+#include <gio/gio.h>
+#include <glib-object.h>
+
+#include "backends/meta-egl.h"
+#include "backends/native/meta-device-pool.h"
+#include "backends/native/meta-drm-buffer.h"
+#include "backends/native/meta-render-device.h"
+
+struct _MetaRenderDeviceClass
+{
+  GObjectClass parent_class;
+
+  EGLDisplay (* create_egl_display) (MetaRenderDevice  *render_device,
+                                     GError           **error);
+
+  MetaDrmBuffer * (* allocate_dma_buf) (MetaRenderDevice    *render_device,
+                                        int                  width,
+                                        int                  height,
+                                        uint32_t             format,
+                                        MetaDrmBufferFlags   flags,
+                                        GError             **error);
+  MetaDrmBuffer * (* import_dma_buf) (MetaRenderDevice  *render_device,
+                                      MetaDrmBuffer     *buffer,
+                                      GError           **error);
+};
+
+#endif /* META_RENDER_DEVICE_PRIVATE_H */
diff --git a/src/backends/native/meta-render-device-surfaceless.c b/src/backends/native/meta-render-device-surfaceless.c
new file mode 100644
index 000000000..fbeea3a7c
--- /dev/null
+++ b/src/backends/native/meta-render-device-surfaceless.c
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2020-2021 Red Hat Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include "backends/native/meta-render-device-surfaceless.h"
+
+#include "backends/meta-backend-private.h"
+#include "backends/meta-egl.h"
+
+struct _MetaRenderDeviceSurfaceless
+{
+  MetaRenderDevice parent;
+};
+
+G_DEFINE_TYPE (MetaRenderDeviceSurfaceless, meta_render_device_surfaceless,
+               META_TYPE_RENDER_DEVICE)
+
+static EGLDisplay
+meta_render_device_surfaceless_create_egl_display (MetaRenderDevice  *render_device,
+                                                   GError           **error)
+{
+  MetaBackend *backend = meta_render_device_get_backend (render_device);
+  MetaEgl *egl = meta_backend_get_egl (backend);
+  EGLDisplay egl_display;
+
+  if (!meta_egl_has_extensions (egl, EGL_NO_DISPLAY, NULL,
+                                "EGL_MESA_platform_surfaceless",
+                                NULL))
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "Missing EGL platform required for surfaceless context: "
+                   "EGL_MESA_platform_surfaceless");
+      return EGL_NO_DISPLAY;
+    }
+
+  egl_display = meta_egl_get_platform_display (egl,
+                                               EGL_PLATFORM_SURFACELESS_MESA,
+                                               EGL_DEFAULT_DISPLAY,
+                                               NULL, error);
+  if (egl_display == EGL_NO_DISPLAY)
+    return EGL_NO_DISPLAY;
+
+  if (!meta_egl_initialize (egl, egl_display, error))
+    {
+      meta_egl_terminate (egl, egl_display, NULL);
+      return EGL_NO_DISPLAY;
+    }
+
+  return egl_display;
+}
+
+static void
+meta_render_device_surfaceless_class_init (MetaRenderDeviceSurfacelessClass *klass)
+{
+  MetaRenderDeviceClass *render_device_class = META_RENDER_DEVICE_CLASS (klass);
+
+  render_device_class->create_egl_display =
+    meta_render_device_surfaceless_create_egl_display;
+}
+
+static void
+meta_render_device_surfaceless_init (MetaRenderDeviceSurfaceless *render_device_surfaceless)
+{
+}
+
+MetaRenderDeviceSurfaceless *
+meta_render_device_surfaceless_new (MetaBackend  *backend,
+                                    GError      **error)
+{
+  return g_initable_new (META_TYPE_RENDER_DEVICE_SURFACELESS,
+                         NULL, error,
+                         "backend", backend,
+                         NULL);
+}
diff --git a/src/wayland/meta-wayland-wl-shell.h b/src/backends/native/meta-render-device-surfaceless.h
similarity index 52%
rename from src/wayland/meta-wayland-wl-shell.h
rename to src/backends/native/meta-render-device-surfaceless.h
index 4a62d8a72..b85fc6eeb 100644
--- a/src/wayland/meta-wayland-wl-shell.h
+++ b/src/backends/native/meta-render-device-surfaceless.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2015 Red Hat, Inc.
+ * Copyright (C) 2021 Red Hat Inc.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -15,19 +15,20 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
  * 02111-1307, USA.
+ *
  */
 
-#ifndef META_WAYLAND_WL_SHELL_H
-#define META_WAYLAND_WL_SHELL_H
+#ifndef META_RENDER_DEVICE_SURFACELESS_H
+#define META_RENDER_DEVICE_SURFACELESS_H
 
-#include "wayland/meta-wayland-shell-surface.h"
+#include "backends/native/meta-render-device-private.h"
 
-#define META_TYPE_WAYLAND_WL_SHELL_SURFACE (meta_wayland_wl_shell_surface_get_type ())
-G_DECLARE_FINAL_TYPE (MetaWaylandWlShellSurface,
-                      meta_wayland_wl_shell_surface,
-                      META, WAYLAND_WL_SHELL_SURFACE,
-                      MetaWaylandShellSurface);
+#define META_TYPE_RENDER_DEVICE_SURFACELESS (meta_render_device_surfaceless_get_type ())
+G_DECLARE_FINAL_TYPE (MetaRenderDeviceSurfaceless, meta_render_device_surfaceless,
+                      META, RENDER_DEVICE_SURFACELESS,
+                      MetaRenderDevice)
 
-void meta_wayland_wl_shell_init (MetaWaylandCompositor *compositor);
+MetaRenderDeviceSurfaceless * meta_render_device_surfaceless_new (MetaBackend  *backend,
+                                                                  GError      **error);
 
-#endif /* META_WAYLAND_WL_SHELL_H */
+#endif /* META_RENDER_DEVICE_SURFACELESS_H */
diff --git a/src/backends/native/meta-render-device.c b/src/backends/native/meta-render-device.c
new file mode 100644
index 000000000..982f30814
--- /dev/null
+++ b/src/backends/native/meta-render-device.c
@@ -0,0 +1,412 @@
+/*
+ * Copyright (C) 2021 Red Hat Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include "backends/native/meta-render-device-private.h"
+
+#include "backends/meta-backend-private.h"
+#include "backends/meta-egl.h"
+#include "backends/native/meta-backend-native-types.h"
+#include "backends/native/meta-drm-buffer-dumb.h"
+
+enum
+{
+  PROP_0,
+
+  PROP_BACKEND,
+  PROP_DEVICE_FILE,
+
+  N_PROPS
+};
+
+static GParamSpec *obj_props[N_PROPS];
+
+typedef struct _MetaRenderDevicePrivate
+{
+  MetaBackend *backend;
+
+  MetaDeviceFile *device_file;
+
+  EGLDisplay egl_display;
+  EGLConfig egl_config;
+
+  gboolean is_hardware_rendering;
+} MetaRenderDevicePrivate;
+
+static void
+initable_iface_init (GInitableIface *initable_iface);
+
+G_DEFINE_ABSTRACT_TYPE_WITH_CODE (MetaRenderDevice, meta_render_device,
+                                  G_TYPE_OBJECT,
+                                  G_ADD_PRIVATE (MetaRenderDevice)
+                                  G_IMPLEMENT_INTERFACE (G_TYPE_INITABLE,
+                                                         initable_iface_init))
+
+static EGLDisplay
+meta_render_device_create_egl_display (MetaRenderDevice  *render_device,
+                                       GError           **error)
+{
+  MetaRenderDeviceClass *klass = META_RENDER_DEVICE_GET_CLASS (render_device);
+
+  return klass->create_egl_display (render_device, error);
+}
+
+static void
+detect_hardware_rendering (MetaRenderDevice *render_device)
+{
+  MetaRenderDevicePrivate *priv =
+    meta_render_device_get_instance_private (render_device);
+  MetaEgl *egl = meta_backend_get_egl (priv->backend);
+  g_autoptr (GError) error = NULL;
+  EGLint *attributes;
+  EGLContext egl_context;
+  const char *renderer_str;
+
+  attributes = (EGLint[]) {
+    EGL_CONTEXT_CLIENT_VERSION, 2,
+    EGL_NONE
+  };
+  egl_context = meta_egl_create_context (egl,
+                                         priv->egl_display,
+                                         EGL_NO_CONFIG_KHR,
+                                         EGL_NO_CONTEXT,
+                                         attributes,
+                                         &error);
+  if (egl_context == EGL_NO_CONTEXT)
+    {
+      meta_topic (META_DEBUG_RENDER, "Failed to create EGLContext for %s: %s",
+                  meta_device_file_get_path (priv->device_file),
+                  error->message);
+      return;
+    }
+
+  if (!meta_egl_make_current (egl,
+                              priv->egl_display,
+                              EGL_NO_SURFACE,
+                              EGL_NO_SURFACE,
+                              egl_context,
+                              &error))
+    {
+      g_warning ("Failed to detect hardware rendering: eglMakeCurrent(): %s",
+                 error->message);
+      goto out_has_context;
+    }
+
+  renderer_str = (const char *) glGetString (GL_RENDERER);
+  if (g_str_has_prefix (renderer_str, "llvmpipe") ||
+      g_str_has_prefix (renderer_str, "softpipe") ||
+      g_str_has_prefix (renderer_str, "swrast"))
+    goto out_has_context;
+
+  priv->is_hardware_rendering = TRUE;
+
+out_has_context:
+  meta_egl_destroy_context (egl, priv->egl_display, egl_context, NULL);
+}
+
+static void
+init_egl (MetaRenderDevice *render_device)
+{
+  MetaRenderDevicePrivate *priv =
+    meta_render_device_get_instance_private (render_device);
+  MetaEgl *egl = meta_backend_get_egl (priv->backend);
+  g_autoptr (GError) error = NULL;
+  EGLDisplay egl_display;
+
+  meta_egl_bind_api (egl, EGL_OPENGL_ES_API, NULL);
+
+  egl_display = meta_render_device_create_egl_display (render_device, &error);
+  if (egl_display == EGL_NO_DISPLAY)
+    {
+      meta_topic (META_DEBUG_RENDER, "Failed to create EGLDisplay for %s: %s",
+                  meta_device_file_get_path (priv->device_file),
+                  error->message);
+      return;
+    }
+
+  priv->egl_display = egl_display;
+  detect_hardware_rendering (render_device);
+}
+
+static gboolean
+meta_render_device_initable_init (GInitable     *initable,
+                                  GCancellable  *cancellable,
+                                  GError       **error)
+{
+  MetaRenderDevice *render_device = META_RENDER_DEVICE (initable);
+
+  init_egl (render_device);
+
+  return TRUE;
+}
+
+static void
+initable_iface_init (GInitableIface *initable_iface)
+{
+  initable_iface->init = meta_render_device_initable_init;
+}
+
+static void
+meta_render_device_get_property (GObject    *object,
+                                 guint       prop_id,
+                                 GValue     *value,
+                                 GParamSpec *pspec)
+{
+  MetaRenderDevice *render_device = META_RENDER_DEVICE (object);
+  MetaRenderDevicePrivate *priv =
+    meta_render_device_get_instance_private (render_device);
+
+  switch (prop_id)
+    {
+    case PROP_BACKEND:
+      g_value_set_object (value, priv->backend);
+      break;
+    case PROP_DEVICE_FILE:
+      g_value_set_pointer (value, priv->device_file);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+}
+
+static void
+meta_render_device_set_property (GObject      *object,
+                                 guint         prop_id,
+                                 const GValue *value,
+                                 GParamSpec   *pspec)
+{
+  MetaRenderDevice *render_device = META_RENDER_DEVICE (object);
+  MetaRenderDevicePrivate *priv =
+    meta_render_device_get_instance_private (render_device);
+
+  switch (prop_id)
+    {
+    case PROP_BACKEND:
+      priv->backend = g_value_get_object (value);
+      break;
+    case PROP_DEVICE_FILE:
+      priv->device_file = g_value_get_pointer (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+}
+
+static void
+meta_render_device_dispose (GObject *object)
+{
+  MetaRenderDevice *render_device = META_RENDER_DEVICE (object);
+  MetaRenderDevicePrivate *priv =
+    meta_render_device_get_instance_private (render_device);
+  MetaEgl *egl = meta_backend_get_egl (priv->backend);
+
+  if (priv->egl_display != EGL_NO_DISPLAY)
+    {
+      meta_egl_terminate (egl, priv->egl_display, NULL);
+      priv->egl_display = EGL_NO_DISPLAY;
+    }
+
+  G_OBJECT_CLASS (meta_render_device_parent_class)->dispose (object);
+}
+
+static void
+meta_render_device_finalize (GObject *object)
+{
+  MetaRenderDevice *render_device = META_RENDER_DEVICE (object);
+  MetaRenderDevicePrivate *priv =
+    meta_render_device_get_instance_private (render_device);
+
+  g_clear_pointer (&priv->device_file, meta_device_file_release);
+
+  G_OBJECT_CLASS (meta_render_device_parent_class)->finalize (object);
+}
+
+static void
+meta_render_device_constructed (GObject *object)
+{
+  MetaRenderDevice *render_device = META_RENDER_DEVICE (object);
+  MetaRenderDevicePrivate *priv =
+    meta_render_device_get_instance_private (render_device);
+
+  if (priv->device_file)
+    meta_device_file_acquire (priv->device_file);
+
+  G_OBJECT_CLASS (meta_render_device_parent_class)->constructed (object);
+}
+
+static void
+meta_render_device_class_init (MetaRenderDeviceClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  object_class->get_property = meta_render_device_get_property;
+  object_class->set_property = meta_render_device_set_property;
+  object_class->constructed = meta_render_device_constructed;
+  object_class->dispose = meta_render_device_dispose;
+  object_class->finalize = meta_render_device_finalize;
+
+  obj_props[PROP_BACKEND] =
+    g_param_spec_object ("backend",
+                         "backend",
+                         "MetaBackend",
+                         META_TYPE_BACKEND,
+                         G_PARAM_READWRITE |
+                         G_PARAM_CONSTRUCT_ONLY |
+                         G_PARAM_STATIC_STRINGS);
+  obj_props[PROP_DEVICE_FILE] =
+    g_param_spec_pointer ("device-file",
+                          "device file",
+                          "MetaDeviceFile",
+                          G_PARAM_READWRITE |
+                          G_PARAM_CONSTRUCT_ONLY |
+                          G_PARAM_STATIC_STRINGS);
+  g_object_class_install_properties (object_class, N_PROPS, obj_props);
+}
+
+static void
+meta_render_device_init (MetaRenderDevice *render_device)
+{
+  MetaRenderDevicePrivate *priv =
+    meta_render_device_get_instance_private (render_device);
+
+  priv->egl_display = EGL_NO_DISPLAY;
+  priv->egl_config = EGL_NO_CONFIG_KHR;
+}
+
+MetaBackend *
+meta_render_device_get_backend (MetaRenderDevice *render_device)
+{
+  MetaRenderDevicePrivate *priv =
+    meta_render_device_get_instance_private (render_device);
+
+  return priv->backend;
+}
+
+MetaDeviceFile *
+meta_render_device_get_device_file (MetaRenderDevice *render_device)
+{
+  MetaRenderDevicePrivate *priv =
+    meta_render_device_get_instance_private (render_device);
+
+  return priv->device_file;
+}
+
+EGLDisplay
+meta_render_device_get_egl_display (MetaRenderDevice *render_device)
+{
+  MetaRenderDevicePrivate *priv =
+    meta_render_device_get_instance_private (render_device);
+
+  return priv->egl_display;
+}
+
+gboolean
+meta_render_device_is_hardware_accelerated (MetaRenderDevice *render_device)
+{
+  MetaRenderDevicePrivate *priv =
+    meta_render_device_get_instance_private (render_device);
+
+  return priv->is_hardware_rendering;
+}
+
+const char *
+meta_render_device_get_name (MetaRenderDevice *render_device)
+{
+  MetaRenderDevicePrivate *priv =
+    meta_render_device_get_instance_private (render_device);
+
+  if (priv->device_file)
+    return meta_device_file_get_path (priv->device_file);
+  else
+    return "(device-less)";
+}
+
+MetaDrmBuffer *
+meta_render_device_allocate_dma_buf (MetaRenderDevice    *render_device,
+                                     int                  width,
+                                     int                  height,
+                                     uint32_t             format,
+                                     MetaDrmBufferFlags   flags,
+                                     GError             **error)
+{
+  MetaRenderDeviceClass *klass = META_RENDER_DEVICE_GET_CLASS (render_device);
+
+  if (klass->allocate_dma_buf)
+    {
+      return klass->allocate_dma_buf (render_device,
+                                      width, height, format,
+                                      flags,
+                                      error);
+    }
+
+  g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+               "Render device '%s' doesn't support allocating DMA buffers",
+               meta_render_device_get_name (render_device));
+
+  return NULL;
+}
+
+MetaDrmBuffer *
+meta_render_device_import_dma_buf (MetaRenderDevice  *render_device,
+                                   MetaDrmBuffer     *buffer,
+                                   GError           **error)
+{
+  MetaRenderDeviceClass *klass = META_RENDER_DEVICE_GET_CLASS (render_device);
+
+  if (klass->import_dma_buf)
+    return klass->import_dma_buf (render_device, buffer, error);
+
+  g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+               "Render device '%s' doesn't importing DMA buffers",
+               meta_render_device_get_name (render_device));
+
+  return NULL;
+}
+
+MetaDrmBuffer *
+meta_render_device_allocate_dumb_buf (MetaRenderDevice  *render_device,
+                                      int                width,
+                                      int                height,
+                                      uint32_t           format,
+                                      GError           **error)
+{
+  MetaRenderDevicePrivate *priv =
+    meta_render_device_get_instance_private (render_device);
+  MetaDrmBufferDumb *buffer_dumb;
+
+  if (!priv->device_file)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
+                   "No device file to allocate from");
+      return NULL;
+    }
+
+  buffer_dumb = meta_drm_buffer_dumb_new (priv->device_file,
+                                          width, height,
+                                          format,
+                                          error);
+  if (!buffer_dumb)
+    return NULL;
+
+  return META_DRM_BUFFER (buffer_dumb);
+}
diff --git a/src/backends/native/meta-render-device.h b/src/backends/native/meta-render-device.h
new file mode 100644
index 000000000..466681353
--- /dev/null
+++ b/src/backends/native/meta-render-device.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2021 Red Hat Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ */
+
+#ifndef META_RENDER_DEVICE_H
+#define META_RENDER_DEVICE_H
+
+#include <glib-object.h>
+
+#include "backends/meta-backend-types.h"
+#include "backends/native/meta-backend-native-types.h"
+
+#define META_TYPE_RENDER_DEVICE (meta_render_device_get_type ())
+G_DECLARE_DERIVABLE_TYPE (MetaRenderDevice, meta_render_device,
+                          META, RENDER_DEVICE,
+                          GObject)
+
+MetaBackend * meta_render_device_get_backend (MetaRenderDevice *render_device);
+
+EGLDisplay meta_render_device_get_egl_display (MetaRenderDevice *render_device);
+
+const char * meta_render_device_get_name (MetaRenderDevice *render_device);
+
+gboolean meta_render_device_is_hardware_accelerated (MetaRenderDevice *render_device);
+
+MetaDeviceFile * meta_render_device_get_device_file (MetaRenderDevice *render_device);
+
+MetaDrmBuffer * meta_render_device_allocate_dma_buf (MetaRenderDevice    *render_device,
+                                                     int                  width,
+                                                     int                  height,
+                                                     uint32_t             format,
+                                                     MetaDrmBufferFlags   flags,
+                                                     GError             **error);
+
+MetaDrmBuffer * meta_render_device_import_dma_buf (MetaRenderDevice  *render_device,
+                                                   MetaDrmBuffer     *buffer,
+                                                   GError           **error);
+
+MetaDrmBuffer * meta_render_device_allocate_dumb_buf (MetaRenderDevice  *render_device,
+                                                      int                width,
+                                                      int                height,
+                                                      uint32_t           format,
+                                                      GError           **error);
+
+#endif /* META_RENDER_DEVICE_H */
diff --git a/src/backends/native/meta-renderer-native-private.h b/src/backends/native/meta-renderer-native-private.h
index 9d51a51c8..e2e133bd9 100644
--- a/src/backends/native/meta-renderer-native-private.h
+++ b/src/backends/native/meta-renderer-native-private.h
@@ -29,6 +29,7 @@
 #define META_RENDERER_NATIVE_PRIVATE_H
 
 #include "backends/meta-gles3.h"
+#include "backends/native/meta-backend-native-types.h"
 #include "backends/native/meta-renderer-native.h"
 
 typedef enum _MetaSharedFramebufferCopyMode
@@ -49,29 +50,16 @@ typedef struct _MetaRendererNativeGpuData
 {
   MetaRendererNative *renderer_native;
 
-  MetaDeviceFile *device_file;
+  MetaRenderDevice *render_device;
   MetaGpuKms *gpu_kms;
 
-  struct {
-    struct gbm_device *device;
-  } gbm;
-
-#ifdef HAVE_EGL_DEVICE
-  struct {
-    EGLDeviceEXT device;
-  } egl;
-#endif
-
   MetaRendererNativeMode mode;
 
-  EGLDisplay egl_display;
-
   /*
    * Fields used for blitting iGPU framebuffer content onto dGPU framebuffers.
    */
   struct {
     MetaSharedFramebufferCopyMode copy_mode;
-    gboolean is_hardware_rendering;
     gboolean has_EGL_EXT_image_dma_buf_import_modifiers;
 
     /* For GPU blit mode */
diff --git a/src/backends/native/meta-renderer-native.c b/src/backends/native/meta-renderer-native.c
index 4c6fa5b70..b38fceecf 100644
--- a/src/backends/native/meta-renderer-native.c
+++ b/src/backends/native/meta-renderer-native.c
@@ -58,10 +58,16 @@
 #include "backends/native/meta-kms-device.h"
 #include "backends/native/meta-kms.h"
 #include "backends/native/meta-onscreen-native.h"
+#include "backends/native/meta-render-device-gbm.h"
+#include "backends/native/meta-render-device-surfaceless.h"
 #include "backends/native/meta-renderer-native-private.h"
 #include "cogl/cogl.h"
 #include "core/boxes-private.h"
 
+#ifdef HAVE_EGL_DEVICE
+#include "backends/native/meta-render-device-egl-stream.h"
+#endif
+
 #ifndef EGL_DRM_MASTER_FD_EXT
 #define EGL_DRM_MASTER_FD_EXT 0x333C
 #endif
@@ -123,8 +129,6 @@ meta_get_renderer_native_parent_vtable (void)
 static void
 meta_renderer_native_gpu_data_free (MetaRendererNativeGpuData *renderer_gpu_data)
 {
-  MetaRendererNative *renderer_native = renderer_gpu_data->renderer_native;
-  MetaEgl *egl = meta_renderer_native_get_egl (renderer_native);
   MetaRenderer *renderer = META_RENDERER (renderer_gpu_data->renderer_native);
   MetaBackend *backend = meta_renderer_get_backend (renderer);
   MetaCursorRenderer *cursor_renderer;
@@ -133,8 +137,14 @@ meta_renderer_native_gpu_data_free (MetaRendererNativeGpuData *renderer_gpu_data
 
   if (renderer_gpu_data->secondary.egl_context != EGL_NO_CONTEXT)
     {
+      MetaRenderDevice *render_device = renderer_gpu_data->render_device;
+      EGLDisplay egl_display =
+        meta_render_device_get_egl_display (render_device);
+      MetaRendererNative *renderer_native = renderer_gpu_data->renderer_native;
+      MetaEgl *egl = meta_renderer_native_get_egl (renderer_native);
+
       meta_egl_destroy_context (egl,
-                                renderer_gpu_data->egl_display,
+                                egl_display,
                                 renderer_gpu_data->secondary.egl_context,
                                 NULL);
     }
@@ -160,12 +170,7 @@ meta_renderer_native_gpu_data_free (MetaRendererNativeGpuData *renderer_gpu_data
         }
     }
 
-  if (renderer_gpu_data->egl_display != EGL_NO_DISPLAY)
-    meta_egl_terminate (egl, renderer_gpu_data->egl_display, NULL);
-
-  g_clear_pointer (&renderer_gpu_data->gbm.device, gbm_device_destroy);
-  g_clear_pointer (&renderer_gpu_data->device_file, meta_device_file_release);
-
+  g_clear_pointer (&renderer_gpu_data->render_device, g_object_unref);
   g_free (renderer_gpu_data);
 }
 
@@ -189,11 +194,18 @@ meta_gbm_device_from_gpu (MetaGpuKms *gpu_kms)
 {
   MetaRendererNative *renderer_native = meta_renderer_native_from_gpu (gpu_kms);
   MetaRendererNativeGpuData *renderer_gpu_data;
+  MetaRenderDevice *render_device;
+  MetaRenderDeviceGbm *render_device_gbm;
 
   renderer_gpu_data = meta_renderer_native_get_gpu_data (renderer_native,
                                                          gpu_kms);
+  render_device = renderer_gpu_data->render_device;
 
-  return renderer_gpu_data->gbm.device;
+  if (!META_IS_RENDER_DEVICE_GBM (render_device))
+    return NULL;
+
+  render_device_gbm = META_RENDER_DEVICE_GBM (render_device);
+  return meta_render_device_gbm_get_gbm_device (render_device_gbm);
 }
 
 MetaGpuKms *
@@ -207,16 +219,23 @@ meta_renderer_native_get_primary_device_file (MetaRendererNative *renderer_nativ
 {
   MetaGpuKms *gpu_kms = renderer_native->primary_gpu_kms;
   MetaRendererNativeGpuData *renderer_gpu_data;
+  MetaRenderDevice *render_device;
 
   renderer_gpu_data = meta_renderer_native_get_gpu_data (renderer_native,
                                                          gpu_kms);
-  return renderer_gpu_data->device_file;
+  render_device = renderer_gpu_data->render_device;
+  return meta_render_device_get_device_file (render_device);
 }
 
 static MetaRendererNativeGpuData *
 meta_create_renderer_native_gpu_data (void)
 {
-  return g_new0 (MetaRendererNativeGpuData, 1);
+  MetaRendererNativeGpuData *renderer_gpu_data;
+
+  renderer_gpu_data = g_new0 (MetaRendererNativeGpuData, 1);
+  renderer_gpu_data->secondary.egl_context = EGL_NO_CONTEXT;
+
+  return renderer_gpu_data;
 }
 
 MetaEgl *
@@ -278,6 +297,7 @@ meta_renderer_native_connect (CoglRenderer *cogl_renderer,
   MetaRendererNative *renderer_native = cogl_renderer->custom_winsys_user_data;
   MetaGpuKms *gpu_kms;
   MetaRendererNativeGpuData *renderer_gpu_data;
+  MetaRenderDevice *render_device;
 
   cogl_renderer->winsys = g_new0 (CoglRendererEGL, 1);
   cogl_renderer_egl = cogl_renderer->winsys;
@@ -285,10 +305,11 @@ meta_renderer_native_connect (CoglRenderer *cogl_renderer,
   gpu_kms = meta_renderer_native_get_primary_gpu (renderer_native);
   renderer_gpu_data = meta_renderer_native_get_gpu_data (renderer_native,
                                                          gpu_kms);
+  render_device = renderer_gpu_data->render_device;
 
   cogl_renderer_egl->platform_vtable = &_cogl_winsys_egl_vtable;
   cogl_renderer_egl->platform = renderer_gpu_data;
-  cogl_renderer_egl->edpy = renderer_gpu_data->egl_display;
+  cogl_renderer_egl->edpy = meta_render_device_get_egl_display (render_device);
 
   if (!_cogl_winsys_egl_renderer_connect_common (cogl_renderer, error))
     goto fail;
@@ -527,7 +548,11 @@ cogl_context_from_renderer_native (MetaRendererNative *renderer_native)
 {
   MetaRenderer *renderer = META_RENDERER (renderer_native);
   MetaBackend *backend = meta_renderer_get_backend (renderer);
-  ClutterBackend *clutter_backend = meta_backend_get_clutter_backend (backend);
+  ClutterBackend *clutter_backend;
+
+  clutter_backend = meta_backend_get_clutter_backend (backend);
+  if (!clutter_backend)
+    return NULL;
 
   return clutter_backend_get_cogl_context (clutter_backend);
 }
@@ -873,56 +898,60 @@ meta_renderer_native_create_dma_buf (CoglRenderer  *cogl_renderer,
     {
     case META_RENDERER_NATIVE_MODE_GBM:
       {
+        MetaRenderDevice *render_device;
+        MetaDrmBufferFlags flags;
+        g_autoptr (MetaDrmBuffer) buffer = NULL;
+        int dmabuf_fd;
+        uint32_t stride;
+        uint32_t offset;
+        uint32_t bpp;
+        uint32_t modifier;
+        uint32_t format;
         CoglFramebuffer *dmabuf_fb;
         CoglDmaBufHandle *dmabuf_handle;
-        struct gbm_bo *new_bo;
-        int stride;
-        int offset;
-        int bpp;
-        int dmabuf_fd = -1;
 
-        new_bo = gbm_bo_create (renderer_gpu_data->gbm.device,
-                                width, height, DRM_FORMAT_XRGB8888,
-                                GBM_BO_USE_RENDERING | GBM_BO_USE_LINEAR);
 
-        if (!new_bo)
-          {
-            g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
-                         "Failed to allocate buffer");
-            return NULL;
-          }
-
-        dmabuf_fd = gbm_bo_get_fd (new_bo);
+        render_device = renderer_gpu_data->render_device;
+        flags = META_DRM_BUFFER_FLAG_NONE;
+        buffer = meta_render_device_allocate_dma_buf (render_device,
+                                                      width, height,
+                                                      DRM_FORMAT_XRGB8888,
+                                                      flags,
+                                                      error);
+        if (!buffer)
+          return NULL;
 
+        dmabuf_fd = meta_drm_buffer_export_fd (buffer, error);
         if (dmabuf_fd == -1)
-          {
-            g_set_error (error, G_IO_ERROR, G_IO_ERROR_EXISTS,
-                         "Failed to export buffer's DMA fd: %s",
-                         g_strerror (errno));
-            return NULL;
-          }
+          return NULL;
+
+        stride = meta_drm_buffer_get_stride (buffer);
+        offset = meta_drm_buffer_get_offset (buffer, 0);
+        bpp = meta_drm_buffer_get_bpp (buffer);
+        modifier = meta_drm_buffer_get_modifier (buffer);
+        format = meta_drm_buffer_get_format (buffer);
 
-        stride = gbm_bo_get_stride (new_bo);
-        offset = gbm_bo_get_offset (new_bo, 0);
-        bpp = 4;
         dmabuf_fb =
           meta_renderer_native_create_dma_buf_framebuffer (renderer_native,
                                                            dmabuf_fd,
                                                            width, height,
                                                            stride,
                                                            offset,
-                                                           DRM_FORMAT_MOD_LINEAR,
-                                                           DRM_FORMAT_XRGB8888,
+                                                           modifier,
+                                                           format,
                                                            error);
 
         if (!dmabuf_fb)
-          return NULL;
+          {
+            close (dmabuf_fd);
+            return NULL;
+          }
 
         dmabuf_handle =
           cogl_dma_buf_handle_new (dmabuf_fb, dmabuf_fd,
                                    width, height, stride, offset, bpp,
-                                   new_bo,
-                                   (GDestroyNotify) gbm_bo_destroy);
+                                   g_steal_pointer (&buffer),
+                                   g_object_unref);
         g_object_unref (dmabuf_fb);
         return dmabuf_handle;
       }
@@ -956,9 +985,6 @@ meta_renderer_native_init_egl_context (CoglContext *cogl_context,
   COGL_FLAGS_SET (cogl_context->winsys_features,
                   COGL_WINSYS_FEATURE_SYNC_AND_COMPLETE_EVENT,
                   TRUE);
-  COGL_FLAGS_SET (cogl_context->winsys_features,
-                  COGL_WINSYS_FEATURE_MULTIPLE_ONSCREEN,
-                  TRUE);
 
 #ifdef HAVE_EGL_DEVICE
   if (renderer_gpu_data->mode == META_RENDERER_NATIVE_MODE_EGL_DEVICE)
@@ -1365,7 +1391,6 @@ meta_renderer_native_rebuild_views (MetaRenderer *renderer)
     META_RENDERER_CLASS (meta_renderer_native_parent_class);
 
   meta_kms_discard_pending_page_flips (kms);
-  meta_kms_discard_pending_updates (kms);
 
   keep_current_onscreens_alive (renderer);
 
@@ -1514,12 +1539,27 @@ init_secondary_gpu_data_gpu (MetaRendererNativeGpuData *renderer_gpu_data,
                              GError                   **error)
 {
   MetaRendererNative *renderer_native = renderer_gpu_data->renderer_native;
+  MetaRenderDevice *render_device = renderer_gpu_data->render_device;
   MetaEgl *egl = meta_renderer_native_get_egl (renderer_native);
-  EGLDisplay egl_display = renderer_gpu_data->egl_display;
+  EGLDisplay egl_display;
   EGLConfig egl_config;
   EGLContext egl_context;
   const char **missing_gl_extensions;
-  const char *renderer_str;
+
+  egl_display = meta_render_device_get_egl_display (render_device);
+  if (egl_display == EGL_NO_DISPLAY)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "No EGL display");
+      return FALSE;
+    }
+
+  if (!meta_render_device_is_hardware_accelerated (render_device))
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "Not hardware accelerated");
+      return FALSE;
+    }
 
   meta_egl_bind_api (egl, EGL_OPENGL_ES_API, NULL);
 
@@ -1527,7 +1567,8 @@ init_secondary_gpu_data_gpu (MetaRendererNativeGpuData *renderer_gpu_data,
                                     &egl_config, error))
     goto err;
 
-  egl_context = create_secondary_egl_context (egl, egl_display, egl_config, error);
+  egl_context = create_secondary_egl_context (egl, egl_display, egl_config,
+                                              error);
   if (egl_context == EGL_NO_CONTEXT)
     goto err;
 
@@ -1544,17 +1585,6 @@ init_secondary_gpu_data_gpu (MetaRendererNativeGpuData *renderer_gpu_data,
       goto err;
     }
 
-  renderer_str = (const char *) glGetString (GL_RENDERER);
-  if (g_str_has_prefix (renderer_str, "llvmpipe") ||
-      g_str_has_prefix (renderer_str, "softpipe") ||
-      g_str_has_prefix (renderer_str, "swrast"))
-    {
-      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
-                   "Do not want to use software renderer (%s), falling back to CPU copy path",
-                   renderer_str);
-      goto err_fail_with_context;
-    }
-
   if (!meta_gles3_has_extensions (renderer_native->gles3,
                                   &missing_gl_extensions,
                                   "GL_OES_EGL_image_external",
@@ -1570,10 +1600,9 @@ init_secondary_gpu_data_gpu (MetaRendererNativeGpuData *renderer_gpu_data,
       g_free (missing_gl_extensions_str);
       g_free (missing_gl_extensions);
 
-      goto err_fail_with_context;
+      goto err_fail_make_current;
     }
 
-  renderer_gpu_data->secondary.is_hardware_rendering = TRUE;
   renderer_gpu_data->secondary.egl_context = egl_context;
   renderer_gpu_data->secondary.egl_config = egl_config;
   renderer_gpu_data->secondary.copy_mode = META_SHARED_FRAMEBUFFER_COPY_MODE_SECONDARY_GPU;
@@ -1587,14 +1616,13 @@ init_secondary_gpu_data_gpu (MetaRendererNativeGpuData *renderer_gpu_data,
 
   return TRUE;
 
-err_fail_with_context:
+err_fail_make_current:
   meta_egl_make_current (egl,
                          egl_display,
                          EGL_NO_SURFACE,
                          EGL_NO_SURFACE,
                          EGL_NO_CONTEXT,
                          NULL);
-  meta_egl_destroy_context (egl, egl_display, egl_context, NULL);
 
 err:
   maybe_restore_cogl_egl_api (renderer_native);
@@ -1605,8 +1633,6 @@ err:
 static void
 init_secondary_gpu_data_cpu (MetaRendererNativeGpuData *renderer_gpu_data)
 {
-  renderer_gpu_data->secondary.is_hardware_rendering = FALSE;
-
   /* First try ZERO, it automatically falls back to PRIMARY as needed */
   renderer_gpu_data->secondary.copy_mode =
     META_SHARED_FRAMEBUFFER_COPY_MODE_ZERO;
@@ -1634,332 +1660,80 @@ gpu_kms_is_hardware_rendering (MetaRendererNative *renderer_native,
   MetaRendererNativeGpuData *data;
 
   data = meta_renderer_native_get_gpu_data (renderer_native, gpu_kms);
-  return data->secondary.is_hardware_rendering;
-}
-
-static EGLDisplay
-init_gbm_egl_display (MetaRendererNative  *renderer_native,
-                      struct gbm_device   *gbm_device,
-                      GError             **error)
-{
-  MetaEgl *egl = meta_renderer_native_get_egl (renderer_native);
-  EGLDisplay egl_display;
-
-  if (!meta_egl_has_extensions (egl, EGL_NO_DISPLAY, NULL,
-                                "EGL_MESA_platform_gbm",
-                                NULL) &&
-      !meta_egl_has_extensions (egl, EGL_NO_DISPLAY, NULL,
-                                "EGL_KHR_platform_gbm",
-                                NULL))
-    {
-      g_set_error (error, G_IO_ERROR,
-                   G_IO_ERROR_FAILED,
-                   "Missing extension for GBM renderer: EGL_KHR_platform_gbm");
-      return EGL_NO_DISPLAY;
-    }
-
-  egl_display = meta_egl_get_platform_display (egl,
-                                               EGL_PLATFORM_GBM_KHR,
-                                               gbm_device, NULL, error);
-  if (egl_display == EGL_NO_DISPLAY)
-    return EGL_NO_DISPLAY;
-
-  if (!meta_egl_initialize (egl, egl_display, error))
-    return EGL_NO_DISPLAY;
-
-  return egl_display;
+  return meta_render_device_is_hardware_accelerated (data->render_device);
 }
 
 static MetaRendererNativeGpuData *
 create_renderer_gpu_data_gbm (MetaRendererNative  *renderer_native,
-                              MetaGpuKms          *gpu_kms,
                               MetaDeviceFile      *device_file,
+                              MetaGpuKms          *gpu_kms,
                               GError             **error)
 {
-  struct gbm_device *gbm_device;
+  MetaRenderer *renderer = META_RENDERER (renderer_native);
+  MetaBackend *backend = meta_renderer_get_backend (renderer);
+  MetaRenderDeviceGbm *render_device_gbm;
   MetaRendererNativeGpuData *renderer_gpu_data;
-  g_autoptr (GError) local_error = NULL;
 
-  gbm_device = gbm_create_device (meta_device_file_get_fd (device_file));
-  if (!gbm_device)
-    {
-      g_set_error (error, G_IO_ERROR,
-                   G_IO_ERROR_FAILED,
-                   "Failed to create gbm device: %s", g_strerror (errno));
-      return NULL;
-    }
+  render_device_gbm = meta_render_device_gbm_new (backend, device_file, error);
+  if (!render_device_gbm)
+    return NULL;
 
   renderer_gpu_data = meta_create_renderer_native_gpu_data ();
-  renderer_gpu_data->device_file = meta_device_file_acquire (device_file);
   renderer_gpu_data->renderer_native = renderer_native;
-  renderer_gpu_data->gpu_kms = gpu_kms;
-  renderer_gpu_data->gbm.device = gbm_device;
   renderer_gpu_data->mode = META_RENDERER_NATIVE_MODE_GBM;
-
-  renderer_gpu_data->egl_display = init_gbm_egl_display (renderer_native,
-                                                         gbm_device,
-                                                         &local_error);
-  if (renderer_gpu_data->egl_display == EGL_NO_DISPLAY)
-    {
-      g_debug ("GBM EGL init for %s failed: %s",
-               meta_device_file_get_path (device_file),
-               local_error->message);
-
-      init_secondary_gpu_data_cpu (renderer_gpu_data);
-      return renderer_gpu_data;
-    }
+  renderer_gpu_data->render_device = META_RENDER_DEVICE (render_device_gbm);
+  renderer_gpu_data->gpu_kms = gpu_kms;
 
   init_secondary_gpu_data (renderer_gpu_data);
   return renderer_gpu_data;
 }
 
-static EGLDisplay
-init_surfaceless_egl_display (MetaRendererNative  *renderer_native,
-                              GError             **error)
-{
-  MetaEgl *egl = meta_renderer_native_get_egl (renderer_native);
-  EGLDisplay egl_display;
-
-  if (!meta_egl_has_extensions (egl, EGL_NO_DISPLAY, NULL,
-                                "EGL_MESA_platform_surfaceless",
-                                NULL))
-    {
-      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
-                   "Missing EGL platform required for surfaceless context: "
-                   "EGL_MESA_platform_surfaceless");
-      return EGL_NO_DISPLAY;
-    }
-
-  egl_display = meta_egl_get_platform_display (egl,
-                                               EGL_PLATFORM_SURFACELESS_MESA,
-                                               EGL_DEFAULT_DISPLAY,
-                                               NULL, error);
-  if (egl_display == EGL_NO_DISPLAY)
-    return EGL_NO_DISPLAY;
-
-  if (!meta_egl_initialize (egl, egl_display, error))
-    return EGL_NO_DISPLAY;
-
-  if (!meta_egl_has_extensions (egl, egl_display, NULL,
-                                "EGL_KHR_no_config_context",
-                                NULL))
-    {
-      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
-                   "Missing EGL extension required for surfaceless context: "
-                   "EGL_KHR_no_config_context");
-      return EGL_NO_DISPLAY;
-    }
-
-  return egl_display;
-}
-
 static MetaRendererNativeGpuData *
 create_renderer_gpu_data_surfaceless (MetaRendererNative  *renderer_native,
                                       GError             **error)
 {
+  MetaRenderer *renderer = META_RENDERER (renderer_native);
+  MetaBackend *backend = meta_renderer_get_backend (renderer);
+  MetaRenderDeviceSurfaceless *render_device_surfaceless;
   MetaRendererNativeGpuData *renderer_gpu_data;
-  EGLDisplay egl_display;
 
-  egl_display = init_surfaceless_egl_display (renderer_native, error);
-  if (egl_display == EGL_NO_DISPLAY)
+  render_device_surfaceless = meta_render_device_surfaceless_new (backend,
+                                                                  error);
+  if (!render_device_surfaceless)
     return NULL;
 
   renderer_gpu_data = meta_create_renderer_native_gpu_data ();
   renderer_gpu_data->renderer_native = renderer_native;
   renderer_gpu_data->mode = META_RENDERER_NATIVE_MODE_SURFACELESS;
-  renderer_gpu_data->egl_display = egl_display;
+  renderer_gpu_data->render_device =
+    META_RENDER_DEVICE (render_device_surfaceless);
 
   return renderer_gpu_data;
 }
 
 #ifdef HAVE_EGL_DEVICE
-static const char *
-get_drm_device_file (MetaEgl     *egl,
-                     EGLDeviceEXT device,
-                     GError     **error)
-{
-  if (!meta_egl_egl_device_has_extensions (egl, device,
-                                           NULL,
-                                           "EGL_EXT_device_drm",
-                                           NULL))
-    {
-      g_set_error (error, G_IO_ERROR,
-                   G_IO_ERROR_FAILED,
-                   "Missing required EGLDevice extension EGL_EXT_device_drm");
-      return NULL;
-    }
-
-  return meta_egl_query_device_string (egl, device,
-                                       EGL_DRM_DEVICE_FILE_EXT,
-                                       error);
-}
-
-static EGLDeviceEXT
-find_egl_device (MetaRendererNative  *renderer_native,
-                 MetaDeviceFile      *device_file,
-                 GError             **error)
-{
-  MetaEgl *egl = meta_renderer_native_get_egl (renderer_native);
-  const char **missing_extensions;
-  EGLint num_devices;
-  EGLDeviceEXT *devices;
-  const char *kms_file_path;
-  EGLDeviceEXT device;
-  EGLint i;
-
-  if (!meta_egl_has_extensions (egl,
-                                EGL_NO_DISPLAY,
-                                &missing_extensions,
-                                "EGL_EXT_device_base",
-                                NULL))
-    {
-      char *missing_extensions_str;
-
-      missing_extensions_str = g_strjoinv (", ", (char **) missing_extensions);
-      g_set_error (error, G_IO_ERROR,
-                   G_IO_ERROR_FAILED,
-                   "Missing EGL extensions required for EGLDevice renderer: %s",
-                   missing_extensions_str);
-      g_free (missing_extensions_str);
-      g_free (missing_extensions);
-      return EGL_NO_DEVICE_EXT;
-    }
-
-  if (!meta_egl_query_devices (egl, 0, NULL, &num_devices, error))
-    return EGL_NO_DEVICE_EXT;
-
-  devices = g_new0 (EGLDeviceEXT, num_devices);
-  if (!meta_egl_query_devices (egl, num_devices, devices, &num_devices,
-                               error))
-    {
-      g_free (devices);
-      return EGL_NO_DEVICE_EXT;
-    }
-
-  kms_file_path = meta_device_file_get_path (device_file);
-
-  device = EGL_NO_DEVICE_EXT;
-  for (i = 0; i < num_devices; i++)
-    {
-      const char *egl_device_drm_path;
-
-      g_clear_error (error);
-
-      egl_device_drm_path = get_drm_device_file (egl, devices[i], error);
-      if (!egl_device_drm_path)
-        continue;
-
-      if (g_str_equal (egl_device_drm_path, kms_file_path))
-        {
-          device = devices[i];
-          break;
-        }
-    }
-  g_free (devices);
-
-  if (device == EGL_NO_DEVICE_EXT)
-    {
-      if (!*error)
-        g_set_error (error, G_IO_ERROR,
-                     G_IO_ERROR_FAILED,
-                     "Failed to find matching EGLDeviceEXT");
-      return EGL_NO_DEVICE_EXT;
-    }
-
-  return device;
-}
-
-static EGLDisplay
-get_egl_device_display (MetaRendererNative  *renderer_native,
-                        MetaDeviceFile      *device_file,
-                        EGLDeviceEXT         egl_device,
-                        GError             **error)
-{
-  MetaEgl *egl = meta_renderer_native_get_egl (renderer_native);
-  int kms_fd = meta_device_file_get_fd (device_file);
-  EGLint platform_attribs[] = {
-    EGL_DRM_MASTER_FD_EXT, kms_fd,
-    EGL_NONE
-  };
-
-  return meta_egl_get_platform_display (egl, EGL_PLATFORM_DEVICE_EXT,
-                                        (void *) egl_device,
-                                        platform_attribs,
-                                        error);
-}
-
-static int
-count_drm_devices (MetaRendererNative *renderer_native)
-{
-  MetaRenderer *renderer = META_RENDERER (renderer_native);
-  MetaBackend *backend = meta_renderer_get_backend (renderer);
-
-  return g_list_length (meta_backend_get_gpus (backend));
-}
-
 static MetaRendererNativeGpuData *
 create_renderer_gpu_data_egl_device (MetaRendererNative  *renderer_native,
-                                     MetaGpuKms          *gpu_kms,
                                      MetaDeviceFile      *device_file,
+                                     MetaGpuKms          *gpu_kms,
                                      GError             **error)
 {
-  MetaEgl *egl = meta_renderer_native_get_egl (renderer_native);
-  const char **missing_extensions;
-  EGLDeviceEXT egl_device;
-  EGLDisplay egl_display;
+  MetaRenderer *renderer = META_RENDERER (renderer_native);
+  MetaBackend *backend = meta_renderer_get_backend (renderer);
+  MetaRenderDeviceEglStream *render_device_egl_stream;
   MetaRendererNativeGpuData *renderer_gpu_data;
 
-  if (count_drm_devices (renderer_native) != 1)
-    {
-      g_set_error (error, G_IO_ERROR,
-                   G_IO_ERROR_FAILED,
-                   "EGLDevice currently only works with single GPU systems");
-      return NULL;
-    }
-
-  egl_device = find_egl_device (renderer_native, device_file, error);
-  if (egl_device == EGL_NO_DEVICE_EXT)
+  render_device_egl_stream = meta_render_device_egl_stream_new (backend,
+                                                                device_file,
+                                                                error);
+  if (!render_device_egl_stream)
     return NULL;
 
-  egl_display = get_egl_device_display (renderer_native, device_file,
-                                        egl_device, error);
-  if (egl_display == EGL_NO_DISPLAY)
-    return NULL;
-
-  if (!meta_egl_initialize (egl, egl_display, error))
-    return NULL;
-
-  if (!meta_egl_has_extensions (egl,
-                                egl_display,
-                                &missing_extensions,
-                                "EGL_NV_output_drm_flip_event",
-                                "EGL_EXT_output_base",
-                                "EGL_EXT_output_drm",
-                                "EGL_KHR_stream",
-                                "EGL_KHR_stream_producer_eglsurface",
-                                "EGL_EXT_stream_consumer_egloutput",
-                                "EGL_EXT_stream_acquire_mode",
-                                NULL))
-    {
-      char *missing_extensions_str;
-
-      missing_extensions_str = g_strjoinv (", ", (char **) missing_extensions);
-      g_set_error (error, G_IO_ERROR,
-                   G_IO_ERROR_FAILED,
-                   "Missing EGL extensions required for EGLDevice renderer: %s",
-                   missing_extensions_str);
-      meta_egl_terminate (egl, egl_display, NULL);
-      g_free (missing_extensions_str);
-      g_free (missing_extensions);
-      return NULL;
-    }
-
   renderer_gpu_data = meta_create_renderer_native_gpu_data ();
-  renderer_gpu_data->device_file = meta_device_file_acquire (device_file);
   renderer_gpu_data->renderer_native = renderer_native;
-  renderer_gpu_data->egl.device = egl_device;
   renderer_gpu_data->mode = META_RENDERER_NATIVE_MODE_EGL_DEVICE;
-  renderer_gpu_data->egl_display = egl_display;
+  renderer_gpu_data->render_device =
+    META_RENDER_DEVICE (render_device_egl_stream);
   renderer_gpu_data->gpu_kms = gpu_kms;
 
   return renderer_gpu_data;
@@ -1975,7 +1749,7 @@ meta_renderer_native_create_renderer_gpu_data (MetaRendererNative  *renderer_nat
   MetaBackend *backend = meta_renderer_get_backend (renderer);
   MetaDevicePool *device_pool =
     meta_backend_native_get_device_pool (META_BACKEND_NATIVE (backend));
-  MetaRendererNativeGpuData *gbm_renderer_gpu_data;
+  MetaRendererNativeGpuData *gbm_renderer_gpu_data = NULL;
   MetaDeviceFileFlags device_file_flags = META_DEVICE_FILE_FLAG_NONE;
   g_autoptr (MetaDeviceFile) device_file = NULL;
   GError *gbm_error = NULL;
@@ -1998,21 +1772,35 @@ meta_renderer_native_create_renderer_gpu_data (MetaRendererNative  *renderer_nat
   if (!device_file)
     return NULL;
 
-  gbm_renderer_gpu_data = create_renderer_gpu_data_gbm (renderer_native,
-                                                        gpu_kms,
-                                                        device_file,
-                                                        &gbm_error);
-  if (gbm_renderer_gpu_data)
+#ifdef HAVE_EGL_DEVICE
+  if (g_strcmp0 (getenv ("MUTTER_DEBUG_FORCE_EGL_STREAM"), "1") != 0)
+#endif
     {
-      if (gbm_renderer_gpu_data->secondary.is_hardware_rendering)
-        return gbm_renderer_gpu_data;
+      gbm_renderer_gpu_data = create_renderer_gpu_data_gbm (renderer_native,
+                                                            device_file,
+                                                            gpu_kms,
+                                                            &gbm_error);
+      if (gbm_renderer_gpu_data)
+        {
+          MetaRenderDevice *render_device = gbm_renderer_gpu_data->render_device;
+
+          if (meta_render_device_is_hardware_accelerated (render_device))
+            return gbm_renderer_gpu_data;
+        }
     }
+#ifdef HAVE_EGL_DEVICE
+  else
+    {
+      g_set_error (&gbm_error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "GBM backend was disabled using env var");
+    }
+#endif
 
 #ifdef HAVE_EGL_DEVICE
   egl_stream_renderer_gpu_data =
     create_renderer_gpu_data_egl_device (renderer_native,
-                                         gpu_kms,
                                          device_file,
+                                         gpu_kms,
                                          &egl_device_error);
   if (egl_stream_renderer_gpu_data)
     {
@@ -2245,11 +2033,13 @@ choose_primary_gpu (MetaBackend         *backend,
 {
   MetaGpuKms *gpu_kms;
   MetaRendererNativeGpuData *renderer_gpu_data;
+  MetaRenderDevice *render_device;
 
   gpu_kms = choose_primary_gpu_unchecked (backend, renderer_native);
   renderer_gpu_data = meta_renderer_native_get_gpu_data (renderer_native,
                                                          gpu_kms);
-  if (renderer_gpu_data->egl_display == EGL_NO_DISPLAY)
+  render_device = renderer_gpu_data->render_device;
+  if (meta_render_device_get_egl_display (render_device) == EGL_NO_DISPLAY)
     {
       g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
                    "The GPU %s chosen as primary is not supported by EGL.",
diff --git a/src/backends/native/meta-seat-impl.c b/src/backends/native/meta-seat-impl.c
index 28349789d..8bf0c6875 100644
--- a/src/backends/native/meta-seat-impl.c
+++ b/src/backends/native/meta-seat-impl.c
@@ -1331,6 +1331,35 @@ notify_swipe_gesture_event (ClutterInputDevice          *input_device,
   queue_event (seat_impl, event);
 }
 
+static void
+notify_hold_gesture_event (ClutterInputDevice          *input_device,
+                           ClutterTouchpadGesturePhase  phase,
+                           uint64_t                     time_us,
+                           uint32_t                     n_fingers)
+{
+  MetaSeatImpl *seat_impl;
+  ClutterEvent *event = NULL;
+
+  seat_impl = seat_impl_from_device (input_device);
+
+  event = clutter_event_new (CLUTTER_TOUCHPAD_HOLD);
+
+  event->touchpad_hold.phase = phase;
+  event->touchpad_hold.time = us2ms (time_us);
+  event->touchpad_hold.n_fingers = n_fingers;
+
+  meta_input_device_native_get_coords_in_impl (META_INPUT_DEVICE_NATIVE (seat_impl->core_pointer),
+                                               &event->touchpad_hold.x,
+                                               &event->touchpad_hold.y);
+
+  meta_xkb_translate_state (event, seat_impl->xkb, seat_impl->button_state);
+
+  clutter_event_set_device (event, seat_impl->core_pointer);
+  clutter_event_set_source_device (event, input_device);
+
+  queue_event (seat_impl, event);
+}
+
 static void
 notify_proximity (ClutterInputDevice *input_device,
                   uint64_t            time_us,
@@ -1930,6 +1959,45 @@ notify_discrete_axis (MetaSeatImpl                  *seat_impl,
                                                  scroll_source);
 }
 
+static void
+handle_pointer_scroll (MetaSeatImpl          *seat_impl,
+                       struct libinput_event *event)
+{
+  struct libinput_device *libinput_device = libinput_event_get_device (event);
+  ClutterInputDevice *device;
+  uint64_t time_us;
+  enum libinput_pointer_axis_source source;
+  struct libinput_event_pointer *axis_event =
+    libinput_event_get_pointer_event (event);
+  ClutterScrollSource scroll_source;
+
+  device = libinput_device_get_user_data (libinput_device);
+
+  time_us = libinput_event_pointer_get_time_usec (axis_event);
+  source = libinput_event_pointer_get_axis_source (axis_event);
+  scroll_source = translate_scroll_source (source);
+
+  /* libinput < 0.8 sent wheel click events with value 10. Since 0.8
+   * the value is the angle of the click in degrees. To keep
+   * backwards-compat with existing clients, we just send multiples of
+   * the click count.
+   */
+
+  switch (scroll_source)
+    {
+    case CLUTTER_SCROLL_SOURCE_WHEEL:
+      notify_discrete_axis (seat_impl, device, time_us, scroll_source,
+                            axis_event);
+      break;
+    case CLUTTER_SCROLL_SOURCE_FINGER:
+    case CLUTTER_SCROLL_SOURCE_CONTINUOUS:
+    case CLUTTER_SCROLL_SOURCE_UNKNOWN:
+      notify_continuous_axis (seat_impl, device, time_us, scroll_source,
+                              axis_event);
+      break;
+    }
+}
+
 static void
 process_tablet_axis (MetaSeatImpl          *seat_impl,
                      struct libinput_event *event)
@@ -2106,36 +2174,7 @@ process_device_event (MetaSeatImpl          *seat_impl,
 
     case LIBINPUT_EVENT_POINTER_AXIS:
       {
-        uint64_t time_us;
-        enum libinput_pointer_axis_source source;
-        struct libinput_event_pointer *axis_event =
-          libinput_event_get_pointer_event (event);
-        ClutterScrollSource scroll_source;
-
-        device = libinput_device_get_user_data (libinput_device);
-
-        time_us = libinput_event_pointer_get_time_usec (axis_event);
-        source = libinput_event_pointer_get_axis_source (axis_event);
-        scroll_source = translate_scroll_source (source);
-
-        /* libinput < 0.8 sent wheel click events with value 10. Since 0.8
-           the value is the angle of the click in degrees. To keep
-           backwards-compat with existing clients, we just send multiples of
-           the click count. */
-
-        switch (scroll_source)
-          {
-          case CLUTTER_SCROLL_SOURCE_WHEEL:
-            notify_discrete_axis (seat_impl, device, time_us, scroll_source,
-                                  axis_event);
-            break;
-          case CLUTTER_SCROLL_SOURCE_FINGER:
-          case CLUTTER_SCROLL_SOURCE_CONTINUOUS:
-          case CLUTTER_SCROLL_SOURCE_UNKNOWN:
-            notify_continuous_axis (seat_impl, device, time_us, scroll_source,
-                                    axis_event);
-            break;
-          }
+        handle_pointer_scroll (seat_impl, event);
         break;
       }
 
@@ -2367,6 +2406,28 @@ process_device_event (MetaSeatImpl          *seat_impl,
                                     time_us, n_fingers, dx, dy, dx_unaccel, dy_unaccel);
         break;
       }
+    case LIBINPUT_EVENT_GESTURE_HOLD_BEGIN:
+    case LIBINPUT_EVENT_GESTURE_HOLD_END:
+      {
+        struct libinput_event_gesture *gesture_event =
+          libinput_event_get_gesture_event (event);
+        ClutterTouchpadGesturePhase phase;
+        uint32_t n_fingers;
+        uint64_t time_us;
+
+        device = libinput_device_get_user_data (libinput_device);
+        time_us = libinput_event_gesture_get_time_usec (gesture_event);
+        n_fingers = libinput_event_gesture_get_finger_count (gesture_event);
+
+        if (libinput_event_get_type (event) == LIBINPUT_EVENT_GESTURE_HOLD_BEGIN)
+          phase = CLUTTER_TOUCHPAD_GESTURE_PHASE_BEGIN;
+        else
+          phase = libinput_event_gesture_get_cancelled (gesture_event) ?
+            CLUTTER_TOUCHPAD_GESTURE_PHASE_CANCEL : CLUTTER_TOUCHPAD_GESTURE_PHASE_END;
+
+        notify_hold_gesture_event (device, phase, time_us, n_fingers);
+        break;
+      }
     case LIBINPUT_EVENT_TABLET_TOOL_AXIS:
       {
         process_tablet_axis (seat_impl, event);
@@ -3453,59 +3514,6 @@ meta_seat_impl_set_pointer_constraint (MetaSeatImpl              *seat_impl,
   g_object_unref (task);
 }
 
-static void
-ensure_pointer_onscreen (MetaSeatImpl *seat_impl)
-{
-  int i, candidate = -1;
-  int nearest_monitor_x, nearest_monitor_y, min_distance = G_MAXINT;
-  cairo_rectangle_int_t monitor_rect;
-  graphene_point_t coords;
-
-  if (!meta_seat_impl_query_state (seat_impl,
-                                   seat_impl->core_pointer, NULL,
-                                   &coords, NULL))
-    return;
-
-  /* Pointer is in a view */
-  if (meta_viewport_info_get_view_at (seat_impl->viewports,
-                                      coords.x, coords.y) >= 0)
-    return;
-
-  /* Find nearest view */
-  for (i = 0; i < meta_viewport_info_get_num_views (seat_impl->viewports); i++)
-    {
-      meta_viewport_info_get_view_info (seat_impl->viewports, i,
-                                        &monitor_rect, NULL);
-      nearest_monitor_x = MIN (ABS (coords.x - monitor_rect.x),
-                               ABS (coords.x -
-                                    monitor_rect.x + monitor_rect.width));
-      nearest_monitor_y = MIN (ABS (coords.y - monitor_rect.y),
-                               ABS (coords.y -
-                                    monitor_rect.y + monitor_rect.height));
-      if (nearest_monitor_x < min_distance ||
-          nearest_monitor_y < min_distance)
-        {
-          min_distance = MIN (nearest_monitor_x, nearest_monitor_y);
-          candidate = i;
-        }
-    }
-
-  if (candidate < 0)
-    return;
-
-  /* Calculate new coordinates on nearest view */
-  meta_viewport_info_get_view_info (seat_impl->viewports,
-                                    candidate,
-                                    &monitor_rect, NULL);
-  coords.x = CLAMP (coords.x, monitor_rect.x,
-                    monitor_rect.x + monitor_rect.width - 1);
-  coords.y = CLAMP (coords.y, monitor_rect.y,
-                    monitor_rect.y + monitor_rect.height - 1);
-
-  notify_absolute_motion_in_impl (seat_impl->core_pointer, 0,
-                                  coords.x, coords.y, NULL);
-}
-
 static gboolean
 set_viewports (GTask *task)
 {
@@ -3515,8 +3523,6 @@ set_viewports (GTask *task)
   g_set_object (&seat_impl->viewports, viewports);
   g_task_return_boolean (task, TRUE);
 
-  ensure_pointer_onscreen (seat_impl);
-
   return G_SOURCE_REMOVE;
 }
 
diff --git a/src/backends/x11/cm/meta-cursor-sprite-xfixes.c b/src/backends/x11/cm/meta-cursor-sprite-xfixes.c
index 0e5ad1387..2847cd295 100644
--- a/src/backends/x11/cm/meta-cursor-sprite-xfixes.c
+++ b/src/backends/x11/cm/meta-cursor-sprite-xfixes.c
@@ -52,9 +52,10 @@ G_DEFINE_TYPE_WITH_CODE (MetaCursorSpriteXfixes,
                          G_IMPLEMENT_INTERFACE (G_TYPE_INITABLE,
                                                 meta_screen_cast_xfixes_init_initable_iface))
 
-static void
+static gboolean
 meta_cursor_sprite_xfixes_realize_texture (MetaCursorSprite *sprite)
 {
+  return TRUE;
 }
 
 static gboolean
diff --git a/src/backends/x11/meta-backend-x11.c b/src/backends/x11/meta-backend-x11.c
index 09a13505d..80efb6e41 100644
--- a/src/backends/x11/meta-backend-x11.c
+++ b/src/backends/x11/meta-backend-x11.c
@@ -620,7 +620,7 @@ meta_backend_x11_post_init (MetaBackend *backend)
 static ClutterBackend *
 meta_backend_x11_create_clutter_backend (MetaBackend *backend)
 {
-  return g_object_new (META_TYPE_CLUTTER_BACKEND_X11, NULL);
+  return CLUTTER_BACKEND (meta_clutter_backend_x11_new (backend));
 }
 
 static ClutterSeat *
@@ -867,7 +867,6 @@ meta_backend_x11_initable_init (GInitable    *initable,
 
   priv->xdisplay = xdisplay;
   priv->xcb = XGetXCBConnection (priv->xdisplay);
-  meta_clutter_x11_set_display (xdisplay);
 
   init_xkb_state (x11);
 
diff --git a/src/backends/x11/meta-clutter-backend-x11.c b/src/backends/x11/meta-clutter-backend-x11.c
index d94987879..fafe31941 100644
--- a/src/backends/x11/meta-clutter-backend-x11.c
+++ b/src/backends/x11/meta-clutter-backend-x11.c
@@ -28,6 +28,7 @@
 
 #include "backends/meta-backend-private.h"
 #include "backends/meta-renderer.h"
+#include "backends/x11/meta-backend-x11.h"
 #include "backends/x11/meta-clutter-backend-x11.h"
 #include "backends/x11/meta-keymap-x11.h"
 #include "backends/x11/meta-seat-x11.h"
@@ -47,9 +48,13 @@ struct _MetaX11EventFilter
   gpointer data;
 };
 
-G_DEFINE_TYPE (MetaClutterBackendX11, meta_clutter_backend_x11,
-               CLUTTER_TYPE_BACKEND)
+typedef struct _MetaClutterBackendX11Private
+{
+  MetaBackend *backend;
+} MetaClutterBackendX11Private;
 
+G_DEFINE_TYPE_WITH_PRIVATE (MetaClutterBackendX11, meta_clutter_backend_x11,
+                            CLUTTER_TYPE_BACKEND)
 
 /* atoms; remember to add the code that assigns the atom value to
  * the member of the MetaClutterBackendX11 structure if you add an
@@ -71,13 +76,9 @@ static const gchar *atom_names[] = {
 #define N_ATOM_NAMES G_N_ELEMENTS (atom_names)
 
 /* various flags corresponding to pre init setup calls */
-static gboolean clutter_enable_xinput = TRUE;
 static gboolean clutter_enable_stereo = FALSE;
-static Display  *_foreign_dpy = NULL;
 
 /* options */
-static gchar *clutter_display_name = NULL;
-static gint clutter_screen = -1;
 static gboolean clutter_synchronise = FALSE;
 
 /* X error trap */
@@ -89,11 +90,12 @@ cogl_xlib_filter (XEvent       *xevent,
                   ClutterEvent *event,
                   gpointer      data)
 {
-  ClutterBackend *backend = data;
+  ClutterBackend *clutter_backend = data;
   MetaX11FilterReturn retval;
   CoglFilterReturn ret;
 
-  ret = cogl_xlib_renderer_handle_event (backend->cogl_renderer, xevent);
+  ret = cogl_xlib_renderer_handle_event (clutter_backend->cogl_renderer,
+                                         xevent);
   switch (ret)
     {
     case COGL_FILTER_REMOVE:
@@ -110,190 +112,78 @@ cogl_xlib_filter (XEvent       *xevent,
 }
 
 static gboolean
-meta_clutter_backend_x11_pre_parse (ClutterBackend  *backend,
-                                    GError         **error)
-{
-  const gchar *env_string;
-
-  /* we don't fail here if DISPLAY is not set, as the user
-   * might pass the --display command line switch
-   */
-  env_string = g_getenv ("DISPLAY");
-  if (env_string)
-    {
-      clutter_display_name = g_strdup (env_string);
-      env_string = NULL;
-    }
-
-  env_string = g_getenv ("CLUTTER_DISABLE_XINPUT");
-  if (env_string)
-    {
-      clutter_enable_xinput = FALSE;
-      env_string = NULL;
-    }
-
-  return TRUE;
-}
-
-static gboolean
-meta_clutter_backend_x11_post_parse (ClutterBackend  *backend,
-                                     GError         **error)
+meta_clutter_backend_x11_finish_init (ClutterBackend  *clutter_backend,
+                                      GError         **error)
 {
-  MetaClutterBackendX11 *backend_x11 = META_CLUTTER_BACKEND_X11 (backend);
+  MetaClutterBackendX11 *clutter_backend_x11 =
+    META_CLUTTER_BACKEND_X11 (clutter_backend);
+  MetaClutterBackendX11Private *priv =
+    meta_clutter_backend_x11_get_instance_private (clutter_backend_x11);
+  MetaBackendX11 *backend_x11 = META_BACKEND_X11 (priv->backend);
   Atom atoms[N_ATOM_NAMES];
+  Screen *xscreen;
 
-  if (_foreign_dpy)
-    backend_x11->xdisplay = _foreign_dpy;
-
-  /* Only open connection if not already set by prior call to
-   * clutter_x11_set_display()
-   */
-  if (backend_x11->xdisplay == NULL)
-    {
-      if (clutter_display_name != NULL &&
-          *clutter_display_name != '\0')
-	{
-	  g_debug ("XOpenDisplay on '%s'", clutter_display_name);
-
-	  backend_x11->xdisplay = XOpenDisplay (clutter_display_name);
-          if (backend_x11->xdisplay == NULL)
-            {
-              g_set_error (error, CLUTTER_INIT_ERROR,
-                           CLUTTER_INIT_ERROR_BACKEND,
-                           "Unable to open display '%s'",
-                           clutter_display_name);
-              return FALSE;
-            }
-	}
-      else
-	{
-	  g_set_error_literal (error, CLUTTER_INIT_ERROR,
-                               CLUTTER_INIT_ERROR_BACKEND,
-                               "Unable to open display. You have to set the "
-                               "DISPLAY environment variable, or use the "
-                               "--display command line argument");
-	  return FALSE;
-	}
-    }
-
-  g_assert (backend_x11->xdisplay != NULL);
-
-  g_debug ("Getting the X screen");
+  clutter_backend_x11->xdisplay = meta_backend_x11_get_xdisplay (backend_x11);
 
   /* add event filter for Cogl events */
-  meta_clutter_x11_add_filter (cogl_xlib_filter, backend);
+  meta_clutter_backend_x11_add_filter (clutter_backend_x11,
+                                       cogl_xlib_filter,
+                                       clutter_backend);
 
-  if (clutter_screen == -1)
-    backend_x11->xscreen = DefaultScreenOfDisplay (backend_x11->xdisplay);
-  else
-    backend_x11->xscreen = ScreenOfDisplay (backend_x11->xdisplay,
-                                            clutter_screen);
+  xscreen = DefaultScreenOfDisplay (clutter_backend_x11->xdisplay);
+  clutter_backend_x11->xscreen_num = XScreenNumberOfScreen (xscreen);
 
-  backend_x11->xscreen_num = XScreenNumberOfScreen (backend_x11->xscreen);
-  backend_x11->xscreen_width = WidthOfScreen (backend_x11->xscreen);
-  backend_x11->xscreen_height = HeightOfScreen (backend_x11->xscreen);
-
-  backend_x11->xwin_root = RootWindow (backend_x11->xdisplay,
-                                       backend_x11->xscreen_num);
-
-  backend_x11->display_name = g_strdup (clutter_display_name);
+  clutter_backend_x11->xwin_root = RootWindow (clutter_backend_x11->xdisplay,
+                                               clutter_backend_x11->xscreen_num);
 
   if (clutter_synchronise)
-    XSynchronize (backend_x11->xdisplay, True);
+    XSynchronize (clutter_backend_x11->xdisplay, True);
 
-  XInternAtoms (backend_x11->xdisplay,
+  XInternAtoms (clutter_backend_x11->xdisplay,
                 (char **) atom_names, N_ATOM_NAMES,
                 False, atoms);
 
-  backend_x11->atom_NET_WM_PID = atoms[0];
-  backend_x11->atom_NET_WM_PING = atoms[1];
-  backend_x11->atom_NET_WM_STATE = atoms[2];
-  backend_x11->atom_NET_WM_USER_TIME = atoms[3];
-  backend_x11->atom_WM_PROTOCOLS = atoms[4];
-  backend_x11->atom_WM_DELETE_WINDOW = atoms[5];
-  backend_x11->atom_XEMBED = atoms[6];
-  backend_x11->atom_XEMBED_INFO = atoms[7];
-  backend_x11->atom_NET_WM_NAME = atoms[8];
-  backend_x11->atom_UTF8_STRING = atoms[9];
-
-  g_free (clutter_display_name);
+  clutter_backend_x11->atom_NET_WM_PID = atoms[0];
+  clutter_backend_x11->atom_NET_WM_PING = atoms[1];
+  clutter_backend_x11->atom_NET_WM_STATE = atoms[2];
+  clutter_backend_x11->atom_NET_WM_USER_TIME = atoms[3];
+  clutter_backend_x11->atom_WM_PROTOCOLS = atoms[4];
+  clutter_backend_x11->atom_WM_DELETE_WINDOW = atoms[5];
+  clutter_backend_x11->atom_XEMBED = atoms[6];
+  clutter_backend_x11->atom_XEMBED_INFO = atoms[7];
+  clutter_backend_x11->atom_NET_WM_NAME = atoms[8];
+  clutter_backend_x11->atom_UTF8_STRING = atoms[9];
 
   g_debug ("X Display '%s'[%p] opened (screen:%d, root:%u, dpi:%f)",
-           backend_x11->display_name,
-           backend_x11->xdisplay,
-           backend_x11->xscreen_num,
-           (unsigned int) backend_x11->xwin_root,
-           clutter_backend_get_resolution (backend));
+           g_getenv ("DISPLAY"),
+           clutter_backend_x11->xdisplay,
+           clutter_backend_x11->xscreen_num,
+           (unsigned int) clutter_backend_x11->xwin_root,
+           clutter_backend_get_resolution (clutter_backend));
 
   return TRUE;
 }
 
-static const GOptionEntry entries[] =
-{
-  {
-    "display", 0,
-    G_OPTION_FLAG_IN_MAIN,
-    G_OPTION_ARG_STRING, &clutter_display_name,
-    N_("X display to use"), "DISPLAY"
-  },
-  {
-    "screen", 0,
-    G_OPTION_FLAG_IN_MAIN,
-    G_OPTION_ARG_INT, &clutter_screen,
-    N_("X screen to use"), "SCREEN"
-  },
-  { "synch", 0,
-    0,
-    G_OPTION_ARG_NONE, &clutter_synchronise,
-    N_("Make X calls synchronous"), NULL
-  },
-  {
-    "disable-xinput", 0,
-    G_OPTION_FLAG_REVERSE,
-    G_OPTION_ARG_NONE, &clutter_enable_xinput,
-    N_("Disable XInput support"), NULL
-  },
-  { NULL }
-};
-
-static void
-meta_clutter_backend_x11_add_options (ClutterBackend *backend,
-                                      GOptionGroup   *group)
-{
-  g_option_group_add_entries (group, entries);
-}
-
 static void
 meta_clutter_backend_x11_finalize (GObject *gobject)
 {
-  MetaClutterBackendX11 *backend_x11 = META_CLUTTER_BACKEND_X11 (gobject);
+  MetaClutterBackendX11 *clutter_backend_x11 = META_CLUTTER_BACKEND_X11 (gobject);
 
-  g_free (backend_x11->display_name);
+  meta_clutter_backend_x11_remove_filter (clutter_backend_x11,
+                                          cogl_xlib_filter,
+                                          clutter_backend_x11);
 
-  meta_clutter_x11_remove_filter (cogl_xlib_filter, gobject);
-
-  XCloseDisplay (backend_x11->xdisplay);
+  XCloseDisplay (clutter_backend_x11->xdisplay);
 
   G_OBJECT_CLASS (meta_clutter_backend_x11_parent_class)->finalize (gobject);
 }
 
-static ClutterFeatureFlags
-meta_clutter_backend_x11_get_features (ClutterBackend *backend)
-{
-  ClutterFeatureFlags flags = CLUTTER_FEATURE_STAGE_CURSOR;
-
-  flags |=
-    CLUTTER_BACKEND_CLASS (meta_clutter_backend_x11_parent_class)->get_features (backend);
-
-  return flags;
-}
-
 static void
-update_last_event_time (MetaClutterBackendX11 *backend_x11,
+update_last_event_time (MetaClutterBackendX11 *clutter_backend_x11,
                         XEvent                *xevent)
 {
   Time current_time = CurrentTime;
-  Time last_time = backend_x11->last_event_time;
+  Time last_time = clutter_backend_x11->last_event_time;
 
   switch (xevent->type)
     {
@@ -330,7 +220,7 @@ update_last_event_time (MetaClutterBackendX11 *backend_x11,
    */
   if ((current_time != CurrentTime) &&
       (current_time > last_time || (last_time - current_time > (30 * 1000))))
-    backend_x11->last_event_time = current_time;
+    clutter_backend_x11->last_event_time = current_time;
 }
 
 static gboolean
@@ -361,8 +251,7 @@ check_onscreen_template (CoglRenderer         *renderer,
     }
   else
     {
-      g_set_error_literal (error, CLUTTER_INIT_ERROR,
-                           CLUTTER_INIT_ERROR_BACKEND,
+      g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_FAILED,
                            internal_error != NULL
                            ? internal_error->message
                            : "Creation of a CoglDisplay failed");
@@ -374,7 +263,7 @@ check_onscreen_template (CoglRenderer         *renderer,
 }
 
 static CoglDisplay *
-meta_clutter_backend_x11_get_display (ClutterBackend  *backend,
+meta_clutter_backend_x11_get_display (ClutterBackend  *clutter_backend,
                                       CoglRenderer    *renderer,
                                       CoglSwapChain   *swap_chain,
                                       GError         **error)
@@ -408,14 +297,17 @@ static CoglRenderer *
 meta_clutter_backend_x11_get_renderer (ClutterBackend  *clutter_backend,
                                        GError         **error)
 {
-  MetaBackend *backend = meta_get_backend ();
-  MetaRenderer *renderer = meta_backend_get_renderer (backend);
+  MetaClutterBackendX11 *clutter_backend_x11 =
+    META_CLUTTER_BACKEND_X11 (clutter_backend);
+  MetaClutterBackendX11Private *priv =
+    meta_clutter_backend_x11_get_instance_private (clutter_backend_x11);
+  MetaRenderer *renderer = meta_backend_get_renderer (priv->backend);
 
   return meta_renderer_create_cogl_renderer (renderer);
 }
 
 static ClutterStageWindow *
-meta_clutter_backend_x11_create_stage (ClutterBackend  *backend,
+meta_clutter_backend_x11_create_stage (ClutterBackend  *clutter_backend,
                                        ClutterStage    *wrapper,
                                        GError         **error)
 {
@@ -428,23 +320,23 @@ meta_clutter_backend_x11_create_stage (ClutterBackend  *backend,
     stage_type  = META_TYPE_STAGE_X11;
 
   stage = g_object_new (stage_type,
-			"backend", backend,
+			"backend", clutter_backend,
 			"wrapper", wrapper,
 			NULL);
   return stage;
 }
 
 static gboolean
-meta_clutter_backend_x11_process_event_filters (MetaClutterBackendX11 *backend_x11,
+meta_clutter_backend_x11_process_event_filters (MetaClutterBackendX11 *clutter_backend_x11,
                                                 gpointer               native,
                                                 ClutterEvent          *event)
 {
   XEvent *xevent = native;
 
   /* X11 filter functions have a higher priority */
-  if (backend_x11->event_filters != NULL)
+  if (clutter_backend_x11->event_filters != NULL)
     {
-      GSList *node = backend_x11->event_filters;
+      GSList *node = clutter_backend_x11->event_filters;
 
       while (node != NULL)
         {
@@ -477,13 +369,14 @@ meta_clutter_backend_x11_translate_event (ClutterBackend *clutter_backend,
                                           gpointer        native,
                                           ClutterEvent   *event)
 {
-  MetaClutterBackendX11 *backend_x11 =
+  MetaClutterBackendX11 *clutter_backend_x11 =
     META_CLUTTER_BACKEND_X11 (clutter_backend);
-  MetaBackend *backend = meta_get_backend ();
+  MetaClutterBackendX11Private *priv =
+    meta_clutter_backend_x11_get_instance_private (clutter_backend_x11);
   MetaStageX11 *stage_x11;
   ClutterSeat *seat;
 
-  if (meta_clutter_backend_x11_process_event_filters (backend_x11,
+  if (meta_clutter_backend_x11_process_event_filters (clutter_backend_x11,
                                                       native,
                                                       event))
     return TRUE;
@@ -491,14 +384,14 @@ meta_clutter_backend_x11_translate_event (ClutterBackend *clutter_backend,
   /* we update the event time only for events that can
    * actually reach Clutter's event queue
    */
-  update_last_event_time (backend_x11, native);
+  update_last_event_time (clutter_backend_x11, native);
 
   stage_x11 =
     META_STAGE_X11 (clutter_backend_get_stage_window (clutter_backend));
   if (meta_stage_x11_translate_event (stage_x11, native, event))
     return TRUE;
 
-  seat = meta_backend_get_default_seat (backend);
+  seat = meta_backend_get_default_seat (priv->backend);
   if (meta_seat_x11_translate_event (META_SEAT_X11 (seat), native, event))
     return TRUE;
 
@@ -508,13 +401,16 @@ meta_clutter_backend_x11_translate_event (ClutterBackend *clutter_backend,
 static ClutterSeat *
 meta_clutter_backend_x11_get_default_seat (ClutterBackend *clutter_backend)
 {
-  MetaBackend *backend = meta_get_backend ();
+  MetaClutterBackendX11 *clutter_backend_x11 =
+    META_CLUTTER_BACKEND_X11 (clutter_backend);
+  MetaClutterBackendX11Private *priv =
+    meta_clutter_backend_x11_get_instance_private (clutter_backend_x11);
 
-  return meta_backend_get_default_seat (backend);
+  return meta_backend_get_default_seat (priv->backend);
 }
 
 static gboolean
-meta_clutter_backend_x11_is_display_server (ClutterBackend *backend)
+meta_clutter_backend_x11_is_display_server (ClutterBackend *clutter_backend)
 {
   return meta_is_wayland_compositor ();
 }
@@ -533,10 +429,7 @@ meta_clutter_backend_x11_class_init (MetaClutterBackendX11Class *klass)
 
   gobject_class->finalize = meta_clutter_backend_x11_finalize;
 
-  clutter_backend_class->pre_parse = meta_clutter_backend_x11_pre_parse;
-  clutter_backend_class->post_parse = meta_clutter_backend_x11_post_parse;
-  clutter_backend_class->add_options = meta_clutter_backend_x11_add_options;
-  clutter_backend_class->get_features = meta_clutter_backend_x11_get_features;
+  clutter_backend_class->finish_init = meta_clutter_backend_x11_finish_init;
 
   clutter_backend_class->get_display = meta_clutter_backend_x11_get_display;
   clutter_backend_class->get_renderer = meta_clutter_backend_x11_get_renderer;
@@ -546,6 +439,19 @@ meta_clutter_backend_x11_class_init (MetaClutterBackendX11Class *klass)
   clutter_backend_class->is_display_server = meta_clutter_backend_x11_is_display_server;
 }
 
+MetaClutterBackendX11 *
+meta_clutter_backend_x11_new (MetaBackend *backend)
+{
+  MetaClutterBackendX11 *clutter_backend_x11;
+  MetaClutterBackendX11Private *priv;
+
+  clutter_backend_x11 = g_object_new (META_TYPE_CLUTTER_BACKEND_X11, NULL);
+  priv = meta_clutter_backend_x11_get_instance_private (clutter_backend_x11);
+  priv->backend = backend;
+
+  return clutter_backend_x11;
+}
+
 static int
 error_handler (Display     *xdisplay,
                XErrorEvent *error)
@@ -572,136 +478,93 @@ meta_clutter_x11_untrap_x_errors (void)
 Display *
 meta_clutter_x11_get_default_display (void)
 {
-  ClutterBackend *backend = clutter_get_default_backend ();
+  ClutterBackend *clutter_backend = clutter_get_default_backend ();
 
-  if (backend == NULL)
+  if (clutter_backend == NULL)
     {
       g_critical ("The Clutter backend has not been initialised");
       return NULL;
     }
 
-  if (!META_IS_CLUTTER_BACKEND_X11 (backend))
+  if (!META_IS_CLUTTER_BACKEND_X11 (clutter_backend))
     {
       g_critical ("The Clutter backend is not a X11 backend");
       return NULL;
     }
 
-  return META_CLUTTER_BACKEND_X11 (backend)->xdisplay;
-}
-
-void
-meta_clutter_x11_set_display (Display *xdisplay)
-{
-  if (_clutter_context_is_initialized ())
-    {
-      g_warning ("%s() can only be used before calling clutter_init()",
-                 G_STRFUNC);
-      return;
-    }
-
-  _foreign_dpy= xdisplay;
+  return META_CLUTTER_BACKEND_X11 (clutter_backend)->xdisplay;
 }
 
 int
 meta_clutter_x11_get_default_screen (void)
 {
- ClutterBackend *backend = clutter_get_default_backend ();
+ ClutterBackend *clutter_backend = clutter_get_default_backend ();
 
-  if (backend == NULL)
+  if (clutter_backend == NULL)
     {
       g_critical ("The Clutter backend has not been initialised");
       return 0;
     }
 
-  if (!META_IS_CLUTTER_BACKEND_X11 (backend))
+  if (!META_IS_CLUTTER_BACKEND_X11 (clutter_backend))
     {
       g_critical ("The Clutter backend is not a X11 backend");
       return 0;
     }
 
-  return META_CLUTTER_BACKEND_X11 (backend)->xscreen_num;
+  return META_CLUTTER_BACKEND_X11 (clutter_backend)->xscreen_num;
 }
 
 Window
 meta_clutter_x11_get_root_window (void)
 {
- ClutterBackend *backend = clutter_get_default_backend ();
+ ClutterBackend *clutter_backend = clutter_get_default_backend ();
 
-  if (backend == NULL)
+  if (clutter_backend == NULL)
     {
       g_critical ("The Clutter backend has not been initialised");
       return None;
     }
 
-  if (!META_IS_CLUTTER_BACKEND_X11 (backend))
+  if (!META_IS_CLUTTER_BACKEND_X11 (clutter_backend))
     {
       g_critical ("The Clutter backend is not a X11 backend");
       return None;
     }
 
-  return META_CLUTTER_BACKEND_X11 (backend)->xwin_root;
+  return META_CLUTTER_BACKEND_X11 (clutter_backend)->xwin_root;
 }
 
 void
-meta_clutter_x11_add_filter (MetaX11FilterFunc func,
-                             gpointer             data)
+meta_clutter_backend_x11_add_filter (MetaClutterBackendX11 *clutter_backend_x11,
+                                     MetaX11FilterFunc      func,
+                                     gpointer               data)
 {
   MetaX11EventFilter *filter;
-  ClutterBackend *backend = clutter_get_default_backend ();
-  MetaClutterBackendX11 *backend_x11;
 
   g_return_if_fail (func != NULL);
 
-  if (backend == NULL)
-    {
-      g_critical ("The Clutter backend has not been initialised");
-      return;
-    }
-
-  if (!META_IS_CLUTTER_BACKEND_X11 (backend))
-    {
-      g_critical ("The Clutter backend is not a X11 backend");
-      return;
-    }
-
-  backend_x11 = META_CLUTTER_BACKEND_X11 (backend);
-
   filter = g_new0 (MetaX11EventFilter, 1);
   filter->func = func;
   filter->data = data;
 
-  backend_x11->event_filters =
-    g_slist_append (backend_x11->event_filters, filter);
+  clutter_backend_x11->event_filters =
+    g_slist_append (clutter_backend_x11->event_filters, filter);
 
   return;
 }
 
 void
-meta_clutter_x11_remove_filter (MetaX11FilterFunc func,
-                                gpointer          data)
+meta_clutter_backend_x11_remove_filter (MetaClutterBackendX11 *clutter_backend_x11,
+                                        MetaX11FilterFunc      func,
+                                        gpointer               data)
 {
   GSList *tmp_list, *this;
   MetaX11EventFilter *filter;
-  ClutterBackend *backend = clutter_get_default_backend ();
-  MetaClutterBackendX11 *backend_x11;
 
   g_return_if_fail (func != NULL);
 
-  if (backend == NULL)
-    {
-      g_critical ("The Clutter backend has not been initialised");
-      return;
-    }
-
-  if (!META_IS_CLUTTER_BACKEND_X11 (backend))
-    {
-      g_critical ("The Clutter backend is not a X11 backend");
-      return;
-    }
-
-  backend_x11 = META_CLUTTER_BACKEND_X11 (backend);
-
-  tmp_list = backend_x11->event_filters;
+  tmp_list = clutter_backend_x11->event_filters;
 
   while (tmp_list)
     {
@@ -711,8 +574,8 @@ meta_clutter_x11_remove_filter (MetaX11FilterFunc func,
 
       if (filter->func == func && filter->data == data)
         {
-          backend_x11->event_filters =
-            g_slist_remove_link (backend_x11->event_filters, this);
+          clutter_backend_x11->event_filters =
+            g_slist_remove_link (clutter_backend_x11->event_filters, this);
 
           g_slist_free_1 (this);
           g_free (filter);
diff --git a/src/backends/x11/meta-clutter-backend-x11.h b/src/backends/x11/meta-clutter-backend-x11.h
index d91a2f3af..9e1cfca13 100644
--- a/src/backends/x11/meta-clutter-backend-x11.h
+++ b/src/backends/x11/meta-clutter-backend-x11.h
@@ -27,6 +27,7 @@
 
 #include <glib-object.h>
 
+#include "backends/meta-backend-types.h"
 #include "clutter/clutter-mutter.h"
 
 struct _MetaClutterBackendX11
@@ -34,12 +35,8 @@ struct _MetaClutterBackendX11
   ClutterBackend parent_instance;
 
   Display *xdisplay;
-  char   *display_name;
 
-  Screen  *xscreen;
   int      xscreen_num;
-  int      xscreen_width;
-  int      xscreen_height;
 
   Window   xwin_root;
 
@@ -77,18 +74,22 @@ typedef MetaX11FilterReturn (*MetaX11FilterFunc) (XEvent        *xev,
                                                   ClutterEvent  *cev,
                                                   gpointer       data);
 
+MetaClutterBackendX11 * meta_clutter_backend_x11_new (MetaBackend *backend);
+
 void meta_clutter_x11_trap_x_errors (void);
 gint meta_clutter_x11_untrap_x_errors (void);
 
 Display *meta_clutter_x11_get_default_display (void);
 int meta_clutter_x11_get_default_screen (void);
 Window meta_clutter_x11_get_root_window (void);
-void meta_clutter_x11_set_display (Display * xdpy);
 
-void meta_clutter_x11_add_filter (MetaX11FilterFunc func,
-                                  gpointer          data);
-void meta_clutter_x11_remove_filter (MetaX11FilterFunc func,
-                                     gpointer          data);
+void meta_clutter_backend_x11_add_filter (MetaClutterBackendX11 *clutter_backend_x11,
+                                          MetaX11FilterFunc      func,
+                                          gpointer               data);
+
+void meta_clutter_backend_x11_remove_filter (MetaClutterBackendX11 *clutter_backend_x11,
+                                             MetaX11FilterFunc      func,
+                                             gpointer               data);
 
 void meta_clutter_x11_set_use_stereo_stage (gboolean use_stereo);
 gboolean meta_clutter_x11_get_use_stereo_stage (void);
diff --git a/src/backends/x11/meta-event-x11.c b/src/backends/x11/meta-event-x11.c
index d1a94bb56..e6483a815 100644
--- a/src/backends/x11/meta-event-x11.c
+++ b/src/backends/x11/meta-event-x11.c
@@ -102,7 +102,8 @@ meta_x11_handle_event (XEvent *xevent)
   while (spin > 0 && (event = clutter_event_get ()))
     {
       /* forward the event into clutter for emission etc. */
-      _clutter_stage_queue_event (event->any.stage, event, FALSE);
+      clutter_do_event (event);
+      clutter_event_free (event);
       --spin;
     }
 
diff --git a/src/backends/x11/meta-keymap-x11.c b/src/backends/x11/meta-keymap-x11.c
index 89542e859..d29a858fe 100644
--- a/src/backends/x11/meta-keymap-x11.c
+++ b/src/backends/x11/meta-keymap-x11.c
@@ -869,9 +869,9 @@ meta_keymap_x11_release_keycode_if_needed (MetaKeymapX11 *keymap_x11,
 }
 
 void
-meta_keymap_x11_latch_modifiers (MetaKeymapX11 *keymap_x11,
-                                 uint32_t       level,
-                                 gboolean       enable)
+meta_keymap_x11_lock_modifiers (MetaKeymapX11 *keymap_x11,
+                                uint32_t       level,
+                                gboolean       enable)
 {
   uint32_t modifiers[] = {
     0,
@@ -891,9 +891,9 @@ meta_keymap_x11_latch_modifiers (MetaKeymapX11 *keymap_x11,
   else
     value = 0;
 
-  XkbLatchModifiers (meta_clutter_x11_get_default_display (),
-                     XkbUseCoreKbd, modifiers[level],
-                     value);
+  XkbLockModifiers (meta_clutter_x11_get_default_display (),
+                    XkbUseCoreKbd, modifiers[level],
+                    value);
 }
 
 static uint32_t
diff --git a/src/backends/x11/meta-keymap-x11.h b/src/backends/x11/meta-keymap-x11.h
index 67a5f8eb9..2f93acdbc 100644
--- a/src/backends/x11/meta-keymap-x11.h
+++ b/src/backends/x11/meta-keymap-x11.h
@@ -44,9 +44,9 @@ gboolean meta_keymap_x11_keycode_for_keyval       (MetaKeymapX11    *keymap_x11,
                                                    guint             keyval,
                                                    guint            *keycode_out,
                                                    guint            *level_out);
-void     meta_keymap_x11_latch_modifiers          (MetaKeymapX11 *keymap_x11,
-                                                   uint32_t          level,
-                                                   gboolean          enable);
+void     meta_keymap_x11_lock_modifiers           (MetaKeymapX11 *keymap_x11,
+                                                   uint32_t       level,
+                                                   gboolean       enable);
 gboolean meta_keymap_x11_reserve_keycode           (MetaKeymapX11 *keymap_x11,
                                                     guint             keyval,
                                                     guint            *keycode_out);
diff --git a/src/backends/x11/meta-renderer-x11.c b/src/backends/x11/meta-renderer-x11.c
index e31faff53..0ee74e31b 100644
--- a/src/backends/x11/meta-renderer-x11.c
+++ b/src/backends/x11/meta-renderer-x11.c
@@ -30,6 +30,7 @@
 #include "backends/meta-logical-monitor.h"
 #include "backends/meta-renderer-view.h"
 #include "backends/meta-renderer.h"
+#include "backends/x11/meta-backend-x11.h"
 #include "backends/x11/meta-clutter-backend-x11.h"
 #include "backends/x11/meta-renderer-x11.h"
 #include "cogl/cogl-xlib.h"
@@ -81,8 +82,10 @@ get_x11_cogl_winsys_vtable (CoglRenderer *renderer)
 static CoglRenderer *
 meta_renderer_x11_create_cogl_renderer (MetaRenderer *renderer)
 {
+  MetaBackend *backend = meta_renderer_get_backend (renderer);
+  MetaBackendX11 *backend_x11 = META_BACKEND_X11 (backend);
+  Display *xdisplay = meta_backend_x11_get_xdisplay (backend_x11);
   CoglRenderer *cogl_renderer;
-  Display *xdisplay = meta_clutter_x11_get_default_display ();
 
   cogl_renderer = cogl_renderer_new ();
   cogl_renderer_set_custom_winsys (cogl_renderer, get_x11_cogl_winsys_vtable,
diff --git a/src/backends/x11/meta-seat-x11.c b/src/backends/x11/meta-seat-x11.c
index 2f2637ac8..0cfa2e510 100644
--- a/src/backends/x11/meta-seat-x11.c
+++ b/src/backends/x11/meta-seat-x11.c
@@ -156,7 +156,9 @@ translate_valuator_class (Display             *xdisplay,
                                   class->resolution);
 
   g_debug ("Added axis '%s' (min:%.2f, max:%.2fd, res:%d) of device %d",
-           clutter_input_axis_atom_names[axis],
+           axis == CLUTTER_INPUT_AXIS_IGNORE ?
+             "Ignored" :
+             clutter_input_axis_atom_names[axis - 1],
            class->min,
            class->max,
            class->resolution,
diff --git a/src/backends/x11/meta-stage-x11.c b/src/backends/x11/meta-stage-x11.c
index 87e7ffec6..203ba9106 100644
--- a/src/backends/x11/meta-stage-x11.c
+++ b/src/backends/x11/meta-stage-x11.c
@@ -80,26 +80,16 @@ meta_stage_x11_fix_window_size (MetaStageX11 *stage_x11,
                                 int           new_width,
                                 int           new_height)
 {
-  MetaStageImpl *stage_impl = META_STAGE_IMPL (stage_x11);
+  g_return_if_fail (new_width > 0);
+  g_return_if_fail (new_height > 0);
 
   if (stage_x11->xwin != None)
     {
       Display *xdisplay = meta_clutter_x11_get_default_display ();
-      uint32_t min_width, min_height;
       XSizeHints *size_hints;
 
       size_hints = XAllocSizeHints();
 
-      clutter_stage_get_minimum_size (stage_impl->wrapper,
-                                      &min_width,
-                                      &min_height);
-
-      if (new_width <= 0)
-        new_width = min_width;
-
-      if (new_height <= 0)
-        new_height = min_height;
-
       size_hints->min_width = new_width;
       size_hints->min_height = new_height;
       size_hints->max_width = new_width;
diff --git a/src/backends/x11/meta-virtual-input-device-x11.c b/src/backends/x11/meta-virtual-input-device-x11.c
index 54bb43ad1..f6464fb91 100644
--- a/src/backends/x11/meta-virtual-input-device-x11.c
+++ b/src/backends/x11/meta-virtual-input-device-x11.c
@@ -186,7 +186,7 @@ meta_virtual_input_device_x11_notify_keyval (ClutterVirtualInputDevice *virtual_
 
   if (!meta_keymap_x11_get_is_modifier (keymap, keycode) &&
       key_state == CLUTTER_KEY_STATE_PRESSED)
-    meta_keymap_x11_latch_modifiers (keymap, level, TRUE);
+    meta_keymap_x11_lock_modifiers (keymap, level, TRUE);
 
   XTestFakeKeyEvent (meta_clutter_x11_get_default_display (),
                      (KeyCode) keycode,
@@ -196,7 +196,7 @@ meta_virtual_input_device_x11_notify_keyval (ClutterVirtualInputDevice *virtual_
   if (key_state == CLUTTER_KEY_STATE_RELEASED)
     {
       if (!meta_keymap_x11_get_is_modifier (keymap, keycode))
-        meta_keymap_x11_latch_modifiers (keymap, level, FALSE);
+        meta_keymap_x11_lock_modifiers (keymap, level, FALSE);
       meta_keymap_x11_release_keycode_if_needed (keymap, keycode);
     }
 }
diff --git a/src/backends/x11/meta-xkb-a11y-x11.c b/src/backends/x11/meta-xkb-a11y-x11.c
index c73b9dc4f..4cfd52e77 100644
--- a/src/backends/x11/meta-xkb-a11y-x11.c
+++ b/src/backends/x11/meta-xkb-a11y-x11.c
@@ -323,6 +323,10 @@ meta_seat_x11_apply_kbd_a11y_settings (ClutterSeat         *seat,
 gboolean
 meta_seat_x11_a11y_init (ClutterSeat *seat)
 {
+  MetaBackend *backend = meta_get_backend ();
+  ClutterBackend *clutter_backend = meta_backend_get_clutter_backend (backend);
+  MetaClutterBackendX11 *clutter_backend_x11 =
+    META_CLUTTER_BACKEND_X11 (clutter_backend);
   Display *xdisplay = meta_clutter_x11_get_default_display ();
   guint event_mask;
 
@@ -333,7 +337,9 @@ meta_seat_x11_a11y_init (ClutterSeat *seat)
 
   XkbSelectEvents (xdisplay, XkbUseCoreKbd, event_mask, event_mask);
 
-  meta_clutter_x11_add_filter (xkb_a11y_event_filter, seat);
+  meta_clutter_backend_x11_add_filter (clutter_backend_x11,
+                                       xkb_a11y_event_filter,
+                                       seat);
 
   return TRUE;
 }
diff --git a/src/compositor/clutter-utils.c b/src/compositor/clutter-utils.c
index 86d788562..3c7165f1e 100644
--- a/src/compositor/clutter-utils.c
+++ b/src/compositor/clutter-utils.c
@@ -69,8 +69,7 @@ gboolean
 meta_actor_vertices_are_untransformed (graphene_point3d_t *verts,
                                        float               widthf,
                                        float               heightf,
-                                       int                *x_origin,
-                                       int                *y_origin)
+                                       MetaTransforms     *trans)
 {
   int width, height;
   int v0x, v0y, v1x, v1y, v2x, v2y, v3x, v3y;
@@ -90,6 +89,14 @@ meta_actor_vertices_are_untransformed (graphene_point3d_t *verts,
   x = v0x >> 8;
   y = v0y >> 8;
 
+  if (trans)
+    {
+      trans->x_origin = x;
+      trans->y_origin = y;
+      trans->x_scale = (v1x - v0x) / (float) width;
+      trans->y_scale = (v2y - v0y) / (float) height;
+    }
+
   /* At integral coordinates? */
   if (x * 256 != v0x || y * 256 != v0y)
     return FALSE;
@@ -103,11 +110,6 @@ meta_actor_vertices_are_untransformed (graphene_point3d_t *verts,
       v3x != v1x || v3y != v2y)
     return FALSE;
 
-  if (x_origin)
-    *x_origin = x;
-  if (y_origin)
-    *y_origin = y;
-
   return TRUE;
 }
 
@@ -137,8 +139,7 @@ meta_actor_painting_untransformed (CoglFramebuffer *fb,
                                    int              paint_height,
                                    int              sample_width,
                                    int              sample_height,
-                                   int             *x_origin,
-                                   int             *y_origin)
+                                   MetaTransforms  *trans)
 {
   graphene_matrix_t modelview, projection, modelview_projection;
   graphene_point3d_t vertices[4];
@@ -183,6 +184,6 @@ meta_actor_painting_untransformed (CoglFramebuffer *fb,
 
   return meta_actor_vertices_are_untransformed (vertices,
                                                 sample_width, sample_height,
-                                                x_origin, y_origin);
+                                                trans);
 }
 
diff --git a/src/compositor/clutter-utils.h b/src/compositor/clutter-utils.h
index 8ed0e2a4d..039e61a61 100644
--- a/src/compositor/clutter-utils.h
+++ b/src/compositor/clutter-utils.h
@@ -23,18 +23,21 @@
 
 #include "clutter/clutter.h"
 
+typedef struct {
+  int x_origin, y_origin;
+  float x_scale, y_scale;
+} MetaTransforms;
+
 gboolean meta_actor_vertices_are_untransformed (graphene_point3d_t *verts,
                                                 float               widthf,
                                                 float               heightf,
-                                                int                *x_origin,
-                                                int                *y_origin);
+                                                MetaTransforms     *trans);
 
 gboolean meta_actor_painting_untransformed (CoglFramebuffer *fb,
                                             int              paint_width,
                                             int              paint_height,
                                             int              sample_widthf,
                                             int              sample_heightf,
-                                            int             *x_origin,
-                                            int             *y_origin);
+                                            MetaTransforms  *trans);
 
 #endif /* __META_CLUTTER_UTILS_H__ */
diff --git a/src/compositor/compositor.c b/src/compositor/compositor.c
index 9cdd39c15..ee6be007b 100644
--- a/src/compositor/compositor.c
+++ b/src/compositor/compositor.c
@@ -353,33 +353,24 @@ grab_devices (MetaModalOptions  options,
               guint32           timestamp)
 {
   MetaBackend *backend = META_BACKEND (meta_get_backend ());
-  gboolean pointer_grabbed = FALSE;
-  gboolean keyboard_grabbed = FALSE;
 
   if ((options & META_MODAL_POINTER_ALREADY_GRABBED) == 0)
     {
       if (!meta_backend_grab_device (backend, META_VIRTUAL_CORE_POINTER_ID, timestamp))
         goto fail;
-
-      pointer_grabbed = TRUE;
     }
 
   if ((options & META_MODAL_KEYBOARD_ALREADY_GRABBED) == 0)
     {
       if (!meta_backend_grab_device (backend, META_VIRTUAL_CORE_KEYBOARD_ID, timestamp))
-        goto fail;
-
-      keyboard_grabbed = TRUE;
+        goto ungrab_pointer;
     }
 
   return TRUE;
 
+ ungrab_pointer:
+  meta_backend_ungrab_device (backend, META_VIRTUAL_CORE_POINTER_ID, timestamp);
  fail:
-  if (pointer_grabbed)
-    meta_backend_ungrab_device (backend, META_VIRTUAL_CORE_POINTER_ID, timestamp);
-  if (keyboard_grabbed)
-    meta_backend_ungrab_device (backend, META_VIRTUAL_CORE_KEYBOARD_ID, timestamp);
-
   return FALSE;
 }
 
diff --git a/src/compositor/meta-background-content.c b/src/compositor/meta-background-content.c
index 49f5885ca..93de521d0 100644
--- a/src/compositor/meta-background-content.c
+++ b/src/compositor/meta-background-content.c
@@ -561,7 +561,7 @@ setup_pipeline (MetaBackgroundContent *self,
                                          actor_pixel_rect->height,
                                          self->texture_width,
                                          self->texture_height,
-                                         NULL, NULL))
+                                         NULL))
     {
       min_filter = COGL_PIPELINE_FILTER_NEAREST;
       mag_filter = COGL_PIPELINE_FILTER_NEAREST;
diff --git a/src/compositor/meta-compositor-native.c b/src/compositor/meta-compositor-native.c
index 00f66b70d..7822789a3 100644
--- a/src/compositor/meta-compositor-native.c
+++ b/src/compositor/meta-compositor-native.c
@@ -23,11 +23,14 @@
 #include "compositor/meta-compositor-native.h"
 
 #include "backends/meta-logical-monitor.h"
+#include "backends/native/meta-crtc-kms.h"
 #include "compositor/meta-surface-actor-wayland.h"
 
 struct _MetaCompositorNative
 {
   MetaCompositorServer parent;
+
+  MetaWaylandSurface *current_scanout_candidate;
 };
 
 G_DEFINE_TYPE (MetaCompositorNative, meta_compositor_native,
@@ -62,57 +65,88 @@ get_window_view (MetaRenderer *renderer,
 static void
 maybe_assign_primary_plane (MetaCompositor *compositor)
 {
+  MetaCompositorNative *compositor_native = META_COMPOSITOR_NATIVE (compositor);
   MetaBackend *backend = meta_get_backend ();
   MetaRenderer *renderer = meta_backend_get_renderer (backend);
   MetaWindowActor *window_actor;
   MetaWindow *window;
   MetaRendererView *view;
+  MetaCrtc *crtc;
   CoglFramebuffer *framebuffer;
   CoglOnscreen *onscreen;
   MetaSurfaceActor *surface_actor;
   MetaSurfaceActorWayland *surface_actor_wayland;
+  MetaWaylandSurface *surface;
+  MetaWaylandSurface *old_candidate =
+    compositor_native->current_scanout_candidate;
+  MetaWaylandSurface *new_candidate = NULL;
   g_autoptr (CoglScanout) scanout = NULL;
 
   if (meta_compositor_is_unredirect_inhibited (compositor))
-    return;
+    goto done;
 
   window_actor = meta_compositor_get_top_window_actor (compositor);
   if (!window_actor)
-    return;
+    goto done;
 
   if (meta_window_actor_effect_in_progress (window_actor))
-    return;
+    goto done;
 
   if (clutter_actor_has_transitions (CLUTTER_ACTOR (window_actor)))
-    return;
+    goto done;
 
   if (clutter_actor_get_n_children (CLUTTER_ACTOR (window_actor)) != 1)
-    return;
+    goto done;
 
   window = meta_window_actor_get_meta_window (window_actor);
   if (!window)
-    return;
+    goto done;
 
   view = get_window_view (renderer, window);
   if (!view)
-    return;
+    goto done;
+
+  crtc = meta_renderer_view_get_crtc (META_RENDERER_VIEW (view));
+  if (!META_IS_CRTC_KMS (crtc))
+    goto done;
 
   framebuffer = clutter_stage_view_get_framebuffer (CLUTTER_STAGE_VIEW (view));
   if (!COGL_IS_ONSCREEN (framebuffer))
-    return;
+    goto done;
 
   surface_actor = meta_window_actor_get_surface (window_actor);
   if (!META_IS_SURFACE_ACTOR_WAYLAND (surface_actor))
-    return;
-
+    goto done;
   surface_actor_wayland = META_SURFACE_ACTOR_WAYLAND (surface_actor);
+
+  surface = meta_surface_actor_wayland_get_surface (surface_actor_wayland);
+  if (!surface)
+    goto done;
+
+  new_candidate = surface;
+
   onscreen = COGL_ONSCREEN (framebuffer);
   scanout = meta_surface_actor_wayland_try_acquire_scanout (surface_actor_wayland,
                                                             onscreen);
   if (!scanout)
-    return;
+    goto done;
 
   clutter_stage_view_assign_next_scanout (CLUTTER_STAGE_VIEW (view), scanout);
+
+done:
+
+  if (old_candidate && old_candidate != new_candidate)
+    {
+      meta_wayland_surface_set_scanout_candidate (old_candidate, NULL);
+      g_clear_weak_pointer (&compositor_native->current_scanout_candidate);
+    }
+
+  if (new_candidate)
+    {
+      meta_wayland_surface_set_scanout_candidate (surface, crtc);
+      g_set_weak_pointer (&compositor_native->current_scanout_candidate,
+                          surface);
+    }
 }
 
 static void
@@ -137,6 +171,16 @@ meta_compositor_native_new (MetaDisplay *display,
                        NULL);
 }
 
+static void
+meta_compositor_native_finalize (GObject *object)
+{
+  MetaCompositorNative *compositor_native = META_COMPOSITOR_NATIVE (object);
+
+  g_clear_weak_pointer (&compositor_native->current_scanout_candidate);
+
+  G_OBJECT_CLASS (meta_compositor_native_parent_class)->finalize (object);
+}
+
 static void
 meta_compositor_native_init (MetaCompositorNative *compositor_native)
 {
@@ -145,7 +189,10 @@ meta_compositor_native_init (MetaCompositorNative *compositor_native)
 static void
 meta_compositor_native_class_init (MetaCompositorNativeClass *klass)
 {
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
   MetaCompositorClass *compositor_class = META_COMPOSITOR_CLASS (klass);
 
+  object_class->finalize = meta_compositor_native_finalize;
+
   compositor_class->before_paint = meta_compositor_native_before_paint;
 }
diff --git a/src/compositor/meta-cullable.c b/src/compositor/meta-cullable.c
index 6f38c5e47..e306c56e2 100644
--- a/src/compositor/meta-cullable.c
+++ b/src/compositor/meta-cullable.c
@@ -175,7 +175,7 @@ meta_cullable_default_is_untransformed (MetaCullable *cullable)
   clutter_actor_get_abs_allocation_vertices (CLUTTER_ACTOR (cullable), verts);
 
   return meta_actor_vertices_are_untransformed (verts, width, height,
-                                                NULL, NULL);
+                                                NULL);
 }
 
 static void
diff --git a/src/compositor/meta-shaped-texture-private.h b/src/compositor/meta-shaped-texture-private.h
index bfe3039a9..ff5f2fa96 100644
--- a/src/compositor/meta-shaped-texture-private.h
+++ b/src/compositor/meta-shaped-texture-private.h
@@ -30,7 +30,7 @@
 #include "backends/meta-monitor-manager-private.h"
 #include "meta/meta-shaped-texture.h"
 
-MetaShapedTexture *meta_shaped_texture_new (void);
+MetaShapedTexture * meta_shaped_texture_new (void);
 void meta_shaped_texture_set_texture (MetaShapedTexture *stex,
                                       CoglTexture       *texture);
 void meta_shaped_texture_set_is_y_inverted (MetaShapedTexture *stex,
diff --git a/src/compositor/meta-shaped-texture.c b/src/compositor/meta-shaped-texture.c
index 1a68f3e1b..9d94bcbb0 100644
--- a/src/compositor/meta-shaped-texture.c
+++ b/src/compositor/meta-shaped-texture.c
@@ -41,7 +41,6 @@
 
 #include "cogl/cogl.h"
 #include "compositor/clutter-utils.h"
-#include "compositor/meta-texture-tower.h"
 #include "compositor/region-utils.h"
 #include "core/boxes-private.h"
 #include "meta/meta-shaped-texture.h"
@@ -82,8 +81,6 @@ struct _MetaShapedTexture
 {
   GObject parent;
 
-  MetaTextureTower *paint_tower;
-
   CoglTexture *texture;
   CoglTexture *mask_texture;
   CoglSnippet *snippet;
@@ -92,6 +89,11 @@ struct _MetaShapedTexture
   CoglPipeline *masked_pipeline;
   CoglPipeline *unblended_pipeline;
 
+  CoglTexture *mipmap_texture;
+  gboolean mipmap_texture_out_of_date;
+  CoglFramebuffer *mipmap_fb;
+  CoglPipeline *mipmap_pipeline;
+
   gboolean is_y_inverted;
 
   /* The region containing only fully opaque pixels */
@@ -150,8 +152,6 @@ invalidate_size (MetaShapedTexture *stex)
 static void
 meta_shaped_texture_init (MetaShapedTexture *stex)
 {
-  stex->paint_tower = meta_texture_tower_new ();
-
   stex->buffer_scale = 1;
   stex->texture = NULL;
   stex->mask_texture = NULL;
@@ -244,6 +244,13 @@ meta_shaped_texture_reset_pipelines (MetaShapedTexture *stex)
   g_clear_pointer (&stex->unblended_pipeline, cogl_object_unref);
 }
 
+static void
+free_mipmaps (MetaShapedTexture *stex)
+{
+  g_clear_object (&stex->mipmap_fb);
+  cogl_clear_object (&stex->mipmap_texture);
+}
+
 static void
 meta_shaped_texture_dispose (GObject *object)
 {
@@ -251,9 +258,8 @@ meta_shaped_texture_dispose (GObject *object)
 
   g_clear_handle_id (&stex->remipmap_timeout_id, g_source_remove);
 
-  if (stex->paint_tower)
-    meta_texture_tower_free (stex->paint_tower);
-  stex->paint_tower = NULL;
+  free_mipmaps (stex);
+  cogl_clear_object (&stex->mipmap_pipeline);
 
   g_clear_pointer (&stex->texture, cogl_object_unref);
 
@@ -548,13 +554,7 @@ set_cogl_texture (MetaShapedTexture *stex,
       update_size (stex);
     }
 
-  /* NB: We don't queue a redraw of the actor here because we don't
-   * know how much of the buffer has changed with respect to the
-   * previous buffer. We only queue a redraw in response to surface
-   * damage. */
-
-  if (stex->create_mipmaps)
-    meta_texture_tower_set_base_texture (stex->paint_tower, cogl_tex);
+  stex->mipmap_texture_out_of_date = TRUE;
 }
 
 static gboolean
@@ -582,11 +582,14 @@ flip_ints (int *x,
   *y = tmp;
 }
 
+static CoglTexture *
+select_texture_for_paint (MetaShapedTexture   *stex,
+                          ClutterPaintContext *paint_context);
+
 static void
 do_paint_content (MetaShapedTexture   *stex,
                   ClutterPaintNode    *root_node,
                   ClutterPaintContext *paint_context,
-                  CoglTexture         *paint_tex,
                   ClutterActorBox     *alloc,
                   uint8_t              opacity)
 {
@@ -595,7 +598,9 @@ do_paint_content (MetaShapedTexture   *stex,
   gboolean use_opaque_region;
   cairo_region_t *blended_tex_region;
   CoglContext *ctx;
-  CoglPipelineFilter filter;
+  CoglPipelineFilter min_filter, mag_filter;
+  MetaTransforms transforms;
+  CoglTexture *paint_tex = stex->texture;
   CoglFramebuffer *framebuffer;
   int sample_width, sample_height;
   gboolean debug_paint_opaque_region;
@@ -642,10 +647,33 @@ do_paint_content (MetaShapedTexture   *stex,
   if (meta_actor_painting_untransformed (framebuffer,
                                          dst_width, dst_height,
                                          sample_width, sample_height,
-                                         NULL, NULL))
-    filter = COGL_PIPELINE_FILTER_NEAREST;
+                                         &transforms))
+    {
+      min_filter = COGL_PIPELINE_FILTER_NEAREST;
+      mag_filter = COGL_PIPELINE_FILTER_NEAREST;
+
+      /* Back to normal desktop viewing. Save some memory */
+      free_mipmaps (stex);
+    }
   else
-    filter = COGL_PIPELINE_FILTER_LINEAR;
+    {
+      min_filter = COGL_PIPELINE_FILTER_LINEAR;
+      mag_filter = COGL_PIPELINE_FILTER_LINEAR;
+
+      /* If we're painting a texture below half its native resolution
+       * then mipmapping is required to avoid aliasing. If it's above
+       * half then sticking with COGL_PIPELINE_FILTER_LINEAR will look
+       * and perform better.
+       */
+      if (stex->create_mipmaps &&
+          transforms.x_scale < 0.5 &&
+          transforms.y_scale < 0.5)
+        {
+          paint_tex = select_texture_for_paint (stex, paint_context);
+          if (paint_tex == stex->mipmap_texture)
+            min_filter = COGL_PIPELINE_FILTER_LINEAR_MIPMAP_NEAREST;
+        }
+    }
 
   ctx = clutter_backend_get_cogl_context (clutter_get_default_backend ());
 
@@ -707,7 +735,7 @@ do_paint_content (MetaShapedTexture   *stex,
 
           opaque_pipeline = get_unblended_pipeline (stex, ctx);
           cogl_pipeline_set_layer_texture (opaque_pipeline, 0, paint_tex);
-          cogl_pipeline_set_layer_filters (opaque_pipeline, 0, filter, filter);
+          cogl_pipeline_set_layer_filters (opaque_pipeline, 0, min_filter, mag_filter);
 
           n_rects = cairo_region_num_rectangles (region);
           for (i = 0; i < n_rects; i++)
@@ -755,11 +783,11 @@ do_paint_content (MetaShapedTexture   *stex,
         {
           blended_pipeline = get_masked_pipeline (stex, ctx);
           cogl_pipeline_set_layer_texture (blended_pipeline, 1, stex->mask_texture);
-          cogl_pipeline_set_layer_filters (blended_pipeline, 1, filter, filter);
+          cogl_pipeline_set_layer_filters (blended_pipeline, 1, min_filter, mag_filter);
         }
 
       cogl_pipeline_set_layer_texture (blended_pipeline, 0, paint_tex);
-      cogl_pipeline_set_layer_filters (blended_pipeline, 0, filter, filter);
+      cogl_pipeline_set_layer_filters (blended_pipeline, 0, min_filter, mag_filter);
 
       CoglColor color;
       cogl_color_init_from_4ub (&color, opacity, opacity, opacity, opacity);
@@ -824,6 +852,94 @@ do_paint_content (MetaShapedTexture   *stex,
   g_clear_pointer (&blended_tex_region, cairo_region_destroy);
 }
 
+static void
+ensure_mipmap_texture (MetaShapedTexture *stex)
+{
+  CoglContext *ctx =
+    clutter_backend_get_cogl_context (clutter_get_default_backend ());
+  int width, height;
+
+  /* Let's avoid spending any texture memory copying the base level texture
+   * because we'll never need that one and it would have used most of the
+   * memory;
+   *    S(0) = W x H
+   *    S(n) = S(n-1) / 4
+   *    sum to infinity of S(n) = 4/3 * S(0)
+   * So subtracting S(0) means even infinite mipmap levels only need one third
+   * of the original texture's memory. Finite levels need less.
+   *
+   * The fact that mipmap level 0 of stex->mipmap_texture is half the
+   * resolution of stex->texture makes no visual difference, so long as you're
+   * never trying to view a level of detail higher than half. If you need that
+   * then just use stex->texture instead of stex->mipmap_texture, which is
+   * faster anyway.
+   */
+  width = cogl_texture_get_width (stex->texture) / 2;
+  height = cogl_texture_get_height (stex->texture) / 2;
+
+  if (!width || !height)
+    {
+      free_mipmaps (stex);
+      return;
+    }
+
+  if (!stex->mipmap_texture ||
+      cogl_texture_get_width (stex->mipmap_texture) != width ||
+      cogl_texture_get_height (stex->mipmap_texture) != height)
+    {
+      CoglOffscreen *offscreen;
+      CoglTexture2D *tex2d;
+
+      free_mipmaps (stex);
+
+      tex2d = cogl_texture_2d_new_with_size (ctx, width, height);
+      if (!tex2d)
+        return;
+
+      stex->mipmap_texture = COGL_TEXTURE (tex2d);
+
+      offscreen = cogl_offscreen_new_with_texture (stex->mipmap_texture);
+      if (!offscreen)
+        {
+          free_mipmaps (stex);
+          return;
+        }
+
+      stex->mipmap_fb = COGL_FRAMEBUFFER (offscreen);
+
+      if (!cogl_framebuffer_allocate (stex->mipmap_fb, NULL))
+        {
+          free_mipmaps (stex);
+          return;
+        }
+
+      cogl_framebuffer_orthographic (stex->mipmap_fb,
+                                     0, 0, width, height, -1.0, 1.0);
+
+      stex->mipmap_texture_out_of_date = TRUE;
+    }
+
+  if (stex->mipmap_texture_out_of_date)
+    {
+      if (!stex->mipmap_pipeline)
+        {
+          stex->mipmap_pipeline = cogl_pipeline_new (ctx);
+          cogl_pipeline_set_blend (stex->mipmap_pipeline, "RGBA = ADD (SRC_COLOR, 0)", NULL);
+          cogl_pipeline_set_layer_filters (stex->mipmap_pipeline, 0,
+                                           COGL_PIPELINE_FILTER_LINEAR,
+                                           COGL_PIPELINE_FILTER_LINEAR);
+        }
+
+      cogl_pipeline_set_layer_texture (stex->mipmap_pipeline, 0, stex->texture);
+      cogl_framebuffer_draw_textured_rectangle (stex->mipmap_fb,
+                                                stex->mipmap_pipeline,
+                                                0, 0, width, height,
+                                                0.0, 0.0, 1.0, 1.0);
+
+      stex->mipmap_texture_out_of_date = FALSE;
+    }
+}
+
 static CoglTexture *
 select_texture_for_paint (MetaShapedTexture   *stex,
                           ClutterPaintContext *paint_context)
@@ -843,8 +959,8 @@ select_texture_for_paint (MetaShapedTexture   *stex,
       if (age >= MIN_MIPMAP_AGE_USEC ||
           stex->fast_updates < MIN_FAST_UPDATES_BEFORE_UNMIPMAP)
         {
-          texture = meta_texture_tower_get_paint_texture (stex->paint_tower,
-                                                          paint_context);
+          ensure_mipmap_texture (stex);
+          texture = stex->mipmap_texture;
         }
     }
 
@@ -876,7 +992,6 @@ meta_shaped_texture_paint_content (ClutterContent      *content,
 {
   MetaShapedTexture *stex = META_SHAPED_TEXTURE (content);
   ClutterActorBox alloc;
-  CoglTexture *paint_tex = NULL;
   uint8_t opacity;
 
   if (stex->clip_region && cairo_region_is_empty (stex->clip_region))
@@ -897,14 +1012,13 @@ meta_shaped_texture_paint_content (ClutterContent      *content,
    * Setting the texture quality to high without SGIS_generate_mipmap
    * support for TFP textures will result in fallbacks to XGetImage.
    */
-  paint_tex = select_texture_for_paint (stex, paint_context);
-  if (!paint_tex)
+  if (stex->texture == NULL)
     return;
 
   opacity = clutter_actor_get_paint_opacity (actor);
   clutter_actor_get_content_box (actor, &alloc);
 
-  do_paint_content (stex, root_node, paint_context, paint_tex, &alloc, opacity);
+  do_paint_content (stex, root_node, paint_context, &alloc, opacity);
 }
 
 static gboolean
@@ -942,10 +1056,10 @@ meta_shaped_texture_set_create_mipmaps (MetaShapedTexture *stex,
 
   if (create_mipmaps != stex->create_mipmaps)
     {
-      CoglTexture *base_texture;
       stex->create_mipmaps = create_mipmaps;
-      base_texture = create_mipmaps ? stex->texture : NULL;
-      meta_texture_tower_set_base_texture (stex->paint_tower, base_texture);
+
+      if (!stex->create_mipmaps)
+        free_mipmaps (stex);
     }
 }
 
@@ -1074,12 +1188,7 @@ meta_shaped_texture_update_area (MetaShapedTexture     *stex,
                                      clip);
     }
 
-  meta_texture_tower_update_area (stex->paint_tower,
-                                  x,
-                                  y,
-                                  width,
-                                  height);
-
+  stex->mipmap_texture_out_of_date = TRUE;
   stex->prev_invalidation = stex->last_invalidation;
   stex->last_invalidation = g_get_monotonic_time ();
 
@@ -1392,6 +1501,8 @@ meta_shaped_texture_get_image (MetaShapedTexture     *stex,
 {
   cairo_rectangle_int_t *image_clip = NULL;
   CoglTexture *texture;
+  CoglContext *cogl_context =
+    clutter_backend_get_cogl_context (clutter_get_default_backend ());
   cairo_surface_t *surface;
 
   g_return_val_if_fail (META_IS_SHAPED_TEXTURE (stex), NULL);
@@ -1432,11 +1543,12 @@ meta_shaped_texture_get_image (MetaShapedTexture     *stex,
     }
 
   if (image_clip)
-    texture = cogl_texture_new_from_sub_texture (texture,
-                                                 image_clip->x,
-                                                 image_clip->y,
-                                                 image_clip->width,
-                                                 image_clip->height);
+    texture = COGL_TEXTURE (cogl_sub_texture_new (cogl_context,
+                                                  texture,
+                                                  image_clip->x,
+                                                  image_clip->y,
+                                                  image_clip->width,
+                                                  image_clip->height));
 
   surface = cairo_image_surface_create (CAIRO_FORMAT_ARGB32,
                                         cogl_texture_get_width (texture),
diff --git a/src/compositor/meta-surface-actor-wayland.c b/src/compositor/meta-surface-actor-wayland.c
index 8c2a93da1..1dad50cd7 100644
--- a/src/compositor/meta-surface-actor-wayland.c
+++ b/src/compositor/meta-surface-actor-wayland.c
@@ -30,7 +30,6 @@
 
 #include "backends/meta-backend-private.h"
 #include "backends/meta-logical-monitor.h"
-#include "cogl/cogl-wayland-server.h"
 #include "compositor/meta-shaped-texture-private.h"
 #include "compositor/region-utils.h"
 #include "wayland/meta-wayland-buffer.h"
@@ -80,8 +79,7 @@ meta_surface_actor_wayland_try_acquire_scanout (MetaSurfaceActorWayland *self,
     return NULL;
 
   surface = meta_surface_actor_wayland_get_surface (self);
-  if (!surface)
-    return NULL;
+  g_return_val_if_fail (surface, NULL);
 
   scanout = meta_wayland_surface_try_acquire_scanout (surface, onscreen);
   if (!scanout)
diff --git a/src/compositor/meta-surface-actor-x11.c b/src/compositor/meta-surface-actor-x11.c
index 41ae2dffb..8063a67e6 100644
--- a/src/compositor/meta-surface-actor-x11.c
+++ b/src/compositor/meta-surface-actor-x11.c
@@ -189,7 +189,10 @@ meta_surface_actor_x11_is_visible (MetaSurfaceActorX11 *self)
 
 static void
 meta_surface_actor_x11_process_damage (MetaSurfaceActor *actor,
-                                       int x, int y, int width, int height)
+                                       int               x,
+                                       int               y,
+                                       int               width,
+                                       int               height)
 {
   MetaSurfaceActorX11 *self = META_SURFACE_ACTOR_X11 (actor);
 
diff --git a/src/compositor/meta-surface-actor.c b/src/compositor/meta-surface-actor.c
index c2bf6696a..fcd94b86d 100644
--- a/src/compositor/meta-surface-actor.c
+++ b/src/compositor/meta-surface-actor.c
@@ -331,7 +331,7 @@ meta_surface_actor_is_untransformed (MetaCullable *cullable)
   return meta_actor_vertices_are_untransformed (verts,
                                                 width * geometry_scale,
                                                 height * geometry_scale,
-                                                NULL, NULL);
+                                                NULL);
 }
 
 static void
diff --git a/src/compositor/meta-texture-tower.c b/src/compositor/meta-texture-tower.c
deleted file mode 100644
index 1fc4623e5..000000000
--- a/src/compositor/meta-texture-tower.c
+++ /dev/null
@@ -1,484 +0,0 @@
-/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
-/*
- * MetaTextureTower
- *
- * Mipmap emulation by creation of scaled down images
- *
- * Copyright (C) 2009 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "config.h"
-
-#include <math.h>
-#include <string.h>
-
-#include "compositor/meta-texture-tower.h"
-
-#ifndef M_LOG2E
-#define M_LOG2E 1.4426950408889634074
-#endif
-
-#define MAX_TEXTURE_LEVELS 12
-
-/* If the texture format in memory doesn't match this, then Mesa
- * will do the conversion, so things will still work, but it might
- * be slow depending on how efficient Mesa is. These should be the
- * native formats unless the display is 16bpp. If conversions
- * here are a bottleneck, investigate whether we are converting when
- * storing window data *into* the texture before adding extra code
- * to handle multiple texture formats.
- */
-#if G_BYTE_ORDER == G_LITTLE_ENDIAN
-#define TEXTURE_FORMAT COGL_PIXEL_FORMAT_BGRA_8888_PRE
-#else
-#define TEXTURE_FORMAT COGL_PIXEL_FORMAT_ARGB_8888_PRE
-#endif
-
-typedef struct
-{
-  guint16 x1;
-  guint16 y1;
-  guint16 x2;
-  guint16 y2;
-} Box;
-
-struct _MetaTextureTower
-{
-  int n_levels;
-  CoglTexture *textures[MAX_TEXTURE_LEVELS];
-  CoglOffscreen *fbos[MAX_TEXTURE_LEVELS];
-  Box invalid[MAX_TEXTURE_LEVELS];
-  CoglPipeline *pipeline_template;
-};
-
-/**
- * meta_texture_tower_new:
- *
- * Creates a new texture tower. The base texture has to be set with
- * meta_texture_tower_set_base_texture() before use.
- *
- * Return value: the new texture tower. Free with meta_texture_tower_free()
- */
-MetaTextureTower *
-meta_texture_tower_new (void)
-{
-  MetaTextureTower *tower;
-
-  tower = g_new0 (MetaTextureTower, 1);
-
-  return tower;
-}
-
-/**
- * meta_texture_tower_free:
- * @tower: a #MetaTextureTower
- *
- * Frees a texture tower created with meta_texture_tower_new().
- */
-void
-meta_texture_tower_free (MetaTextureTower *tower)
-{
-  g_return_if_fail (tower != NULL);
-
-  if (tower->pipeline_template != NULL)
-    cogl_object_unref (tower->pipeline_template);
-
-  meta_texture_tower_set_base_texture (tower, NULL);
-
-  g_free (tower);
-}
-
-/**
- * meta_texture_tower_set_base_texture:
- * @tower: a #MetaTextureTower
- * @texture: the new texture used as a base for scaled down versions
- *
- * Sets the base texture that is the scaled texture that the
- * scaled textures of the tower are derived from. The texture itself
- * will be used as level 0 of the tower and will be referenced until
- * unset or until the tower is freed.
- */
-void
-meta_texture_tower_set_base_texture (MetaTextureTower *tower,
-                                     CoglTexture      *texture)
-{
-  int i;
-
-  g_return_if_fail (tower != NULL);
-
-  if (texture == tower->textures[0])
-    return;
-
-  if (tower->textures[0] != NULL)
-    {
-      for (i = 1; i < tower->n_levels; i++)
-        {
-          cogl_clear_object (&tower->textures[i]);
-          g_clear_object (&tower->fbos[i]);
-        }
-
-      cogl_object_unref (tower->textures[0]);
-    }
-
-  tower->textures[0] = texture;
-
-  if (tower->textures[0] != NULL)
-    {
-      int width, height;
-
-      cogl_object_ref (tower->textures[0]);
-
-      width = cogl_texture_get_width (tower->textures[0]);
-      height = cogl_texture_get_height (tower->textures[0]);
-
-      tower->n_levels = 1 + MAX ((int)(M_LOG2E * log (width)), (int)(M_LOG2E * log (height)));
-      tower->n_levels = MIN(tower->n_levels, MAX_TEXTURE_LEVELS);
-
-      meta_texture_tower_update_area (tower, 0, 0, width, height);
-    }
-  else
-    {
-      tower->n_levels = 0;
-    }
-}
-
-/**
- * meta_texture_tower_update_area:
- * @tower: a #MetaTextureTower
- * @x: X coordinate of upper left of rectangle that changed
- * @y: Y coordinate of upper left of rectangle that changed
- * @width: width of rectangle that changed
- * @height: height rectangle that changed
- *
- * Mark a region of the base texture as having changed; the next
- * time a scaled down version of the base texture is retrieved,
- * the appropriate area of the scaled down texture will be updated.
- */
-void
-meta_texture_tower_update_area (MetaTextureTower *tower,
-                                int               x,
-                                int               y,
-                                int               width,
-                                int               height)
-{
-  int texture_width, texture_height;
-  Box invalid;
-  int i;
-
-  g_return_if_fail (tower != NULL);
-
-  if (tower->textures[0] == NULL)
-    return;
-
-  texture_width = cogl_texture_get_width (tower->textures[0]);
-  texture_height = cogl_texture_get_height (tower->textures[0]);
-
-  invalid.x1 = x;
-  invalid.y1 = y;
-  invalid.x2 = x + width;
-  invalid.y2 = y + height;
-
-  for (i = 1; i < tower->n_levels; i++)
-    {
-      texture_width = MAX (1, texture_width / 2);
-      texture_height = MAX (1, texture_height / 2);
-
-      invalid.x1 = invalid.x1 / 2;
-      invalid.y1 = invalid.y1 / 2;
-      invalid.x2 = MIN (texture_width, (invalid.x2 + 1) / 2);
-      invalid.y2 = MIN (texture_height, (invalid.y2 + 1) / 2);
-
-      if (tower->invalid[i].x1 == tower->invalid[i].x2 ||
-          tower->invalid[i].y1 == tower->invalid[i].y2)
-        {
-          tower->invalid[i] = invalid;
-        }
-      else
-        {
-          tower->invalid[i].x1 = MIN (tower->invalid[i].x1, invalid.x1);
-          tower->invalid[i].y1 = MIN (tower->invalid[i].y1, invalid.y1);
-          tower->invalid[i].x2 = MAX (tower->invalid[i].x2, invalid.x2);
-          tower->invalid[i].y2 = MAX (tower->invalid[i].y2, invalid.y2);
-        }
-    }
-}
-
-/* It generally looks worse if we scale up a window texture by even a
- * small amount than if we scale it down using bilinear filtering, so
- * we always pick the *larger* adjacent level. */
-#define LOD_BIAS (-0.49)
-
-/* This determines the appropriate level of detail to use when drawing the
- * texture, in a way that corresponds to what the GL specification does
- * when mip-mapping. This is probably fancier and slower than what we need,
- * but we do the computation only once each time we paint a window, and
- * its easier to just use the equations from the specification than to
- * come up with something simpler.
- *
- * If window is being painted at an angle from the viewer, then we have to
- * pick a point in the texture; we use the middle of the texture (which is
- * why the width/height are passed in.) This is not the normal case for
- * Meta.
- */
-static int
-get_paint_level (ClutterPaintContext *paint_context,
-                 int                  width,
-                 int                  height)
-{
-  CoglFramebuffer *framebuffer;
-  graphene_matrix_t projection, modelview, pm;
-  float xx, xy, xw;
-  float yx, yy, yw;
-  float wx, wy, ww;
-  float v[4];
-  double viewport_width, viewport_height;
-  double u0, v0;
-  double xc, yc, wc;
-  double dxdu_, dxdv_, dydu_, dydv_;
-  double det_, det_sq;
-  double rho_sq;
-  double lambda;
-
-  /* See
-   * http://www.opengl.org/registry/doc/glspec32.core.20090803.pdf
-   * Section 3.8.9, p. 1.6.2. Here we have
-   *
-   *  u(x,y) = x_o;
-   *  v(x,y) = y_o;
-   *
-   * Since we are mapping 1:1 from object coordinates into pixel
-   * texture coordinates, the clip coordinates are:
-   *
-   *  (x_c)                               (x_o)        (u)
-   *  (y_c) = (M_projection)(M_modelview) (y_o) = (PM) (v)
-   *  (z_c)                               (z_o)        (0)
-   *  (w_c)                               (w_o)        (1)
-   */
-
-  framebuffer = clutter_paint_context_get_framebuffer (paint_context);
-  cogl_framebuffer_get_projection_matrix (framebuffer, &projection);
-  cogl_framebuffer_get_modelview_matrix (framebuffer, &modelview);
-
-  graphene_matrix_multiply (&modelview, &projection, &pm);
-
-  xx = graphene_matrix_get_value (&pm, 0, 0);
-  xy = graphene_matrix_get_value (&pm, 0, 1);
-  xw = graphene_matrix_get_value (&pm, 0, 3);
-  yx = graphene_matrix_get_value (&pm, 1, 0);
-  yy = graphene_matrix_get_value (&pm, 1, 1);
-  yw = graphene_matrix_get_value (&pm, 1, 3);
-  wx = graphene_matrix_get_value (&pm, 3, 0);
-  wy = graphene_matrix_get_value (&pm, 3, 1);
-  ww = graphene_matrix_get_value (&pm, 3, 3);
-
-  cogl_framebuffer_get_viewport4fv (framebuffer, v);
-  viewport_width = v[2];
-  viewport_height = v[3];
-
-  u0 = width / 2.;
-  v0 = height / 2.;
-
-  xc = xx * u0 + yx * v0 + wx;
-  yc = xy * u0 + yy * v0 + wy;
-  wc = xw * u0 + yw * v0 + ww;
-
-  /* We'll simplify the equations below for a bit of micro-optimization.
-   * The commented out code is the unsimplified version.
-
-  // Partial derivates of window coordinates:
-  //
-  //  x_w = 0.5 * viewport_width * x_c / w_c + viewport_center_x
-  //  y_w = 0.5 * viewport_height * y_c / w_c + viewport_center_y
-  //
-  // with respect to u, v, using
-  // d(a/b)/dx = da/dx * (1/b) - a * db/dx / (b^2)
-
-  dxdu = 0.5 * viewport_width * (xx - xw * (xc/wc)) / wc;
-  dxdv = 0.5 * viewport_width * (yx - yw * (xc/wc)) / wc;
-  dydu = 0.5 * viewport_height * (xy - xw * (yc/wc)) / wc;
-  dydv = 0.5 * viewport_height * (yy - yw * (yc/wc)) / wc;
-
-  // Compute the inverse partials as the matrix inverse
-  det = dxdu * dydv - dxdv * dydu;
-
-  dudx =   dydv / det;
-  dudy = - dxdv / det;
-  dvdx = - dydu / det;
-  dvdy =   dvdu / det;
-
-  // Scale factor; maximum of the distance in texels for a change of 1 pixel
-  // in the X direction or 1 pixel in the Y direction
-  rho = MAX (sqrt (dudx * dudx + dvdx * dvdx), sqrt(dudy * dudy + dvdy * dvdy));
-
-  // Level of detail
-  lambda = log2 (rho) + LOD_BIAS;
-  */
-
-  /* dxdu * wc, etc */
-  dxdu_ = 0.5 * viewport_width * (xx - xw * (xc/wc));
-  dxdv_ = 0.5 * viewport_width * (yx - yw * (xc/wc));
-  dydu_ = 0.5 * viewport_height * (xy - xw * (yc/wc));
-  dydv_ = 0.5 * viewport_height * (yy - yw * (yc/wc));
-
-  /* det * wc^2 */
-  det_ = dxdu_ * dydv_ - dxdv_ * dydu_;
-  det_sq = det_ * det_;
-  if (det_sq == 0.0)
-    return -1;
-
-  /* (rho * det * wc)^2 */
-  rho_sq = MAX (dydv_ * dydv_ + dydu_ * dydu_, dxdv_ * dxdv_ + dxdu_ * dxdu_);
-  lambda = 0.5 * M_LOG2E * log (rho_sq * wc * wc / det_sq) + LOD_BIAS;
-
-#if 0
-  g_print ("%g %g %g\n", 0.5 * viewport_width * xx / ww, 0.5 * viewport_height * yy / ww, lambda);
-#endif
-
-  if (lambda <= 0.)
-    return 0;
-  else
-    return (int)(0.5 + lambda);
-}
-
-static void
-texture_tower_create_texture (MetaTextureTower *tower,
-                              int               level,
-                              int               width,
-                              int               height)
-{
-  tower->textures[level] = cogl_texture_new_with_size (width, height,
-                                                       COGL_TEXTURE_NO_AUTO_MIPMAP,
-                                                       TEXTURE_FORMAT);
-
-  tower->invalid[level].x1 = 0;
-  tower->invalid[level].y1 = 0;
-  tower->invalid[level].x2 = width;
-  tower->invalid[level].y2 = height;
-}
-
-static void
-texture_tower_revalidate (MetaTextureTower *tower,
-                          int               level)
-{
-  CoglTexture *source_texture = tower->textures[level - 1];
-  int source_texture_width = cogl_texture_get_width (source_texture);
-  int source_texture_height = cogl_texture_get_height (source_texture);
-  CoglTexture *dest_texture = tower->textures[level];
-  int dest_texture_width = cogl_texture_get_width (dest_texture);
-  int dest_texture_height = cogl_texture_get_height (dest_texture);
-  Box *invalid = &tower->invalid[level];
-  CoglFramebuffer *fb;
-  GError *catch_error = NULL;
-  CoglPipeline *pipeline;
-
-  if (tower->fbos[level] == NULL)
-    tower->fbos[level] = cogl_offscreen_new_with_texture (dest_texture);
-
-  fb = COGL_FRAMEBUFFER (tower->fbos[level]);
-
-  if (!cogl_framebuffer_allocate (fb, &catch_error))
-    {
-      g_error_free (catch_error);
-      return;
-    }
-
-  cogl_framebuffer_orthographic (fb, 0, 0, dest_texture_width, dest_texture_height, -1., 1.);
-
-  if (!tower->pipeline_template)
-    {
-      CoglContext *ctx =
-        clutter_backend_get_cogl_context (clutter_get_default_backend ());
-      tower->pipeline_template = cogl_pipeline_new (ctx);
-      cogl_pipeline_set_blend (tower->pipeline_template, "RGBA = ADD (SRC_COLOR, 0)", NULL);
-    }
-
-  pipeline = cogl_pipeline_copy (tower->pipeline_template);
-  cogl_pipeline_set_layer_texture (pipeline, 0, tower->textures[level - 1]);
-
-  cogl_framebuffer_draw_textured_rectangle (fb, pipeline,
-                                            invalid->x1, invalid->y1,
-                                            invalid->x2, invalid->y2,
-                                            (2. * invalid->x1) / source_texture_width,
-                                            (2. * invalid->y1) / source_texture_height,
-                                            (2. * invalid->x2) / source_texture_width,
-                                            (2. * invalid->y2) / source_texture_height);
-
-  cogl_object_unref (pipeline);
-
-  tower->invalid[level].x1 = tower->invalid[level].x2 = 0;
-  tower->invalid[level].y1 = tower->invalid[level].y2 = 0;
-}
-
-/**
- * meta_texture_tower_get_paint_texture:
- * @tower: a #MetaTextureTower
- * @paint_context: a #ClutterPaintContext
- *
- * Gets the texture from the tower that best matches the current
- * rendering scale. (On the assumption here the texture is going to
- * be rendered with vertex coordinates that correspond to its
- * size in pixels, so a 200x200 texture will be rendered on the
- * rectangle (0, 0, 200, 200).
- *
- * Return value: the COGL texture handle to use for painting, or
- *  %NULL if no base texture has yet been set.
- */
-CoglTexture *
-meta_texture_tower_get_paint_texture (MetaTextureTower    *tower,
-                                      ClutterPaintContext *paint_context)
-{
-  int texture_width, texture_height;
-  int level;
-
-  g_return_val_if_fail (tower != NULL, NULL);
-
-  if (tower->textures[0] == NULL)
-    return NULL;
-
-  texture_width = cogl_texture_get_width (tower->textures[0]);
-  texture_height = cogl_texture_get_height (tower->textures[0]);
-
-  level = get_paint_level (paint_context, texture_width, texture_height);
-  if (level < 0) /* singular paint matrix, scaled to nothing */
-    return NULL;
-  level = MIN (level, tower->n_levels - 1);
-
-  if (tower->textures[level] == NULL ||
-      (tower->invalid[level].x2 != tower->invalid[level].x1 &&
-       tower->invalid[level].y2 != tower->invalid[level].y1))
-    {
-      int i;
-
-      for (i = 1; i <= level; i++)
-       {
-         /* Use "floor" convention here to be consistent with the NPOT texture extension */
-         texture_width = MAX (1, texture_width / 2);
-         texture_height = MAX (1, texture_height / 2);
-
-         if (tower->textures[i] == NULL)
-           texture_tower_create_texture (tower, i, texture_width, texture_height);
-       }
-
-      for (i = 1; i <= level; i++)
-       {
-         if (tower->invalid[level].x2 != tower->invalid[level].x1 &&
-             tower->invalid[level].y2 != tower->invalid[level].y1)
-           texture_tower_revalidate (tower, i);
-       }
-   }
-
-  return tower->textures[level];
-}
diff --git a/src/compositor/meta-texture-tower.h b/src/compositor/meta-texture-tower.h
deleted file mode 100644
index 1f5b37146..000000000
--- a/src/compositor/meta-texture-tower.h
+++ /dev/null
@@ -1,68 +0,0 @@
-/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
-/*
- * MetaTextureTower
- *
- * Mipmap emulation by creation of scaled down images
- *
- * Copyright (C) 2009 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef __META_TEXTURE_TOWER_H__
-#define __META_TEXTURE_TOWER_H__
-
-#include "clutter/clutter.h"
-
-G_BEGIN_DECLS
-
-/**
- * SECTION:MetaTextureTower
- * @short_description: mipmap emulation by creation of scaled down images
- *
- * A #MetaTextureTower is used to get good looking scaled down images when
- * we can't use the GL drivers mipmap support. There are two separate reasons
- *
- *  - Some cards (including radeon cards <= r5xx) only support
- *    TEXTURE_RECTANGLE_ARB and not NPOT textures. Rectangular textures
- *    are defined not to support mipmapping.
- *  - Even when NPOT textures are available, the combination of NPOT
- *    textures, texture_from_pixmap, and mipmapping doesn't typically
- *    work, since the X server doesn't allocate pixmaps in the right
- *    layout for mipmapping.
- *
- * So, what we do is create the "mipmap" levels ourselves by successive
- * power-of-two scaledowns, and when rendering pick the single texture
- * that best matches the scale we are rendering at. (Since we aren't
- * typically using perspective transforms, we'll frequently have a single
- * scale for the entire texture.)
- */
-
-typedef struct _MetaTextureTower MetaTextureTower;
-
-MetaTextureTower *meta_texture_tower_new               (void);
-void              meta_texture_tower_free              (MetaTextureTower *tower);
-void              meta_texture_tower_set_base_texture  (MetaTextureTower *tower,
-                                                        CoglTexture      *texture);
-void              meta_texture_tower_update_area       (MetaTextureTower *tower,
-                                                        int               x,
-                                                        int               y,
-                                                        int               width,
-                                                        int               height);
-CoglTexture      *meta_texture_tower_get_paint_texture (MetaTextureTower    *tower,
-                                                        ClutterPaintContext *paint_context);
-
-G_END_DECLS
-
-#endif /* __META_TEXTURE_TOWER_H__ */
diff --git a/src/compositor/meta-window-actor-private.h b/src/compositor/meta-window-actor-private.h
index adae06547..035eebb08 100644
--- a/src/compositor/meta-window-actor-private.h
+++ b/src/compositor/meta-window-actor-private.h
@@ -85,6 +85,8 @@ void meta_window_actor_assign_surface_actor (MetaWindowActor  *self,
 
 META_EXPORT_TEST
 MetaWindowActor *meta_window_actor_from_window (MetaWindow *window);
+
+META_EXPORT_TEST
 MetaWindowActor *meta_window_actor_from_actor (ClutterActor *actor);
 
 void meta_window_actor_set_geometry_scale (MetaWindowActor *window_actor,
diff --git a/src/compositor/meta-window-group.c b/src/compositor/meta-window-group.c
index 16ff2db09..c6af609ae 100644
--- a/src/compositor/meta-window-group.c
+++ b/src/compositor/meta-window-group.c
@@ -92,6 +92,7 @@ meta_window_group_paint (ClutterActor        *actor,
     {
       CoglFramebuffer *fb;
       ClutterStageView *view;
+      MetaTransforms trans;
 
       fb = clutter_paint_context_get_framebuffer (paint_context);
       view = clutter_paint_context_get_stage_view (paint_context);
@@ -102,13 +103,15 @@ meta_window_group_paint (ClutterActor        *actor,
                                               screen_height,
                                               screen_width,
                                               screen_height,
-                                              &paint_x_origin,
-                                              &paint_y_origin) ||
+                                              &trans) ||
           !meta_cullable_is_untransformed (META_CULLABLE (actor)))
         {
           parent_actor_class->paint (actor, paint_context);
           return;
         }
+
+      paint_x_origin = trans.x_origin;
+      paint_y_origin = trans.y_origin;
     }
   else
     {
diff --git a/src/compositor/plugins/default.c b/src/compositor/plugins/default.c
index 3d09c4997..f762b3e6e 100644
--- a/src/compositor/plugins/default.c
+++ b/src/compositor/plugins/default.c
@@ -503,16 +503,11 @@ switch_workspace (MetaPlugin *plugin,
   MetaDisplay *display;
   MetaDefaultPluginPrivate *priv = META_DEFAULT_PLUGIN (plugin)->priv;
   GList        *l;
+  ClutterActor *workspace0  = clutter_actor_new ();
+  ClutterActor *workspace1  = clutter_actor_new ();
   ClutterActor *stage;
-  ClutterActor *workspace1, *workspace2;
   int           screen_width, screen_height;
 
-  if (from == to)
-    {
-      meta_plugin_switch_workspace_completed (plugin);
-      return;
-    }
-
   display = meta_plugin_get_display (plugin);
   stage = meta_get_stage_for_display (display);
 
@@ -520,70 +515,66 @@ switch_workspace (MetaPlugin *plugin,
                          &screen_width,
                          &screen_height);
 
-  workspace1 = clutter_actor_new ();
-  workspace2 = clutter_actor_new ();
-
   clutter_actor_set_pivot_point (workspace1, 1.0, 1.0);
-  clutter_actor_set_size (workspace1,
-                          screen_width,
-                          screen_height);
-  clutter_actor_set_size (workspace2,
-                          screen_width,
-                          screen_height);
+  clutter_actor_set_position (workspace1,
+                              screen_width,
+                              screen_height);
 
   clutter_actor_set_scale (workspace1, 0.0, 0.0);
 
   clutter_actor_add_child (stage, workspace1);
-  clutter_actor_add_child (stage, workspace2);
+  clutter_actor_add_child (stage, workspace0);
 
-  for (l = g_list_last (meta_get_window_actors (display)); l; l = l->prev)
+  if (from == to)
+    {
+      meta_plugin_switch_workspace_completed (plugin);
+      return;
+    }
+
+  l = g_list_last (meta_get_window_actors (display));
+
+  while (l)
     {
       MetaWindowActor *window_actor = l->data;
       ActorPrivate    *apriv	    = get_actor_private (window_actor);
       ClutterActor    *actor	    = CLUTTER_ACTOR (window_actor);
-      MetaWindow      *window;
+      MetaWorkspace   *workspace;
+      gint             win_workspace;
 
-      window = meta_window_actor_get_meta_window (window_actor);
+      workspace = meta_window_get_workspace (meta_window_actor_get_meta_window (window_actor));
+      win_workspace = meta_workspace_index (workspace);
 
-      if (meta_window_is_on_all_workspaces (window))
+      if (win_workspace == to || win_workspace == from)
+        {
+          ClutterActor *parent = win_workspace == to ? workspace1 : workspace0;
+          apriv->orig_parent = clutter_actor_get_parent (actor);
+
+          g_object_ref (actor);
+          clutter_actor_remove_child (clutter_actor_get_parent (actor), actor);
+          clutter_actor_add_child (parent, actor);
+          clutter_actor_show (actor);
+          clutter_actor_set_child_below_sibling (parent, actor, NULL);
+          g_object_unref (actor);
+        }
+      else if (win_workspace < 0)
         {
           /* Sticky window */
           apriv->orig_parent = NULL;
         }
       else
         {
-          MetaWorkspace *workspace;
-          gint           win_workspace;
-
-          workspace = meta_window_get_workspace (window);
-          win_workspace = meta_workspace_index (workspace);
-
-          if (win_workspace == to || win_workspace == from)
-            {
-              ClutterActor *parent = win_workspace == to ? workspace1
-                                                         : workspace2;
-              apriv->orig_parent = clutter_actor_get_parent (actor);
-
-              g_object_ref (actor);
-              clutter_actor_remove_child (clutter_actor_get_parent (actor),
-                                          actor);
-              clutter_actor_add_child (parent, actor);
-              clutter_actor_set_child_below_sibling (parent, actor, NULL);
-              g_object_unref (actor);
-            }
-          else
-            {
-              /* Window on some other desktop */
-              clutter_actor_hide (actor);
-              apriv->orig_parent = NULL;
-            }
+          /* Window on some other desktop */
+          clutter_actor_hide (actor);
+          apriv->orig_parent = NULL;
         }
+
+      l = l->prev;
     }
 
-  priv->desktop1 = workspace1;
-  priv->desktop2 = workspace2;
+  priv->desktop1 = workspace0;
+  priv->desktop2 = workspace1;
 
-  priv->tml_switch_workspace1 = actor_animate (workspace1, CLUTTER_EASE_IN_SINE,
+  priv->tml_switch_workspace1 = actor_animate (workspace0, CLUTTER_EASE_IN_SINE,
                                                ANIMATION_SWITCH,
                                                "scale-x", 1.0,
                                                "scale-y", 1.0,
@@ -593,7 +584,7 @@ switch_workspace (MetaPlugin *plugin,
                     G_CALLBACK (on_switch_workspace_effect_complete),
                     plugin);
 
-  priv->tml_switch_workspace2 = actor_animate (workspace2, CLUTTER_EASE_IN_SINE,
+  priv->tml_switch_workspace2 = actor_animate (workspace1, CLUTTER_EASE_IN_SINE,
                                                ANIMATION_SWITCH,
                                                "scale-x", 0.0,
                                                "scale-y", 0.0,
diff --git a/src/core/constraints.c b/src/core/constraints.c
index f5729354f..4b1d95338 100644
--- a/src/core/constraints.c
+++ b/src/core/constraints.c
@@ -350,7 +350,6 @@ setup_constraint_info (ConstraintInfo      *info,
     meta_backend_get_monitor_manager (backend);
   MetaLogicalMonitor *logical_monitor;
   MetaWorkspace *cur_workspace;
-  MetaPlacementRule *placement_rule;
 
   info->orig    = *orig;
   info->current = *new;
@@ -406,41 +405,9 @@ setup_constraint_info (ConstraintInfo      *info,
   if (!info->is_user_action)
     info->fixed_directions = FIXED_DIRECTION_NONE;
 
-  placement_rule = meta_window_get_placement_rule (window);
-  if (placement_rule)
-    {
-      MetaRectangle rect;
-      MetaRectangle parent_rect;
-
-      rect = placement_rule->anchor_rect;
-
-      parent_rect = placement_rule->parent_rect;
-      rect.x += parent_rect.x;
-      rect.y += parent_rect.y;
-      logical_monitor =
-        meta_monitor_manager_get_logical_monitor_from_rect (monitor_manager,
-                                                            &rect);
-      if (!logical_monitor)
-        {
-          logical_monitor =
-            meta_monitor_manager_get_logical_monitor_from_rect (monitor_manager,
-                                                                &parent_rect);
-        }
-    }
-  else
-    {
-      logical_monitor =
-        meta_monitor_manager_get_logical_monitor_from_rect (monitor_manager,
-                                                            &info->current);
-    }
-
-  if (!logical_monitor)
-    {
-      g_warning ("No sensible logical monitor could be used for constraining");
-      logical_monitor =
-        meta_monitor_manager_get_primary_logical_monitor (monitor_manager);
-    }
-
+  logical_monitor =
+    meta_monitor_manager_get_logical_monitor_from_rect (monitor_manager,
+                                                        &info->current);
   meta_window_get_work_area_for_logical_monitor (window,
                                                  logical_monitor,
                                                  &info->work_area_monitor);
@@ -560,23 +527,23 @@ place_window_if_needed(MetaWindow     *window,
         {
           meta_window_place (window, orig_rect.x, orig_rect.y,
                              &placed_rect.x, &placed_rect.y);
-
-          /* placing the window may have changed the monitor.  Find the
-           * new monitor and update the ConstraintInfo
-           */
-          logical_monitor =
-            meta_monitor_manager_get_logical_monitor_from_rect (monitor_manager,
-                                                                &placed_rect);
-          info->entire_monitor = logical_monitor->rect;
-          meta_window_get_work_area_for_logical_monitor (window,
-                                                         logical_monitor,
-                                                         &info->work_area_monitor);
-          cur_workspace = window->display->workspace_manager->active_workspace;
-          info->usable_monitor_region =
-            meta_workspace_get_onmonitor_region (cur_workspace, logical_monitor);
         }
       did_placement = TRUE;
 
+      /* placing the window may have changed the monitor.  Find the
+       * new monitor and update the ConstraintInfo
+       */
+      logical_monitor =
+        meta_monitor_manager_get_logical_monitor_from_rect (monitor_manager,
+                                                            &placed_rect);
+      info->entire_monitor = logical_monitor->rect;
+      meta_window_get_work_area_for_logical_monitor (window,
+                                                     logical_monitor,
+                                                     &info->work_area_monitor);
+      cur_workspace = window->display->workspace_manager->active_workspace;
+      info->usable_monitor_region =
+        meta_workspace_get_onmonitor_region (cur_workspace, logical_monitor);
+
       info->current.x = placed_rect.x;
       info->current.y = placed_rect.y;
 
diff --git a/src/core/delete.c b/src/core/delete.c
index 058764b08..81537dfe5 100644
--- a/src/core/delete.c
+++ b/src/core/delete.c
@@ -22,6 +22,8 @@
 
 #define _XOPEN_SOURCE /* for kill() */
 
+#define MAX_QUEUED_EVENTS 400
+
 #include "config.h"
 
 #include <errno.h>
@@ -39,6 +41,8 @@ close_dialog_response_cb (MetaCloseDialog         *dialog,
 {
   if (response == META_CLOSE_DIALOG_RESPONSE_FORCE_CLOSE)
     meta_window_kill (window);
+  else
+    meta_window_ensure_close_dialog_timeout (window);
 }
 
 static void
@@ -57,23 +61,22 @@ meta_window_ensure_close_dialog (MetaWindow *window)
 }
 
 void
-meta_window_set_alive (MetaWindow *window,
-                       gboolean    is_alive)
+meta_window_show_close_dialog (MetaWindow *window)
 {
-  if (is_alive && window->close_dialog)
-    {
-      meta_close_dialog_hide (window->close_dialog);
-    }
-  else if (!is_alive)
-    {
-      meta_window_ensure_close_dialog (window);
-      meta_close_dialog_show (window->close_dialog);
+  meta_window_ensure_close_dialog (window);
+  meta_close_dialog_show (window->close_dialog);
 
-      if (window->display &&
-          window->display->event_route == META_EVENT_ROUTE_NORMAL &&
-          window == window->display->focus_window)
-        meta_close_dialog_focus (window->close_dialog);
-    }
+  if (window->display &&
+      window->display->event_route == META_EVENT_ROUTE_NORMAL &&
+      window == window->display->focus_window)
+    meta_close_dialog_focus (window->close_dialog);
+}
+
+void
+meta_window_hide_close_dialog (MetaWindow *window)
+{
+  if (window->close_dialog)
+    meta_close_dialog_hide (window->close_dialog);
 }
 
 void
@@ -83,6 +86,21 @@ meta_window_check_alive (MetaWindow *window,
   meta_display_ping_window (window, timestamp);
 }
 
+void
+meta_window_check_alive_on_event (MetaWindow *window,
+                                  uint32_t    timestamp)
+{
+  if (!meta_window_can_ping (window))
+    return;
+
+  meta_display_ping_window (window, timestamp);
+
+  window->events_during_ping++;
+
+  if (window->events_during_ping > MAX_QUEUED_EVENTS)
+    meta_window_set_alive (window, FALSE);
+}
+
 void
 meta_window_delete (MetaWindow  *window,
                     guint32      timestamp)
diff --git a/src/core/display.c b/src/core/display.c
index d7852f34f..bb3918cf3 100644
--- a/src/core/display.c
+++ b/src/core/display.c
@@ -889,8 +889,12 @@ meta_display_new (MetaContext  *context,
 #ifdef HAVE_WAYLAND
   if (meta_is_wayland_compositor ())
     {
+      MetaWaylandCompositor *wayland_compositor =
+        meta_wayland_compositor_get_default ();
       MetaX11DisplayPolicy x11_display_policy;
 
+      meta_wayland_compositor_init_display (wayland_compositor, display);
+
       x11_display_policy = meta_context_get_x11_display_policy (context);
       if (x11_display_policy == META_X11_DISPLAY_POLICY_MANDATORY)
         {
@@ -1725,11 +1729,9 @@ static void
 manage_root_cursor_sprite_scale (MetaDisplay             *display,
                                  MetaCursorSpriteXcursor *sprite_xcursor)
 {
-  g_signal_connect_object (sprite_xcursor,
-                           "prepare-at",
-                           G_CALLBACK (root_cursor_prepare_at),
-                           display,
-                           0);
+  meta_cursor_sprite_set_prepare_func (META_CURSOR_SPRITE (sprite_xcursor),
+                                       (MetaCursorPrepareFunc) root_cursor_prepare_at,
+                                       display);
 }
 
 void
@@ -2142,6 +2144,7 @@ meta_display_ping_timeout (gpointer data)
   MetaDisplay *display = window->display;
 
   meta_window_set_alive (window, FALSE);
+  meta_window_show_close_dialog (window);
 
   ping_data->ping_timeout_id = 0;
 
@@ -2231,6 +2234,8 @@ meta_display_ping_window (MetaWindow *window,
               serial, window->desc);
 
   META_WINDOW_GET_CLASS (window)->ping (window, serial);
+
+  window->events_during_ping = 0;
 }
 
 /**
@@ -2384,6 +2389,31 @@ mru_cmp (gconstpointer a,
     return 0;
 }
 
+/**
+ * meta_display_list_all_windows:
+ * @display: a #MetaDisplay
+ *
+ * List all windows, including override-redirect ones. The windows are
+ * in no particular order.
+ *
+ * Returns: (transfer container) (element-type Meta.Window): List of windows
+ */
+GList *
+meta_display_list_all_windows (MetaDisplay *display)
+{
+  GList *all_windows = NULL;
+  g_autoptr (GSList) windows = NULL;
+  GSList *l;
+
+  windows = meta_display_list_windows (display,
+                                       META_LIST_INCLUDE_OVERRIDE_REDIRECT);
+
+  /* Yay for mixing GList and GSList in the API */
+  for (l = windows; l; l = l->next)
+    all_windows = g_list_prepend (all_windows, l->data);
+  return all_windows;
+}
+
 /**
  * meta_display_get_tab_list:
  * @display: a #MetaDisplay
diff --git a/src/core/edge-resistance.c b/src/core/edge-resistance.c
index 3e42936e7..eeaf055ca 100644
--- a/src/core/edge-resistance.c
+++ b/src/core/edge-resistance.c
@@ -38,29 +38,12 @@
   window->type   != META_WINDOW_MENU    &&     \
   window->type   != META_WINDOW_SPLASHSCREEN
 
-struct ResistanceDataForAnEdge
-{
-  gboolean     timeout_setup;
-  guint        timeout_id;
-  int          timeout_edge_pos;
-  gboolean     timeout_over;
-  GSourceFunc  timeout_func;
-  MetaWindow  *window;
-  int          keyboard_buildup;
-};
-typedef struct ResistanceDataForAnEdge ResistanceDataForAnEdge;
-
 struct MetaEdgeResistanceData
 {
   GArray *left_edges;
   GArray *right_edges;
   GArray *top_edges;
   GArray *bottom_edges;
-
-  ResistanceDataForAnEdge left_data;
-  ResistanceDataForAnEdge right_data;
-  ResistanceDataForAnEdge top_data;
-  ResistanceDataForAnEdge bottom_data;
 };
 
 static void compute_resistance_and_snapping_edges (MetaDisplay *display);
@@ -312,18 +295,6 @@ movement_towards_edge (MetaSide side, int increment)
     }
 }
 
-static gboolean
-edge_resistance_timeout (gpointer data)
-{
-  ResistanceDataForAnEdge *resistance_data = data;
-
-  resistance_data->timeout_over = TRUE;
-  resistance_data->timeout_id = 0;
-  (*resistance_data->timeout_func)(resistance_data->window);
-
-  return FALSE;
-}
-
 static int
 apply_edge_resistance (MetaWindow                *window,
                        int                        old_pos,
@@ -331,8 +302,6 @@ apply_edge_resistance (MetaWindow                *window,
                        const MetaRectangle       *old_rect,
                        const MetaRectangle       *new_rect,
                        GArray                    *edges,
-                       ResistanceDataForAnEdge   *resistance_data,
-                       GSourceFunc                timeout_func,
                        gboolean                   xdir,
                        gboolean                   include_windows,
                        gboolean                   keyboard_op)
@@ -348,25 +317,11 @@ apply_edge_resistance (MetaWindow                *window,
   const int PIXEL_DISTANCE_THRESHOLD_AWAYFROM_MONITOR  =  0;
   const int PIXEL_DISTANCE_THRESHOLD_TOWARDS_SCREEN    = 32;
   const int PIXEL_DISTANCE_THRESHOLD_AWAYFROM_SCREEN   =  0;
-  const int TIMEOUT_RESISTANCE_LENGTH_MS_WINDOW   =   0;
-  const int TIMEOUT_RESISTANCE_LENGTH_MS_MONITOR =   0;
-  const int TIMEOUT_RESISTANCE_LENGTH_MS_SCREEN   =   0;
 
   /* Quit if no movement was specified */
   if (old_pos == new_pos)
     return new_pos;
 
-  /* Remove the old timeout if it's no longer relevant */
-  if (resistance_data->timeout_setup &&
-      ((resistance_data->timeout_edge_pos > old_pos &&
-        resistance_data->timeout_edge_pos > new_pos)  ||
-       (resistance_data->timeout_edge_pos < old_pos &&
-        resistance_data->timeout_edge_pos < new_pos)))
-    {
-      resistance_data->timeout_setup = FALSE;
-      g_clear_handle_id (&resistance_data->timeout_id, g_source_remove);
-    }
-
   /* Get the range of indices in the edge array that we move past/to. */
   begin = find_index_of_edge_near_position (edges, old_pos,  increasing, xdir);
   end   = find_index_of_edge_near_position (edges, new_pos, !increasing, xdir);
@@ -410,48 +365,6 @@ apply_edge_resistance (MetaWindow                *window,
         {
           int threshold;
 
-          /* TIMEOUT RESISTANCE: If the edge is relevant and we're moving
-           * towards it, then we may want to have some kind of time delay
-           * before the user can move past this edge.
-           */
-          if (movement_towards_edge (edge->side_type, increment))
-            {
-              /* First, determine the length of time for the resistance */
-              int timeout_length_ms = 0;
-              switch (edge->edge_type)
-                {
-                case META_EDGE_WINDOW:
-                  if (include_windows)
-                    timeout_length_ms = TIMEOUT_RESISTANCE_LENGTH_MS_WINDOW;
-                  break;
-                case META_EDGE_MONITOR:
-                  timeout_length_ms = TIMEOUT_RESISTANCE_LENGTH_MS_MONITOR;
-                  break;
-                case META_EDGE_SCREEN:
-                  timeout_length_ms = TIMEOUT_RESISTANCE_LENGTH_MS_SCREEN;
-                  break;
-                }
-
-              if (!resistance_data->timeout_setup &&
-                  timeout_length_ms != 0)
-                {
-                  resistance_data->timeout_id =
-                    g_timeout_add (timeout_length_ms,
-                                   edge_resistance_timeout,
-                                   resistance_data);
-                  g_source_set_name_by_id (resistance_data->timeout_id,
-                                           "[mutter] edge_resistance_timeout");
-                  resistance_data->timeout_setup = TRUE;
-                  resistance_data->timeout_edge_pos = compare;
-                  resistance_data->timeout_over = FALSE;
-                  resistance_data->timeout_func = timeout_func;
-                  resistance_data->window = window;
-                }
-              if (!resistance_data->timeout_over &&
-                  timeout_length_ms != 0)
-                return compare;
-            }
-
           /* PIXEL DISTANCE MOUSE RESISTANCE: If the edge matters and the
            * user hasn't moved at least threshold pixels past this edge,
            * stop movement at this edge.  (Note that this is different from
@@ -545,7 +458,6 @@ apply_edge_resistance_to_each_side (MetaDisplay             *display,
                                     MetaWindow              *window,
                                     const MetaRectangle     *old_outer,
                                     MetaRectangle           *new_outer,
-                                    GSourceFunc              timeout_func,
                                     MetaEdgeResistanceFlags  flags,
                                     gboolean                 is_resize)
 {
@@ -659,8 +571,6 @@ apply_edge_resistance_to_each_side (MetaDisplay             *display,
                                               old_outer,
                                               new_outer,
                                               edge_data->left_edges,
-                                              &edge_data->left_data,
-                                              timeout_func,
                                               TRUE,
                                               include_windows,
                                               keyboard_op);
@@ -670,8 +580,6 @@ apply_edge_resistance_to_each_side (MetaDisplay             *display,
                                               old_outer,
                                               new_outer,
                                               edge_data->right_edges,
-                                              &edge_data->right_data,
-                                              timeout_func,
                                               TRUE,
                                               include_windows,
                                               keyboard_op);
@@ -690,8 +598,6 @@ apply_edge_resistance_to_each_side (MetaDisplay             *display,
                                               old_outer,
                                               new_outer,
                                               edge_data->top_edges,
-                                              &edge_data->top_data,
-                                              timeout_func,
                                               FALSE,
                                               include_windows,
                                               keyboard_op);
@@ -701,8 +607,6 @@ apply_edge_resistance_to_each_side (MetaDisplay             *display,
                                               old_outer,
                                               new_outer,
                                               edge_data->bottom_edges,
-                                              &edge_data->bottom_data,
-                                              timeout_func,
                                               FALSE,
                                               include_windows,
                                               keyboard_op);
@@ -792,16 +696,6 @@ meta_display_cleanup_edges (MetaDisplay *display)
   edge_data->top_edges = NULL;
   edge_data->bottom_edges = NULL;
 
-  /* Cleanup the timeouts */
-  if (edge_data->left_data.timeout_setup)
-    g_clear_handle_id (&edge_data->left_data.timeout_id, g_source_remove);
-  if (edge_data->right_data.timeout_setup)
-    g_clear_handle_id (&edge_data->right_data.timeout_id, g_source_remove);
-  if (edge_data->top_data.timeout_setup)
-    g_clear_handle_id (&edge_data->top_data.timeout_id, g_source_remove);
-  if (edge_data->bottom_data.timeout_setup)
-    g_clear_handle_id (&edge_data->bottom_data.timeout_id, g_source_remove);
-
   g_free (display->grab_edge_resistance_data);
   display->grab_edge_resistance_data = NULL;
 }
@@ -979,22 +873,6 @@ cache_edges (MetaDisplay *display,
                 stupid_sort_requiring_extra_pointer_dereference);
 }
 
-static void
-initialize_grab_edge_resistance_data (MetaDisplay *display)
-{
-  MetaEdgeResistanceData *edge_data = display->grab_edge_resistance_data;
-
-  edge_data->left_data.timeout_setup   = FALSE;
-  edge_data->right_data.timeout_setup  = FALSE;
-  edge_data->top_data.timeout_setup    = FALSE;
-  edge_data->bottom_data.timeout_setup = FALSE;
-
-  edge_data->left_data.keyboard_buildup   = 0;
-  edge_data->right_data.keyboard_buildup  = 0;
-  edge_data->top_data.keyboard_buildup    = 0;
-  edge_data->bottom_data.keyboard_buildup = 0;
-}
-
 static void
 compute_resistance_and_snapping_edges (MetaDisplay *display)
 {
@@ -1179,18 +1057,12 @@ compute_resistance_and_snapping_edges (MetaDisplay *display)
                workspace_manager->active_workspace->monitor_edges,
                workspace_manager->active_workspace->screen_edges);
   g_list_free (edges);
-
-  /*
-   * 6th: Initialize the resistance timeouts and buildups
-   */
-  initialize_grab_edge_resistance_data (display);
 }
 
 void
 meta_window_edge_resistance_for_move (MetaWindow              *window,
                                       int                     *new_x,
                                       int                     *new_y,
-                                      GSourceFunc              timeout_func,
                                       MetaEdgeResistanceFlags  flags)
 {
   MetaRectangle old_outer, proposed_outer, new_outer;
@@ -1214,7 +1086,6 @@ meta_window_edge_resistance_for_move (MetaWindow              *window,
                                           window,
                                           &old_outer,
                                           &new_outer,
-                                          timeout_func,
                                           flags,
                                           is_resize))
     {
@@ -1272,7 +1143,6 @@ meta_window_edge_resistance_for_resize (MetaWindow              *window,
                                         int                     *new_width,
                                         int                     *new_height,
                                         MetaGravity              gravity,
-                                        GSourceFunc              timeout_func,
                                         MetaEdgeResistanceFlags  flags)
 {
   MetaRectangle old_outer, new_outer;
@@ -1295,7 +1165,6 @@ meta_window_edge_resistance_for_resize (MetaWindow              *window,
                                           window,
                                           &old_outer,
                                           &new_outer,
-                                          timeout_func,
                                           flags,
                                           TRUE))
     {
diff --git a/src/core/edge-resistance.h b/src/core/edge-resistance.h
index 4eb6abdca..a1df48029 100644
--- a/src/core/edge-resistance.h
+++ b/src/core/edge-resistance.h
@@ -27,13 +27,11 @@
 void meta_window_edge_resistance_for_move   (MetaWindow              *window,
                                              int                     *new_x,
                                              int                     *new_y,
-                                             GSourceFunc              timeout_func,
                                              MetaEdgeResistanceFlags  flags);
 void meta_window_edge_resistance_for_resize (MetaWindow              *window,
                                              int                     *new_width,
                                              int                     *new_height,
                                              MetaGravity              gravity,
-                                             GSourceFunc              timeout_func,
                                              MetaEdgeResistanceFlags  flags);
 
 #endif /* META_EDGE_RESISTANCE_H */
diff --git a/src/core/events.c b/src/core/events.c
index 8afc720ef..a8f854a02 100644
--- a/src/core/events.c
+++ b/src/core/events.c
@@ -43,6 +43,7 @@
 
 #define IS_GESTURE_EVENT(e) ((e)->type == CLUTTER_TOUCHPAD_SWIPE || \
                              (e)->type == CLUTTER_TOUCHPAD_PINCH || \
+                             (e)->type == CLUTTER_TOUCHPAD_HOLD || \
                              (e)->type == CLUTTER_TOUCH_BEGIN || \
                              (e)->type == CLUTTER_TOUCH_UPDATE || \
                              (e)->type == CLUTTER_TOUCH_END || \
@@ -201,7 +202,7 @@ meta_display_handle_event (MetaDisplay        *display,
                            const ClutterEvent *event)
 {
   MetaBackend *backend = meta_get_backend ();
-  MetaWindow *window;
+  MetaWindow *window = NULL;
   gboolean bypass_clutter = FALSE;
   G_GNUC_UNUSED gboolean bypass_wayland = FALSE;
   MetaGestureTracker *gesture_tracker;
@@ -419,10 +420,15 @@ meta_display_handle_event (MetaDisplay        *display,
        * See: https://gitlab.gnome.org/GNOME/mutter/issues/88
        */
       if (meta_window_handle_ui_frame_event (window, event))
-        bypass_wayland = (event->type == CLUTTER_BUTTON_PRESS ||
-                          event->type == CLUTTER_TOUCH_BEGIN);
+        {
+          bypass_wayland = (event->type == CLUTTER_BUTTON_PRESS ||
+                            event->type == CLUTTER_TOUCH_BEGIN);
+        }
       else
-        meta_window_handle_ungrabbed_event (window, event);
+        {
+          bypass_wayland = meta_window_has_modals (window);
+          meta_window_handle_ungrabbed_event (window, event);
+        }
 
       /* This might start a grab op. If it does, then filter out the
        * event, and if it doesn't, replay the event to release our
@@ -474,6 +480,10 @@ meta_display_handle_event (MetaDisplay        *display,
 #ifdef HAVE_WAYLAND
   if (compositor && !bypass_wayland)
     {
+      if (window && event->type == CLUTTER_MOTION &&
+          event->any.time != CLUTTER_CURRENT_TIME)
+        meta_window_check_alive_on_event (window, event->any.time);
+
       if (meta_wayland_compositor_handle_event (compositor, event))
         bypass_clutter = TRUE;
     }
diff --git a/src/core/keybindings.c b/src/core/keybindings.c
index b1ab7bfce..975e68897 100644
--- a/src/core/keybindings.c
+++ b/src/core/keybindings.c
@@ -2510,7 +2510,6 @@ process_keyboard_move_grab (MetaDisplay     *display,
       meta_window_edge_resistance_for_move (window,
                                             &x,
                                             &y,
-                                            NULL,
                                             flags);
 
       meta_window_move_frame (window, TRUE, x, y);
@@ -2864,7 +2863,6 @@ process_keyboard_resize_grab (MetaDisplay     *display,
                                               &width,
                                               &height,
                                               gravity,
-                                              NULL,
                                               flags);
 
       meta_window_resize_frame_with_gravity (window,
diff --git a/src/core/meta-gesture-tracker.c b/src/core/meta-gesture-tracker.c
index 2badf8b82..33ee834e3 100644
--- a/src/core/meta-gesture-tracker.c
+++ b/src/core/meta-gesture-tracker.c
@@ -227,6 +227,7 @@ static gboolean
 state_is_applicable (MetaSequenceState prev_state,
                      MetaSequenceState state)
 {
+  /* PENDING_END state is final */
   if (prev_state == META_SEQUENCE_PENDING_END)
     return FALSE;
 
@@ -234,10 +235,6 @@ state_is_applicable (MetaSequenceState prev_state,
   if (state == META_SEQUENCE_NONE)
     return FALSE;
 
-  /* PENDING_END state is final */
-  if (prev_state == META_SEQUENCE_PENDING_END)
-    return FALSE;
-
   /* Sequences must be accepted/denied before PENDING_END */
   if (prev_state == META_SEQUENCE_NONE &&
       state == META_SEQUENCE_PENDING_END)
diff --git a/src/core/meta-workspace-manager.c b/src/core/meta-workspace-manager.c
index 61fbc0090..0279ab23d 100644
--- a/src/core/meta-workspace-manager.c
+++ b/src/core/meta-workspace-manager.c
@@ -881,24 +881,32 @@ meta_workspace_manager_calc_workspace_layout (MetaWorkspaceManager *workspace_ma
 #ifdef WITH_VERBOSE_MODE
   if (meta_is_verbose ())
     {
+      g_autoptr (GString) str = NULL;
+
+      str = g_string_new ("Workspace layout:");
       r = 0;
       while (r < layout->rows)
         {
-          meta_verbose (" ");
-          meta_push_no_msg_prefix ();
+          g_string_append (str, "\n");
           c = 0;
           while (c < layout->cols)
             {
               if (r == layout->current_row &&
                   c == layout->current_col)
-                meta_verbose ("*%2d ", layout->grid[r*layout->cols+c]);
+                {
+                  g_string_append_printf (str, "*%2d ",
+                                          layout->grid[r * layout->cols + c]);
+                }
               else
-                meta_verbose ("%3d ", layout->grid[r*layout->cols+c]);
+                {
+                  g_string_append_printf (str, "%3d ",
+                                          layout->grid[r * layout->cols + c]);
+                }
               ++c;
             }
-          meta_pop_no_msg_prefix ();
           ++r;
         }
+      meta_verbose ("%s", str->str);
     }
 #endif /* WITH_VERBOSE_MODE */
 }
diff --git a/src/core/mutter.c b/src/core/mutter.c
index 01041e734..51b9951b1 100644
--- a/src/core/mutter.c
+++ b/src/core/mutter.c
@@ -39,7 +39,33 @@ print_version (const gchar    *option_name,
   exit (0);
 }
 
+static void
+command_exited_cb (GPid     command_pid,
+                   int      status,
+                   gpointer user_data)
+{
+  MetaContext *context = user_data;
+
+  g_spawn_close_pid (command_pid);
+
+  if (status)
+    {
+      GError *error;
+
+      error = g_error_new (G_IO_ERROR, G_IO_ERROR_FAILED,
+                           "The command exited with a nonzero status: %d\n",
+                           status);
+
+      meta_context_terminate_with_error (context, error);
+    }
+  else
+    {
+      meta_context_terminate (context);
+    }
+}
+
 static const char *plugin = "libdefault";
+static char **argv_ignored = NULL;
 
 GOptionEntry mutter_options[] = {
   {
@@ -54,6 +80,12 @@ GOptionEntry mutter_options[] = {
     N_("Mutter plugin to use"),
     "PLUGIN",
   },
+  {
+    G_OPTION_REMAINING,
+    .arg = G_OPTION_ARG_STRING_ARRAY,
+    &argv_ignored,
+    .arg_description = "[[--] COMMAND [ARGUMENT…]]"
+  },
   { NULL }
 };
 
@@ -99,7 +131,7 @@ main (int argc, char **argv)
   meta_context_add_option_entries (context, mutter_options, GETTEXT_PACKAGE);
   if (!meta_context_configure (context, &argc, &argv, &error))
     {
-      g_printerr ("Failed to configure: %s", error->message);
+      g_printerr ("Failed to configure: %s\n", error->message);
       return EXIT_FAILURE;
     }
 
@@ -109,21 +141,38 @@ main (int argc, char **argv)
 
   if (!meta_context_setup (context, &error))
     {
-      g_printerr ("Failed to setup: %s", error->message);
+      g_printerr ("Failed to setup: %s\n", error->message);
       return EXIT_FAILURE;
     }
 
   if (!meta_context_start (context, &error))
     {
-      g_printerr ("Failed to start: %s", error->message);
+      g_printerr ("Failed to start: %s\n", error->message);
       return EXIT_FAILURE;
     }
 
   meta_context_notify_ready (context);
+  if (argv_ignored)
+    {
+      GPid command_pid;
+      g_auto (GStrv) command_argv = NULL;
+
+      command_argv = g_steal_pointer (&argv_ignored);
+
+      if (!g_spawn_async (NULL, command_argv, NULL,
+                          G_SPAWN_DO_NOT_REAP_CHILD | G_SPAWN_SEARCH_PATH,
+                          NULL, NULL, &command_pid, &error))
+        {
+          g_printerr ("Failed to run the command: %s\n", error->message);
+          return EXIT_FAILURE;
+        }
+
+      g_child_watch_add (command_pid, command_exited_cb, context);
+    }
 
   if (!meta_context_run_main_loop (context, &error))
     {
-      g_printerr ("Mutter terminated with a failure: %s", error->message);
+      g_printerr ("Mutter terminated with a failure: %s\n", error->message);
       return EXIT_FAILURE;
     }
 
diff --git a/src/core/stack-tracker.c b/src/core/stack-tracker.c
index fbfef6465..9c217a08c 100644
--- a/src/core/stack-tracker.c
+++ b/src/core/stack-tracker.c
@@ -231,13 +231,11 @@ stack_dump (MetaStackTracker *tracker,
 {
   guint i;
 
-  meta_push_no_msg_prefix ();
   for (i = 0; i < stack->len; i++)
     {
       guint64 window = g_array_index (stack, guint64, i);
       meta_topic (META_DEBUG_STACK, "    %s", get_window_desc (tracker, window));
     }
-  meta_pop_no_msg_prefix ();
 }
 #endif /* WITH_VERBOSE_MODE */
 
@@ -248,7 +246,6 @@ meta_stack_tracker_dump (MetaStackTracker *tracker)
   GList *l;
 
   meta_topic (META_DEBUG_STACK, "MetaStackTracker state");
-  meta_push_no_msg_prefix ();
   meta_topic (META_DEBUG_STACK, "  xserver_serial: %ld", tracker->xserver_serial);
   meta_topic (META_DEBUG_STACK, "  verified_stack: ");
   stack_dump (tracker, tracker->verified_stack);
@@ -264,7 +261,6 @@ meta_stack_tracker_dump (MetaStackTracker *tracker)
       meta_topic (META_DEBUG_STACK, "  predicted_stack: ");
       stack_dump (tracker, tracker->predicted_stack);
     }
-  meta_pop_no_msg_prefix ();
 #endif /* WITH_VERBOSE_MODE */
 }
 
diff --git a/src/core/stack.c b/src/core/stack.c
index 50e9e7e04..1af59f5be 100644
--- a/src/core/stack.c
+++ b/src/core/stack.c
@@ -86,7 +86,6 @@ on_stack_changed (MetaStack *stack)
   hidden_stack_ids = g_array_new (FALSE, FALSE, sizeof (uint64_t));
 
   meta_topic (META_DEBUG_STACK, "Bottom to top: ");
-  meta_push_no_msg_prefix ();
 
   sorted = meta_stack_list_windows (stack, NULL);
 
@@ -124,8 +123,6 @@ on_stack_changed (MetaStack *stack)
       g_array_append_val (all_root_children_stacked, stack_id);
     }
 
-  meta_pop_no_msg_prefix ();
-
   if (display->x11_display)
     {
       uint64_t guard_window_id;
diff --git a/src/core/util-private.h b/src/core/util-private.h
index 01b663966..ff9d7ce42 100644
--- a/src/core/util-private.h
+++ b/src/core/util-private.h
@@ -54,8 +54,4 @@ void meta_init_debug_utils (void);
    (ycoord) >= (rect).y &&                   \
    (ycoord) <  ((rect).y + (rect).height))
 
-void     meta_get_clutter_debug_flags (ClutterDebugFlag     *debug_flags,
-                                       ClutterDrawDebugFlag *draw_flags,
-                                       ClutterPickDebugFlag *pick_flags);
-
 #endif
diff --git a/src/core/util.c b/src/core/util.c
index 74a884c80..bfac2c071 100644
--- a/src/core/util.c
+++ b/src/core/util.c
@@ -71,17 +71,10 @@ static const GDebugKey meta_debug_keys[] = {
   { "screen-cast", META_DEBUG_SCREEN_CAST },
   { "remote-desktop", META_DEBUG_REMOTE_DESKTOP },
   { "backend", META_DEBUG_BACKEND },
+  { "render", META_DEBUG_RENDER },
 };
 
-#ifdef WITH_VERBOSE_MODE
-static void
-meta_topic_real_valist (MetaDebugTopic topic,
-                        const char    *format,
-                        va_list        args) G_GNUC_PRINTF(2, 0);
-#endif
-
 static gint verbose_topics = 0;
-static int no_prefix = 0;
 static gboolean is_wayland_compositor = FALSE;
 static int debug_paint_flags = 0;
 
@@ -264,18 +257,8 @@ utf8_fputs (const char *str,
 }
 
 #ifdef WITH_VERBOSE_MODE
-void
-meta_verbose_real (const char *format, ...)
-{
-  va_list args;
-
-  va_start (args, format);
-  meta_topic_real_valist (META_DEBUG_VERBOSE, format, args);
-  va_end (args);
-}
-
-static const char*
-topic_name (MetaDebugTopic topic)
+const char *
+meta_topic_to_string (MetaDebugTopic topic)
 {
   switch (topic)
     {
@@ -319,6 +302,8 @@ topic_name (MetaDebugTopic topic)
       return "DBUS";
     case META_DEBUG_INPUT:
       return "INPUT";
+    case META_DEBUG_WAYLAND:
+      return "WAYLAND";
     case META_DEBUG_KMS:
       return "KMS";
     case META_DEBUG_SCREEN_CAST:
@@ -327,17 +312,15 @@ topic_name (MetaDebugTopic topic)
       return "REMOTE_DESKTOP";
     case META_DEBUG_BACKEND:
       return "BACKEND";
+    case META_DEBUG_RENDER:
+      return "RENDER";
     case META_DEBUG_VERBOSE:
       return "VERBOSE";
-    case META_DEBUG_WAYLAND:
-      return "WAYLAND";
     }
 
   return "WM";
 }
 
-static int sync_count = 0;
-
 gboolean
 meta_is_topic_enabled (MetaDebugTopic topic)
 {
@@ -349,52 +332,6 @@ meta_is_topic_enabled (MetaDebugTopic topic)
 
   return !!(verbose_topics & topic);
 }
-
-static void
-meta_topic_real_valist (MetaDebugTopic topic,
-                        const char    *format,
-                        va_list        args)
-{
-  gchar *str;
-  FILE *out;
-
-  g_return_if_fail (format != NULL);
-
-  if (!meta_is_topic_enabled (topic))
-    return;
-
-  str = g_strdup_vprintf (format, args);
-
-  out = logfile ? logfile : stderr;
-
-  if (no_prefix == 0)
-    fprintf (out, "%s: ", topic_name (topic));
-
-  if (topic == META_DEBUG_SYNC)
-    {
-      ++sync_count;
-      fprintf (out, "%d: ", sync_count);
-    }
-
-  utf8_fputs (str, out);
-  utf8_fputs ("\n", out);
-
-  fflush (out);
-
-  g_free (str);
-}
-
-void
-meta_topic_real (MetaDebugTopic topic,
-                 const char *format,
-                 ...)
-{
-  va_list args;
-
-  va_start (args, format);
-  meta_topic_real_valist (topic, format, args);
-  va_end (args);
-}
 #endif /* WITH_VERBOSE_MODE */
 
 void
@@ -416,8 +353,7 @@ meta_bug (const char *format, ...)
   out = stderr;
 #endif
 
-  if (no_prefix == 0)
-    utf8_fputs ("Bug in window manager: ", out);
+  utf8_fputs ("Bug in window manager: ", out);
   utf8_fputs (str, out);
   utf8_fputs ("\n", out);
 
@@ -448,8 +384,7 @@ meta_warning (const char *format, ...)
   out = stderr;
 #endif
 
-  if (no_prefix == 0)
-    utf8_fputs ("Window manager warning: ", out);
+  utf8_fputs ("Window manager warning: ", out);
   utf8_fputs (str, out);
   utf8_fputs ("\n", out);
 
@@ -479,8 +414,7 @@ meta_fatal (const char *format, ...)
   out = stderr;
 #endif
 
-  if (no_prefix == 0)
-    utf8_fputs ("Window manager error: ", out);
+  utf8_fputs ("Window manager error: ", out);
   utf8_fputs (str, out);
   utf8_fputs ("\n", out);
 
@@ -491,20 +425,6 @@ meta_fatal (const char *format, ...)
   meta_exit (META_EXIT_ERROR);
 }
 
-void
-meta_push_no_msg_prefix (void)
-{
-  ++no_prefix;
-}
-
-void
-meta_pop_no_msg_prefix (void)
-{
-  g_return_if_fail (no_prefix > 0);
-
-  --no_prefix;
-}
-
 void
 meta_exit (MetaExitCode code)
 {
@@ -769,6 +689,12 @@ meta_remove_clutter_debug_flags (ClutterDebugFlag     debug_flags,
   clutter_remove_debug_flags (debug_flags, draw_flags, pick_flags);
 }
 
+/**
+ * meta_get_clutter_debug_flags:
+ * @debug_flags: (out) (optional): return location for debug flags
+ * @draw_flags: (out) (optional): return location for draw debug flags
+ * @pick_flags: (out) (optional): return location for pick debug flags
+ */
 void
 meta_get_clutter_debug_flags (ClutterDebugFlag     *debug_flags,
                               ClutterDrawDebugFlag *draw_flags,
diff --git a/src/core/window-private.h b/src/core/window-private.h
index 3bd75fe47..8305897a4 100644
--- a/src/core/window-private.h
+++ b/src/core/window-private.h
@@ -79,6 +79,7 @@ typedef enum
   META_MOVE_RESIZE_WAYLAND_STATE_CHANGED = 1 << 9,
   META_MOVE_RESIZE_FORCE_UPDATE_MONITOR = 1 << 10,
   META_MOVE_RESIZE_PLACEMENT_CHANGED = 1 << 11,
+  META_MOVE_RESIZE_WAYLAND_CLIENT_RESIZE = 1 << 12,
 } MetaMoveResizeFlags;
 
 typedef enum
@@ -436,6 +437,9 @@ struct _MetaWindow
   /* whether focus should be restored on map */
   guint restore_focus_on_map : 1;
 
+  /* Whether the window is alive */
+  guint is_alive : 1;
+
   /* if non-NULL, the bounds of the window frame */
   cairo_region_t *frame_bounds;
 
@@ -516,8 +520,8 @@ struct _MetaWindow
    * For X11 windows, this matches XGetGeometry of the toplevel.
    *
    * For Wayland windows, the position matches the position of the
-   * surface associated with shell surface (wl_shell_surface, xdg_surface
-   * etc). The size matches the size surface size as displayed in the stage.
+   * surface associated with shell surface (xdg_surface, etc.)
+   * The size matches the size surface size as displayed in the stage.
    */
   MetaRectangle buffer_rect;
 
@@ -563,11 +567,14 @@ struct _MetaWindow
   } placement;
 
   guint unmanage_idle_id;
+  guint close_dialog_timeout_id;
 
   pid_t client_pid;
 
   gboolean has_valid_cgroup;
   GFile *cgroup_path;
+
+  unsigned int events_during_ping;
 };
 
 struct _MetaWindowClass
@@ -823,6 +830,7 @@ void meta_window_set_gtk_dbus_properties  (MetaWindow *window,
                                            const char *window_object_path);
 
 gboolean meta_window_has_transient_type   (MetaWindow *window);
+gboolean meta_window_has_modals           (MetaWindow *window);
 
 void meta_window_set_transient_for        (MetaWindow *window,
                                            MetaWindow *parent);
@@ -876,6 +884,11 @@ void meta_window_grab_op_began (MetaWindow *window, MetaGrabOp op);
 void meta_window_grab_op_ended (MetaWindow *window, MetaGrabOp op);
 
 void meta_window_set_alive (MetaWindow *window, gboolean is_alive);
+gboolean meta_window_get_alive (MetaWindow *window);
+
+void meta_window_show_close_dialog (MetaWindow *window);
+void meta_window_hide_close_dialog (MetaWindow *window);
+void meta_window_ensure_close_dialog_timeout (MetaWindow *window);
 
 gboolean meta_window_has_pointer (MetaWindow *window);
 
@@ -897,4 +910,8 @@ gboolean meta_window_is_focus_async (MetaWindow *window);
 GFile *meta_window_get_unit_cgroup (MetaWindow *window);
 gboolean meta_window_unit_cgroup_equal (MetaWindow *window1,
                                         MetaWindow *window2);
+
+void meta_window_check_alive_on_event (MetaWindow *window,
+                                       uint32_t    timestamp);
+
 #endif
diff --git a/src/core/window.c b/src/core/window.c
index 662395161..518cebb34 100644
--- a/src/core/window.c
+++ b/src/core/window.c
@@ -139,13 +139,11 @@ static void     update_move           (MetaWindow              *window,
                                        MetaEdgeResistanceFlags  flags,
                                        int                      x,
                                        int                      y);
-static gboolean update_move_timeout   (gpointer data);
 static void     update_resize         (MetaWindow              *window,
                                        MetaEdgeResistanceFlags  flags,
                                        int                      x,
                                        int                      y,
                                        gboolean                 force);
-static gboolean update_resize_timeout (gpointer data);
 static gboolean should_be_on_all_workspaces (MetaWindow *window);
 
 static void meta_window_flush_calc_showing   (MetaWindow *window);
@@ -216,6 +214,7 @@ enum
   PROP_GTK_APP_MENU_OBJECT_PATH,
   PROP_GTK_MENUBAR_OBJECT_PATH,
   PROP_ON_ALL_WORKSPACES,
+  PROP_IS_ALIVE,
 
   PROP_LAST,
 };
@@ -635,6 +634,13 @@ meta_window_class_init (MetaWindowClass *klass)
                           FALSE,
                           G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);
 
+  obj_props[PROP_IS_ALIVE] =
+    g_param_spec_boolean ("is-alive",
+                          "Is alive",
+                          "Whether the window responds to pings",
+                          TRUE,
+                          G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);
+
   g_object_class_install_properties (object_class, PROP_LAST, obj_props);
 
   window_signals[WORKSPACE_CHANGED] =
@@ -731,6 +737,7 @@ meta_window_init (MetaWindow *self)
 {
   self->stamp = next_window_stamp++;
   meta_prefs_add_listener (prefs_changed_callback, self);
+  self->is_alive = TRUE;
 }
 
 static gboolean
@@ -1054,7 +1061,6 @@ _meta_window_shared_new (MetaDisplay         *display,
 
   /* And this is our unmaximized size */
   window->saved_rect = window->rect;
-  window->saved_rect_fullscreen = window->rect;
   window->unconstrained_rect = window->rect;
 
   window->depth = attrs->depth;
@@ -1460,6 +1466,7 @@ meta_window_unmanage (MetaWindow  *window,
   window->unmanaging = TRUE;
 
   g_clear_handle_id (&window->unmanage_idle_id, g_source_remove);
+  g_clear_handle_id (&window->close_dialog_timeout_id, g_source_remove);
 
   g_signal_emit (window, window_signals[UNMANAGING], 0);
 
@@ -4165,8 +4172,13 @@ meta_window_move_resize_internal (MetaWindow          *window,
       g_signal_emit (window, window_signals[SIZE_CHANGED], 0);
     }
 
-  if (moved_or_resized || did_placement)
-    window->unconstrained_rect = unconstrained_rect;
+  /* Only update the stored size when requested but not when a
+   * (potentially outdated) request completes */
+  if (!(flags & META_MOVE_RESIZE_WAYLAND_FINISH_MOVE_RESIZE) || 
+      flags & META_MOVE_RESIZE_WAYLAND_CLIENT_RESIZE)
+    {
+      window->unconstrained_rect = unconstrained_rect;
+    }
 
   if ((moved_or_resized ||
        did_placement ||
@@ -4211,6 +4223,9 @@ meta_window_move_resize_internal (MetaWindow          *window,
 
   meta_stack_update_window_tile_matches (window->display->stack,
                                          workspace_manager->active_workspace);
+
+  if (flags & META_MOVE_RESIZE_WAYLAND_CLIENT_RESIZE)
+    meta_window_queue (window, META_QUEUE_MOVE_RESIZE);
 }
 
 /**
@@ -6105,19 +6120,6 @@ check_moveresize_frequency (MetaWindow *window,
   return TRUE;
 }
 
-static gboolean
-update_move_timeout (gpointer data)
-{
-  MetaWindow *window = data;
-
-  update_move (window,
-               window->display->grab_last_edge_resistance_flags,
-               window->display->grab_latest_motion_x,
-               window->display->grab_latest_motion_y);
-
-  return FALSE;
-}
-
 static void
 update_move_maybe_tile (MetaWindow *window,
                         int         shake_threshold,
@@ -6352,7 +6354,6 @@ update_move (MetaWindow              *window,
   meta_window_edge_resistance_for_move (window,
                                         &new_x,
                                         &new_y,
-                                        update_move_timeout,
                                         flags);
 
   meta_window_move_frame (window, TRUE, new_x, new_y);
@@ -6491,7 +6492,6 @@ update_resize (MetaWindow              *window,
                                           &new_rect.width,
                                           &new_rect.height,
                                           gravity,
-                                          update_resize_timeout,
                                           flags);
 
   meta_window_resize_frame_with_gravity (window, TRUE,
@@ -7973,7 +7973,7 @@ meta_window_get_frame_bounds (MetaWindow *window)
  * meta_window_is_attached_dialog:
  * @window: a #MetaWindow
  *
- * Tests if @window is should be attached to its parent window.
+ * Tests if @window should be attached to its parent window.
  * (If the "attach_modal_dialogs" option is not enabled, this will
  * always return %FALSE.)
  *
@@ -7985,6 +7985,71 @@ meta_window_is_attached_dialog (MetaWindow *window)
   return window->attached;
 }
 
+static gboolean
+has_attached_foreach_func (MetaWindow *window,
+                           void       *data)
+{
+  gboolean *is_attached = data;
+
+  *is_attached = window->attached && !window->unmanaging;
+
+  if (*is_attached)
+    return FALSE;
+
+  return TRUE;
+}
+
+
+/**
+ * meta_window_has_attached_dialogs:
+ * @window: a #MetaWindow
+ *
+ * Tests if @window has any transients attached to it.
+ * (If the "attach_modal_dialogs" option is not enabled, this will
+ * always return %FALSE.)
+ *
+ * Return value: whether @window has attached transients
+ */
+gboolean
+meta_window_has_attached_dialogs (MetaWindow *window)
+{
+  gboolean has_attached = FALSE;
+
+  meta_window_foreach_transient (window,
+                                 has_attached_foreach_func,
+                                 &has_attached);
+  return has_attached;
+}
+
+static gboolean
+has_modals_foreach_func (MetaWindow *window,
+                         void       *data)
+{
+  gboolean *is_modal = data;
+
+  *is_modal = window->type == META_WINDOW_MODAL_DIALOG && !window->unmanaging;
+
+  if (*is_modal)
+    return FALSE;
+
+  return TRUE;
+}
+
+/**
+ * meta_window_has_modals:
+ * @window: a #MetaWindow
+ *
+ * Return value: whether @window has any modal transients
+ */
+gboolean
+meta_window_has_modals (MetaWindow *window)
+{
+  gboolean has_modals = FALSE;
+
+  meta_window_foreach_transient (window, has_modals_foreach_func, &has_modals);
+  return has_modals;
+}
+
 /**
  * meta_window_get_tile_match:
  * @window: a #MetaWindow
@@ -8826,3 +8891,55 @@ meta_window_get_client_type (MetaWindow *window)
 {
   return window->client_type;
 }
+
+static gboolean
+meta_window_close_dialog_timeout (MetaWindow *window)
+{
+  meta_window_show_close_dialog (window);
+  window->close_dialog_timeout_id = 0;
+
+  return G_SOURCE_REMOVE;
+}
+
+void
+meta_window_ensure_close_dialog_timeout (MetaWindow *window)
+{
+  guint check_alive_timeout = meta_prefs_get_check_alive_timeout ();
+
+  if (window->is_alive)
+    return;
+  if (window->close_dialog_timeout_id != 0)
+    return;
+  if (check_alive_timeout == 0)
+    return;
+
+  window->close_dialog_timeout_id =
+    g_timeout_add (check_alive_timeout,
+                   (GSourceFunc) meta_window_close_dialog_timeout,
+                   window);
+  g_source_set_name_by_id (window->close_dialog_timeout_id,
+                           "[mutter] meta_window_close_dialog_timeout");
+}
+
+void
+meta_window_set_alive (MetaWindow *window,
+                       gboolean    is_alive)
+{
+  if (window->is_alive == is_alive)
+    return;
+
+  window->is_alive = is_alive;
+  g_object_notify_by_pspec (G_OBJECT (window), obj_props[PROP_IS_ALIVE]);
+
+  if (is_alive)
+    {
+      g_clear_handle_id (&window->close_dialog_timeout_id, g_source_remove);
+      meta_window_hide_close_dialog (window);
+    }
+}
+
+gboolean
+meta_window_get_alive (MetaWindow *window)
+{
+  return window->is_alive;
+}
diff --git a/src/core/workspace.c b/src/core/workspace.c
index 76ba87b5a..3bd517fca 100644
--- a/src/core/workspace.c
+++ b/src/core/workspace.c
@@ -717,9 +717,7 @@ meta_workspace_index (MetaWorkspace *workspace)
   int ret;
 
   ret = g_list_index (workspace->manager->workspaces, workspace);
-
-  if (ret < 0)
-    meta_bug ("Workspace does not exist to index!");
+  g_return_val_if_fail (ret >= 0, -1);
 
   return ret;
 }
diff --git a/src/meson.build b/src/meson.build
index f3aebfb28..a3aa15957 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -340,8 +340,6 @@ mutter_sources = [
   'compositor/meta-surface-actor-x11.h',
   'compositor/meta-sync-ring.c',
   'compositor/meta-sync-ring.h',
-  'compositor/meta-texture-tower.c',
-  'compositor/meta-texture-tower.h',
   'compositor/meta-window-actor.c',
   'compositor/meta-window-actor-private.h',
   'compositor/meta-window-actor-x11.c',
@@ -460,6 +458,13 @@ mutter_sources = [
   'x11/xprops.h',
 ]
 
+if have_egl_device
+  mutter_sources += [
+    'backends/native/meta-render-device-egl-stream.c',
+    'backends/native/meta-render-device-egl-stream.h',
+  ]
+endif
+
 if have_egl
   mutter_sources += [
     'backends/meta-egl.c',
@@ -577,6 +582,8 @@ if have_wayland
     'wayland/meta-wayland-pointer.c',
     'wayland/meta-wayland-pointer-constraints.c',
     'wayland/meta-wayland-pointer-constraints.h',
+    'wayland/meta-wayland-pointer-gesture-hold.c',
+    'wayland/meta-wayland-pointer-gesture-hold.h',
     'wayland/meta-wayland-pointer-gesture-pinch.c',
     'wayland/meta-wayland-pointer-gesture-pinch.h',
     'wayland/meta-wayland-pointer-gestures.c',
@@ -619,8 +626,6 @@ if have_wayland
     'wayland/meta-wayland-tablet-tool.h',
     'wayland/meta-wayland-text-input.c',
     'wayland/meta-wayland-text-input.h',
-    'wayland/meta-wayland-text-input-legacy.c',
-    'wayland/meta-wayland-text-input-legacy.h',
     'wayland/meta-wayland-touch.c',
     'wayland/meta-wayland-touch.h',
     'wayland/meta-wayland-types.h',
@@ -629,8 +634,6 @@ if have_wayland
     'wayland/meta-wayland-viewporter.h',
     'wayland/meta-wayland-window-configuration.c',
     'wayland/meta-wayland-window-configuration.h',
-    'wayland/meta-wayland-wl-shell.c',
-    'wayland/meta-wayland-wl-shell.h',
     'wayland/meta-wayland-xdg-foreign.c',
     'wayland/meta-wayland-xdg-foreign.h',
     'wayland/meta-wayland-xdg-shell.c',
@@ -748,6 +751,13 @@ if have_native_backend
     'backends/native/meta-onscreen-native.h',
     'backends/native/meta-pointer-constraint-native.c',
     'backends/native/meta-pointer-constraint-native.h',
+    'backends/native/meta-render-device-gbm.c',
+    'backends/native/meta-render-device-gbm.h',
+    'backends/native/meta-render-device-private.h',
+    'backends/native/meta-render-device-surfaceless.c',
+    'backends/native/meta-render-device-surfaceless.h',
+    'backends/native/meta-render-device.c',
+    'backends/native/meta-render-device.h',
     'backends/native/meta-renderer-native-gles3.c',
     'backends/native/meta-renderer-native-gles3.h',
     'backends/native/meta-renderer-native-private.h',
@@ -790,6 +800,7 @@ endif
 if have_native_backend
   mutter_private_enum_sources += [
     'backends/native/meta-backend-native-types.h',
+    'backends/native/meta-drm-buffer.h',
     'backends/native/meta-kms-types.h',
   ]
 endif
@@ -807,14 +818,14 @@ if mutter_private_enum_sources.length() > 0
 endif
 
 dbus_display_config_built_sources = gnome.gdbus_codegen('meta-dbus-display-config',
-    'org.gnome.Mutter.DisplayConfig.xml',
+    join_paths(dbus_interfaces_dir, 'org.gnome.Mutter.DisplayConfig.xml'),
     interface_prefix: 'org.gnome.Mutter.',
     namespace: 'MetaDBus',
   )
 mutter_built_sources += dbus_display_config_built_sources
 
 dbus_idle_monitor_built_sources = gnome.gdbus_codegen('meta-dbus-idle-monitor',
-    'org.gnome.Mutter.IdleMonitor.xml',
+    join_paths(dbus_interfaces_dir, 'org.gnome.Mutter.IdleMonitor.xml'),
     interface_prefix: 'org.gnome.Mutter.',
     namespace: 'MetaDBus',
     object_manager: true,
@@ -853,7 +864,7 @@ if have_native_backend
   mutter_built_sources += default_modes_h
 
   dbus_login1_built_sources = gnome.gdbus_codegen('meta-dbus-login1',
-    'org.freedesktop.login1.xml',
+    join_paths(dbus_interfaces_dir, 'org.freedesktop.login1.xml'),
     interface_prefix: 'org.freedesktop.login1.',
     namespace: 'MetaDbusLogin1',
   )
@@ -862,20 +873,27 @@ endif
 
 if have_remote_desktop
   dbus_remote_desktop_built_sources = gnome.gdbus_codegen('meta-dbus-remote-desktop',
-      'org.gnome.Mutter.RemoteDesktop.xml',
+      join_paths(dbus_interfaces_dir, 'org.gnome.Mutter.RemoteDesktop.xml'),
       interface_prefix: 'org.gnome.Mutter.',
       namespace: 'MetaDBus',
     )
   mutter_built_sources += dbus_remote_desktop_built_sources
 
   dbus_screen_cast_built_sources = gnome.gdbus_codegen('meta-dbus-screen-cast',
-      'org.gnome.Mutter.ScreenCast.xml',
+      join_paths(dbus_interfaces_dir, 'org.gnome.Mutter.ScreenCast.xml'),
       interface_prefix: 'org.gnome.Mutter.',
       namespace: 'MetaDBus',
     )
   mutter_built_sources += dbus_screen_cast_built_sources
 endif
 
+dbus_rtkit_built_sources = gnome.gdbus_codegen('meta-dbus-rtkit1',
+    join_paths(dbus_interfaces_dir, 'org.freedesktop.RealtimeKit1.xml'),
+    interface_prefix: 'org.freedesktop.',
+    namespace: 'MetaDbus',
+)
+mutter_built_sources += dbus_rtkit_built_sources
+
 wayland_protocol_server_headers = []
 wayland_protocol_client_headers = []
 wayland_protocol_sources = []
@@ -888,7 +906,6 @@ if have_wayland
   wayland_protocols = [
     ['gtk-primary-selection', 'private', ],
     ['gtk-shell', 'private', ],
-    ['gtk-text-input', 'private', ],
     ['keyboard-shortcuts-inhibit', 'unstable', 'v1', ],
     ['linux-dmabuf', 'unstable', 'v1', ],
     ['pointer-constraints', 'unstable', 'v1', ],
diff --git a/src/meta/display.h b/src/meta/display.h
index 23bcbd0f5..e59bd0393 100644
--- a/src/meta/display.h
+++ b/src/meta/display.h
@@ -110,6 +110,9 @@ guint32 meta_display_get_current_time (MetaDisplay *display);
 META_EXPORT
 guint32 meta_display_get_current_time_roundtrip (MetaDisplay *display);
 
+META_EXPORT
+GList * meta_display_list_all_windows (MetaDisplay *display);
+
 META_EXPORT
 GList* meta_display_get_tab_list (MetaDisplay   *display,
                                   MetaTabList    type,
diff --git a/src/meta/meta-backend.h b/src/meta/meta-backend.h
index 63a679a1a..cfb042a72 100644
--- a/src/meta/meta-backend.h
+++ b/src/meta/meta-backend.h
@@ -30,6 +30,7 @@
 #include "clutter/clutter.h"
 #include "meta/meta-dnd.h"
 #include "meta/meta-idle-monitor.h"
+#include "meta/meta-monitor-manager.h"
 #include "meta/meta-remote-access-controller.h"
 
 #define META_TYPE_BACKEND (meta_backend_get_type ())
@@ -64,12 +65,18 @@ MetaSettings *meta_backend_get_settings (MetaBackend *backend);
 META_EXPORT
 MetaIdleMonitor * meta_backend_get_core_idle_monitor (MetaBackend *backend);
 
+META_EXPORT
+MetaMonitorManager * meta_backend_get_monitor_manager (MetaBackend *backend);
+
 META_EXPORT
 MetaRemoteAccessController * meta_backend_get_remote_access_controller (MetaBackend *backend);
 
 META_EXPORT
 gboolean meta_backend_is_rendering_hardware_accelerated (MetaBackend *backend);
 
+META_EXPORT
+gboolean meta_backend_is_headless (MetaBackend *backend);
+
 META_EXPORT
 void meta_clutter_init (void);
 
diff --git a/src/meta/util.h b/src/meta/util.h
index 834e61d49..c44a63fc8 100644
--- a/src/meta/util.h
+++ b/src/meta/util.h
@@ -38,10 +38,6 @@ gboolean meta_is_syncing (void);
 META_EXPORT
 gboolean meta_is_wayland_compositor (void);
 
-META_EXPORT
-void meta_verbose_real    (const char *format,
-                           ...) G_GNUC_PRINTF (1, 2);
-
 META_EXPORT
 void meta_bug        (const char *format,
                       ...) G_GNUC_PRINTF (1, 2);
@@ -80,6 +76,7 @@ void meta_fatal      (const char *format,
  * @META_DEBUG_SCREEN_CAST: screencasting
  * @META_DEBUG_REMOTE_DESKTOP: remote desktop
  * @META_DEBUG_BACKEND: backend
+ * @META_DEBUG_RENDER: native backend rendering
  */
 typedef enum
 {
@@ -109,6 +106,7 @@ typedef enum
   META_DEBUG_SCREEN_CAST     = 1 << 22,
   META_DEBUG_REMOTE_DESKTOP  = 1 << 23,
   META_DEBUG_BACKEND         = 1 << 24,
+  META_DEBUG_RENDER          = 1 << 25,
 } MetaDebugTopic;
 
 /**
@@ -125,11 +123,6 @@ typedef enum
 META_EXPORT
 gboolean meta_is_topic_enabled (MetaDebugTopic topic);
 
-META_EXPORT
-void meta_topic_real      (MetaDebugTopic topic,
-                           const char    *format,
-                           ...) G_GNUC_PRINTF (2, 3);
-
 META_EXPORT
 void meta_add_verbose_topic    (MetaDebugTopic topic);
 
@@ -175,22 +168,23 @@ GPid meta_show_dialog (const char *type,
 /* To disable verbose mode, we make these functions into no-ops */
 #ifdef WITH_VERBOSE_MODE
 
-#define meta_verbose(...) \
-  G_STMT_START \
-    { \
-      if (meta_is_topic_enabled (META_DEBUG_VERBOSE)) \
-        meta_verbose_real (__VA_ARGS__); \
-    } \
-  G_STMT_END
+const char * meta_topic_to_string (MetaDebugTopic topic);
 
-#define meta_topic(debug_topic,...) \
+#define meta_topic(debug_topic, ...) \
   G_STMT_START \
     { \
       if (meta_is_topic_enabled (debug_topic)) \
-        meta_topic_real (debug_topic, __VA_ARGS__); \
+        { \
+          g_autofree char *message = NULL; \
+\
+          message = g_strdup_printf (__VA_ARGS__); \
+          g_message ("%s: %s", meta_topic_to_string (debug_topic), message); \
+        } \
     } \
   G_STMT_END
 
+#define meta_verbose(...) meta_topic (META_DEBUG_VERBOSE, __VA_ARGS__)
+
 #else
 
 #  ifdef G_HAVE_ISO_VARARGS
@@ -224,6 +218,11 @@ void meta_remove_clutter_debug_flags (ClutterDebugFlag     debug_flags,
                                       ClutterDrawDebugFlag draw_flags,
                                       ClutterPickDebugFlag pick_flags);
 
+META_EXPORT
+void meta_get_clutter_debug_flags (ClutterDebugFlag     *debug_flags,
+                                   ClutterDrawDebugFlag *draw_flags,
+                                   ClutterPickDebugFlag *pick_flags);
+
 META_EXPORT
 void meta_add_debug_paint_flag (MetaDebugPaintFlag flag);
 
diff --git a/src/meta/window.h b/src/meta/window.h
index 2b69269d1..d5d07a061 100644
--- a/src/meta/window.h
+++ b/src/meta/window.h
@@ -343,6 +343,9 @@ gboolean    meta_window_is_remote (MetaWindow *window);
 META_EXPORT
 gboolean    meta_window_is_attached_dialog (MetaWindow *window);
 
+META_EXPORT
+gboolean    meta_window_has_attached_dialogs (MetaWindow *window);
+
 META_EXPORT
 const char *meta_window_get_mutter_hints (MetaWindow *window);
 
diff --git a/src/tests/clutter/accessibility/cally-atkevents-example.c b/src/tests/clutter/accessibility/cally-atkevents-example.c
index a94b7880a..182cb66f6 100644
--- a/src/tests/clutter/accessibility/cally-atkevents-example.c
+++ b/src/tests/clutter/accessibility/cally-atkevents-example.c
@@ -178,15 +178,12 @@ main (int argc, char *argv[])
 
   clutter_actor_show (stage_main);
 
-  if (clutter_feature_available (CLUTTER_FEATURE_STAGE_MULTIPLE))
-    {
-      stage = clutter_test_get_stage ();
-      clutter_stage_set_title (CLUTTER_STAGE (stage), "Cally - AtkEvents/2");
-      g_signal_connect (stage, "destroy", G_CALLBACK (clutter_test_quit), NULL);
+  stage = clutter_test_get_stage ();
+  clutter_stage_set_title (CLUTTER_STAGE (stage), "Cally - AtkEvents/2");
+  g_signal_connect (stage, "destroy", G_CALLBACK (clutter_test_quit), NULL);
 
-      make_ui (stage);
-      clutter_actor_show (stage);
-    }
+  make_ui (stage);
+  clutter_actor_show (stage);
 
   clutter_test_main ();
 
diff --git a/src/tests/clutter/conform/actor-event-hold.c b/src/tests/clutter/conform/actor-event-hold.c
new file mode 100644
index 000000000..1635cf7b4
--- /dev/null
+++ b/src/tests/clutter/conform/actor-event-hold.c
@@ -0,0 +1,141 @@
+/*
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author: José Expósito <jose.exposito89@gmail.com>
+ */
+#include <stdlib.h>
+#include <string.h>
+
+#include <clutter/clutter.h>
+
+#include "tests/clutter-test-utils.h"
+
+#define EVENT_TIME 1000
+
+typedef struct {
+  ClutterTouchpadGesturePhase phase;
+  guint n_fingers;
+  gfloat x;
+  gfloat y;
+} HoldTestCase;
+
+static const HoldTestCase test_cases[] = {
+  {
+    .phase = CLUTTER_TOUCHPAD_GESTURE_PHASE_BEGIN,
+    .n_fingers = 1,
+    .x = 100,
+    .y = 150,
+  },
+  {
+    .phase = CLUTTER_TOUCHPAD_GESTURE_PHASE_END,
+    .n_fingers = 2,
+    .x = 200,
+    .y = 250,
+  },
+  {
+    .phase = CLUTTER_TOUCHPAD_GESTURE_PHASE_CANCEL,
+    .n_fingers = 3,
+    .x = 300,
+    .y = 350,
+  },
+};
+
+static gboolean
+on_stage_captured_event (ClutterActor  *stage,
+                         ClutterEvent  *event,
+                         ClutterEvent **captured_event)
+{
+  *captured_event = clutter_event_copy (event);
+  return TRUE;
+}
+
+static void
+actor_event_hold (void)
+{
+  ClutterActor *stage;
+  ClutterBackend *backend;
+  ClutterSeat *seat;
+  ClutterInputDevice *device;
+  ClutterEvent *event;
+  ClutterEvent *captured_event;
+  size_t n_test_case;
+
+  /* Get the stage and listen for touchpad events */
+  stage = clutter_test_get_stage ();
+  g_signal_connect (stage, "captured-event::touchpad",
+                    G_CALLBACK (on_stage_captured_event),
+                    &captured_event);
+  clutter_actor_show (stage);
+
+  /* Get the input device*/
+  backend = clutter_get_default_backend ();
+  seat = clutter_backend_get_default_seat (backend);
+  device = clutter_seat_get_pointer (seat);
+
+  while (clutter_stage_get_device_actor (CLUTTER_STAGE (stage), device, NULL) == NULL)
+    g_main_context_iteration (NULL, FALSE);
+
+  for (n_test_case = 0; n_test_case < G_N_ELEMENTS (test_cases); n_test_case++)
+    {
+      graphene_point_t actual_position;
+      gdouble *actual_axes;
+      ClutterTouchpadGesturePhase actual_phase;
+      guint actual_n_fingers;
+      gdouble dx, dy, udx, udy;
+
+      const HoldTestCase *test_case = test_cases + n_test_case;
+
+      /* Create a synthetic hold event */
+      event = clutter_event_new (CLUTTER_TOUCHPAD_HOLD);
+      event->touchpad_hold.phase = test_case->phase;
+      event->touchpad_hold.time = EVENT_TIME;
+      event->touchpad_hold.n_fingers = test_case->n_fingers;
+      event->touchpad_hold.stage = (ClutterStage *) stage;
+      event->touchpad_hold.source = stage;
+      clutter_event_set_coords (event, test_case->x, test_case->y);
+      clutter_event_set_device (event, device);
+
+      clutter_event_put (event);
+      clutter_event_free (event);
+
+      /* Capture the event received by the stage */
+      captured_event = NULL;
+      while (captured_event == NULL)
+        g_main_context_iteration (NULL, FALSE);
+
+      /* Check that expected the event params match the actual values */
+      clutter_event_get_position (captured_event, &actual_position);
+      actual_axes = clutter_event_get_axes (captured_event, 0);
+      actual_phase = clutter_event_get_gesture_phase (captured_event);
+      actual_n_fingers = clutter_event_get_touchpad_gesture_finger_count (captured_event);
+      clutter_event_get_gesture_motion_delta (captured_event, &dx, &dy);
+      clutter_event_get_gesture_motion_delta_unaccelerated (captured_event, &udx, &udy);
+
+      g_assert (actual_position.x == test_case->x);
+      g_assert (actual_position.y == test_case->y);
+      g_assert_null (actual_axes);
+      g_assert (actual_phase == test_case->phase);
+      g_assert (actual_n_fingers == test_case->n_fingers);
+      g_assert (dx == 0);
+      g_assert (dy == 0);
+      g_assert (udx == 0);
+      g_assert (udy == 0);
+
+      clutter_event_free (captured_event);
+    }
+}
+
+CLUTTER_TEST_SUITE (
+  CLUTTER_TEST_UNIT ("/actor/event/hold", actor_event_hold)
+)
diff --git a/src/tests/clutter/conform/frame-clock-timeline.c b/src/tests/clutter/conform/frame-clock-timeline.c
index 0f9f04d79..fe001b55c 100644
--- a/src/tests/clutter/conform/frame-clock-timeline.c
+++ b/src/tests/clutter/conform/frame-clock-timeline.c
@@ -2,11 +2,11 @@
 #include "tests/clutter-test-utils.h"
 
 static const float refresh_rate = 60.0;
+static const int64_t refresh_interval_us = G_USEC_PER_SEC / refresh_rate;
 
 static ClutterFrameResult
 timeline_frame_clock_frame (ClutterFrameClock *frame_clock,
                             int64_t            frame_count,
-                            int64_t            time_us,
                             gpointer           user_data)
 {
   ClutterFrameInfo frame_info;
@@ -61,6 +61,8 @@ frame_clock_timeline_basic (void)
   int frame_counter;
   int64_t before_us;
   int64_t after_us;
+  int64_t duration_us;
+  int64_t lateness_us;
 
   main_loop = g_main_loop_new (NULL, FALSE);
   frame_clock = clutter_frame_clock_new (refresh_rate,
@@ -97,10 +99,10 @@ frame_clock_timeline_basic (void)
   g_main_loop_run (main_loop);
 
   after_us = g_get_monotonic_time ();
+  duration_us = after_us - before_us;
+  lateness_us = duration_us - ms2us (clutter_timeline_get_duration (timeline));
 
-  g_assert_cmpint (after_us - before_us,
-                   >=,
-                   ms2us (clutter_timeline_get_duration (timeline)));
+  g_assert_cmpint (lateness_us, >, -refresh_interval_us);
 
   g_assert_true (marker1_reached);
 
@@ -140,6 +142,8 @@ frame_clock_timeline_switch (void)
   int frame_counter;
   int64_t before_us;
   int64_t after_us;
+  int64_t duration_us;
+  int64_t lateness_us;
 
   main_loop = g_main_loop_new (NULL, FALSE);
 
@@ -181,10 +185,15 @@ frame_clock_timeline_switch (void)
   g_main_loop_run (main_loop);
 
   after_us = g_get_monotonic_time ();
+  duration_us = after_us - before_us;
+  lateness_us = duration_us - ms2us (clutter_timeline_get_duration (timeline));
 
-  g_assert_cmpint (after_us - before_us,
-                   >=,
-                   ms2us (clutter_timeline_get_duration (timeline)));
+  /* Our threshold is two frames. This is because switching a timeline to a
+   * new clock of the same frequency shifts the phase up to one frame. And
+   * this timeline has seen two different clocks so its overall duration may
+   * be out by almost two frames. But more than two frames is a bug.
+   */
+  g_assert_cmpint (lateness_us, >, -2 * refresh_interval_us);
 
   g_assert (clutter_timeline_get_frame_clock (timeline) == frame_clock2);
 
diff --git a/src/tests/clutter/conform/frame-clock.c b/src/tests/clutter/conform/frame-clock.c
index 810c39a02..cf118de1b 100644
--- a/src/tests/clutter/conform/frame-clock.c
+++ b/src/tests/clutter/conform/frame-clock.c
@@ -92,7 +92,6 @@ fake_hw_clock_new (ClutterFrameClock *frame_clock,
 static ClutterFrameResult
 frame_clock_frame (ClutterFrameClock *frame_clock,
                    int64_t            frame_count,
-                   int64_t            time_us,
                    gpointer           user_data)
 {
   FrameClockTest *test = user_data;
@@ -187,7 +186,6 @@ schedule_update_idle (gpointer user_data)
 static ClutterFrameResult
 immediate_frame_clock_frame (ClutterFrameClock *frame_clock,
                              int64_t            frame_count,
-                             int64_t            time_us,
                              gpointer           user_data)
 {
   GMainLoop *main_loop = user_data;
@@ -262,7 +260,6 @@ schedule_update_timeout (gpointer user_data)
 static ClutterFrameResult
 delayed_damage_frame_clock_frame (ClutterFrameClock *frame_clock,
                                   int64_t            frame_count,
-                                  int64_t            time_us,
                                   gpointer           user_data)
 {
   FrameClockTest *test = user_data;
@@ -336,7 +333,6 @@ frame_clock_delayed_damage (void)
 static ClutterFrameResult
 no_damage_frame_clock_frame (ClutterFrameClock *frame_clock,
                              int64_t            frame_count,
-                             int64_t            time_us,
                              gpointer           user_data)
 {
   g_assert_not_reached ();
@@ -390,7 +386,6 @@ typedef struct _UpdateNowFrameClockTest
 static ClutterFrameResult
 update_now_frame_clock_frame (ClutterFrameClock *frame_clock,
                               int64_t            frame_count,
-                              int64_t            time_us,
                               gpointer           user_data)
 {
   UpdateNowFrameClockTest *test = user_data;
@@ -497,7 +492,6 @@ before_frame_frame_clock_before_frame (ClutterFrameClock *frame_clock,
 static ClutterFrameResult
 before_frame_frame_clock_frame (ClutterFrameClock *frame_clock,
                                 int64_t            frame_count,
-                                int64_t            time_us,
                                 gpointer           user_data)
 {
   int64_t *expected_frame_count = user_data;
@@ -567,7 +561,6 @@ typedef struct _InhibitTest
 static ClutterFrameResult
 inhibit_frame_clock_frame (ClutterFrameClock *frame_clock,
                            int64_t            frame_count,
-                           int64_t            time_us,
                            gpointer           user_data)
 {
   InhibitTest *test = user_data;
@@ -645,7 +638,6 @@ typedef struct _RescheduleOnIdleFrameClockTest
 static ClutterFrameResult
 reschedule_on_idle_clock_frame (ClutterFrameClock *frame_clock,
                                 int64_t            frame_count,
-                                int64_t            time_us,
                                 gpointer           user_data)
 {
   RescheduleOnIdleFrameClockTest *test = user_data;
@@ -773,7 +765,6 @@ notify_ready_and_schedule_update_idle (gpointer user_data)
 static ClutterFrameResult
 frame_clock_ready_frame (ClutterFrameClock *frame_clock,
                          int64_t            frame_count,
-                         int64_t            time_us,
                          gpointer           user_data)
 {
   GMainLoop *main_loop = user_data;
diff --git a/src/tests/clutter/conform/meson.build b/src/tests/clutter/conform/meson.build
index aec4a9148..f02b78b41 100644
--- a/src/tests/clutter/conform/meson.build
+++ b/src/tests/clutter/conform/meson.build
@@ -12,6 +12,7 @@ clutter_tests_conform_link_args = [
 clutter_conform_tests_actor_tests = [
   'actor-clone',
   'actor-destroy',
+  'actor-event-hold',
   'actor-graph',
   'actor-invariants',
   'actor-iter',
diff --git a/src/tests/clutter/interactive/test-cogl-multitexture.c b/src/tests/clutter/interactive/test-cogl-multitexture.c
index f14f0b7d8..f2c073dd3 100644
--- a/src/tests/clutter/interactive/test-cogl-multitexture.c
+++ b/src/tests/clutter/interactive/test-cogl-multitexture.c
@@ -11,7 +11,7 @@
 
 #include "tests/clutter-test-utils.h"
 
-typedef struct _TestMultiLayerMaterialState
+typedef struct _TestMultiLayerPipelineState
 {
   ClutterActor    *group;
   CoglHandle       alpha_tex;
@@ -20,17 +20,17 @@ typedef struct _TestMultiLayerMaterialState
 
   ClutterTimeline *timeline;
 
-  CoglHandle       material0;
+  CoglPipeline *pipeline0;
   graphene_matrix_t tex_matrix0;
   graphene_matrix_t rot_matrix0;
   CoglHandle       light_tex0;
 
-  CoglHandle       material1;
+  CoglPipeline *pipeline1;
   graphene_matrix_t tex_matrix1;
   graphene_matrix_t rot_matrix1;
   CoglHandle       light_tex1;
 
-} TestMultiLayerMaterialState;
+} TestMultiLayerPipelineState;
 
 int
 test_cogl_multitexture_main (int argc, char *argv[]);
@@ -43,17 +43,17 @@ frame_cb (ClutterTimeline  *timeline,
 	  gint		   frame_no,
 	  gpointer	   data)
 {
-  TestMultiLayerMaterialState *state = data;
+  TestMultiLayerPipelineState *state = data;
 
   graphene_matrix_multiply (&state->rot_matrix0,
                             &state->tex_matrix0,
                             &state->tex_matrix0);
-  cogl_material_set_layer_matrix (state->material0, 2, &state->tex_matrix0);
+  cogl_pipeline_set_layer_matrix (state->pipeline0, 2, &state->tex_matrix0);
 
   graphene_matrix_multiply (&state->rot_matrix1,
                             &state->tex_matrix1,
                             &state->tex_matrix1);
-  cogl_material_set_layer_matrix (state->material1, 2, &state->tex_matrix1);
+  cogl_pipeline_set_layer_matrix (state->pipeline1, 2, &state->tex_matrix1);
 }
 
 static void
@@ -61,7 +61,7 @@ material_rectangle_paint (ClutterActor        *actor,
                           ClutterPaintContext *paint_context,
                           gpointer             data)
 {
-  TestMultiLayerMaterialState *state = data;
+  TestMultiLayerPipelineState *state = data;
   CoglFramebuffer *framebuffer =
     clutter_paint_context_get_framebuffer (paint_context);
 
@@ -70,13 +70,13 @@ material_rectangle_paint (ClutterActor        *actor,
   cogl_framebuffer_translate (framebuffer, 150, 15, 0);
 
   cogl_framebuffer_draw_multitextured_rectangle (framebuffer,
-                                                 COGL_FRAMEBUFFER (state->material0),
+                                                 COGL_FRAMEBUFFER (state->pipeline0),
                                                  0, 0, 200, 213,
                                                  state->tex_coords,
                                                  12);
   cogl_framebuffer_translate (framebuffer, -300, -30, 0);
   cogl_framebuffer_draw_multitextured_rectangle (framebuffer,
-                                                 COGL_FRAMEBUFFER (state->material1),
+                                                 COGL_FRAMEBUFFER (state->pipeline1),
                                                  0, 0, 200, 213,
                                                  state->tex_coords,
                                                  12);
@@ -86,7 +86,7 @@ material_rectangle_paint (ClutterActor        *actor,
 
 static void
 animation_completed_cb (ClutterAnimation            *animation,
-                        TestMultiLayerMaterialState *state)
+                        TestMultiLayerPipelineState *state)
 {
   static gboolean go_back = FALSE;
   gdouble new_rotation_y;
@@ -114,7 +114,7 @@ test_cogl_multitexture_main (int argc, char *argv[])
   GError            *error = NULL;
   ClutterActor	    *stage;
   ClutterColor       stage_color = { 0x61, 0x56, 0x56, 0xff };
-  g_autofree TestMultiLayerMaterialState *state = g_new0 (TestMultiLayerMaterialState, 1);
+  g_autofree TestMultiLayerPipelineState *state = g_new0 (TestMultiLayerPipelineState, 1);
   gfloat             stage_w, stage_h;
   gchar            **files;
   gfloat             tex_coords[] =
@@ -184,15 +184,15 @@ test_cogl_multitexture_main (int argc, char *argv[])
 
   g_strfreev (files);
 
-  state->material0 = cogl_material_new ();
-  cogl_material_set_layer (state->material0, 0, state->alpha_tex);
-  cogl_material_set_layer (state->material0, 1, state->redhand_tex);
-  cogl_material_set_layer (state->material0, 2, state->light_tex0);
+  state->pipeline0 = cogl_pipeline_new ();
+  cogl_pipeline_set_layer (state->pipeline0, 0, state->alpha_tex);
+  cogl_pipeline_set_layer (state->pipeline0, 1, state->redhand_tex);
+  cogl_pipeline_set_layer (state->pipeline0, 2, state->light_tex0);
 
-  state->material1 = cogl_material_new ();
-  cogl_material_set_layer (state->material1, 0, state->alpha_tex);
-  cogl_material_set_layer (state->material1, 1, state->redhand_tex);
-  cogl_material_set_layer (state->material1, 2, state->light_tex1);
+  state->pipeline1 = cogl_pipeline_new ();
+  cogl_pipeline_set_layer (state->pipeline1, 0, state->alpha_tex);
+  cogl_pipeline_set_layer (state->pipeline1, 1, state->redhand_tex);
+  cogl_pipeline_set_layer (state->pipeline1, 2, state->light_tex1);
 
   state->tex_coords = tex_coords;
 
@@ -236,8 +236,8 @@ test_cogl_multitexture_main (int argc, char *argv[])
 
   clutter_test_main ();
 
-  cogl_object_unref (state->material1);
-  cogl_object_unref (state->material0);
+  cogl_object_unref (state->pipeline1);
+  cogl_object_unref (state->pipeline0);
   cogl_object_unref (state->alpha_tex);
   cogl_object_unref (state->redhand_tex);
   cogl_object_unref (state->light_tex0);
diff --git a/src/tests/clutter/interactive/test-cogl-offscreen.c b/src/tests/clutter/interactive/test-cogl-offscreen.c
index 4f2e6bddb..0b4a2f10f 100644
--- a/src/tests/clutter/interactive/test-cogl-offscreen.c
+++ b/src/tests/clutter/interactive/test-cogl-offscreen.c
@@ -281,6 +281,8 @@ static void
 test_coglbox_init (TestCoglbox *self)
 {
   TestCoglboxPrivate *priv;
+  CoglContext *ctx =
+    clutter_backend_get_cogl_context (clutter_get_default_backend ());
   gchar *file;
 
   self->priv = priv = TEST_COGLBOX_GET_PRIVATE(self);
@@ -294,9 +296,7 @@ test_coglbox_init (TestCoglbox *self)
   g_free (file);
 
   printf ("Creating texture with size\n");
-  priv->texture_id = cogl_texture_new_with_size (200, 200,
-                                                 COGL_TEXTURE_NONE,
-						 COGL_PIXEL_FORMAT_RGB_888);
+  priv->texture_id = cogl_texture_2d_new_with_size (ctx, 200, 200);
 
   if (priv->texture_id == NULL)
     printf ("Failed creating texture with size!\n");
diff --git a/src/tests/clutter/interactive/test-cogl-point-sprites.c b/src/tests/clutter/interactive/test-cogl-point-sprites.c
index 9d6027274..0b3feb0c3 100644
--- a/src/tests/clutter/interactive/test-cogl-point-sprites.c
+++ b/src/tests/clutter/interactive/test-cogl-point-sprites.c
@@ -50,7 +50,7 @@ struct _Data
   Spark sparks[N_SPARKS];
   GTimer *last_spark_time;
 
-  CoglMaterial *material;
+  CoglPipeline *pipeline;
 };
 
 int
@@ -217,22 +217,24 @@ test_cogl_point_sprites_main (int argc, char *argv[])
 {
   ClutterActor *stage;
   CoglHandle tex;
+  CoglContext *ctx =
+    clutter_backend_get_cogl_context (clutter_get_default_backend ());
   Data data;
   GError *error = NULL;
   int i;
 
   clutter_test_init (&argc, &argv);
 
-  data.material = cogl_material_new ();
+  data.pipeline = cogl_pipeline_new (ctx);
   data.last_spark_time = g_timer_new ();
   data.next_spark_num = 0;
-  cogl_material_set_point_size (data.material, TEXTURE_SIZE);
+  cogl_pipeline_set_point_size (data.pipeline, TEXTURE_SIZE);
 
   tex = generate_round_texture ();
-  cogl_material_set_layer (data.material, 0, tex);
+  cogl_pipeline_set_layer_texture (data.pipeline, 0, tex);
   cogl_object_unref (tex);
 
-  if (!cogl_material_set_layer_point_sprite_coords_enabled (data.material,
+  if (!cogl_pipeline_set_layer_point_sprite_coords_enabled (data.pipeline,
                                                             0, TRUE,
                                                             &error))
     {
@@ -266,7 +268,7 @@ test_cogl_point_sprites_main (int argc, char *argv[])
 
   clutter_test_main ();
 
-  cogl_object_unref (data.material);
+  cogl_object_unref (data.pipeline);
   g_timer_destroy (data.last_spark_time);
 
   for (i = 0; i < N_FIREWORKS; i++)
diff --git a/src/tests/clutter/interactive/test-cogl-shader-glsl.c b/src/tests/clutter/interactive/test-cogl-shader-glsl.c
index 62b16e772..a386f43ce 100644
--- a/src/tests/clutter/interactive/test-cogl-shader-glsl.c
+++ b/src/tests/clutter/interactive/test-cogl-shader-glsl.c
@@ -161,7 +161,7 @@ static ShaderSource shaders[]=
 };
 
 static CoglHandle redhand;
-static CoglMaterial *material;
+static CoglPipeline *pipeline;
 static unsigned int timeout_id = 0;
 static int shader_no = 0;
 
@@ -176,7 +176,7 @@ on_after_paint (ClutterActor        *actor,
   float image_width = cogl_texture_get_width (redhand);
   float image_height = cogl_texture_get_height (redhand);
 
-  cogl_framebuffer_draw_rectangle (framebuffer, COGL_PIPELINE (material),
+  cogl_framebuffer_draw_rectangle (framebuffer, pipeline,
                                    stage_width / 2.0f - image_width / 2.0f,
                                    stage_height / 2.0f - image_height / 2.0f,
                                    stage_width / 2.0f + image_width / 2.0f,
@@ -188,6 +188,9 @@ set_shader_num (int new_no)
 {
   CoglHandle shader;
   CoglHandle program;
+  CoglPipeline *pipeline;
+  CoglContext *ctx =
+    clutter_backend_get_cogl_context (clutter_get_default_backend ());
   int image_width = cogl_texture_get_width (redhand);
   int image_height = cogl_texture_get_height (redhand);
   int uniform_no;
@@ -196,6 +199,8 @@ set_shader_num (int new_no)
            new_no,
            shaders[new_no].name);
 
+  pipeline = cogl_pipeline_new (ctx);
+
   shader = cogl_create_shader (COGL_SHADER_TYPE_FRAGMENT);
   cogl_shader_source (shader, shaders[new_no].source);
 
@@ -218,7 +223,7 @@ set_shader_num (int new_no)
   uniform_no = cogl_program_get_uniform_location (program, "y_step");
   cogl_program_set_uniform_1f (program, uniform_no, 1.0f / image_height);
 
-  cogl_material_set_user_program (material, program);
+  cogl_pipeline_set_user_program (pipeline, program);
   cogl_object_unref (program);
 
   shader_no = new_no;
@@ -305,6 +310,9 @@ test_cogl_shader_glsl_main (int argc, char *argv[])
   char *file;
   GError *error;
   ClutterColor stage_color = { 0x61, 0x64, 0x8c, 0xff };
+  CoglPipeline *pipeline;
+  CoglContext *ctx =
+    clutter_backend_get_cogl_context (clutter_get_default_backend ());
 
   clutter_test_init (&argc, &argv);
 
@@ -322,8 +330,8 @@ test_cogl_shader_glsl_main (int argc, char *argv[])
   if (redhand == NULL)
     g_error ("image load failed: %s", error->message);
 
-  material = cogl_material_new ();
-  cogl_material_set_layer (material, 0, redhand);
+  pipeline = cogl_pipeline_new (ctx);
+  cogl_pipeline_set_layer_texture (pipeline, 0, redhand);
 
   set_shader_num (0);
   g_signal_connect (CLUTTER_STAGE (stage), "after-paint", G_CALLBACK (on_after_paint), NULL);
diff --git a/src/tests/clutter/interactive/test-cogl-tex-polygon.c b/src/tests/clutter/interactive/test-cogl-tex-polygon.c
index 2479a3d7c..464622074 100644
--- a/src/tests/clutter/interactive/test-cogl-tex-polygon.c
+++ b/src/tests/clutter/interactive/test-cogl-tex-polygon.c
@@ -149,7 +149,7 @@ test_coglbox_fade_texture (CoglFramebuffer *framebuffer,
 
 static void
 test_coglbox_triangle_texture (CoglFramebuffer *framebuffer,
-                               CoglHandle       material,
+                               CoglPipeline    *pipeline,
                                int              tex_width,
                                int              tex_height,
                                float            x,
@@ -186,7 +186,7 @@ test_coglbox_triangle_texture (CoglFramebuffer *framebuffer,
                                        COGL_VERTICES_MODE_TRIANGLE_FAN,
                                        3,
                                        vertices);
-  cogl_primitive_draw (primitive, framebuffer, material);
+  cogl_primitive_draw (primitive, framebuffer, pipeline);
   cogl_object_unref (primitive);
 }
 
@@ -199,19 +199,22 @@ test_coglbox_paint (ClutterActor        *self,
                                            : priv->not_sliced_tex;
   int tex_width = cogl_texture_get_width (tex_handle);
   int tex_height = cogl_texture_get_height (tex_handle);
+  CoglPipeline *pipeline;
   CoglFramebuffer *framebuffer =
     clutter_paint_context_get_framebuffer (paint_context);
-  CoglHandle material = cogl_material_new ();
+  CoglContext *ctx =
+    clutter_backend_get_cogl_context (clutter_get_default_backend ());
 
-  cogl_material_set_layer (material, 0, tex_handle);
+  pipeline = cogl_pipeline_new (ctx);
+  cogl_pipeline_set_layer_texture (pipeline, 0, tex_handle);
 
-  cogl_material_set_layer_filters (material, 0,
+  cogl_pipeline_set_layer_filters (pipeline, 0,
                                    priv->use_linear_filtering
-                                   ? COGL_MATERIAL_FILTER_LINEAR :
-                                   COGL_MATERIAL_FILTER_NEAREST,
+                                   ? COGL_PIPELINE_FILTER_LINEAR :
+                                   COGL_PIPELINE_FILTER_NEAREST,
                                    priv->use_linear_filtering
-                                   ? COGL_MATERIAL_FILTER_LINEAR :
-                                   COGL_MATERIAL_FILTER_NEAREST);
+                                   ? COGL_PIPELINE_FILTER_LINEAR :
+                                   COGL_PIPELINE_FILTER_NEAREST);
 
   cogl_framebuffer_push_matrix (framebuffer);
   cogl_framebuffer_translate (framebuffer, tex_width / 2, 0, 0);
@@ -219,10 +222,10 @@ test_coglbox_paint (ClutterActor        *self,
   cogl_framebuffer_translate (framebuffer, -tex_width / 2, 0, 0);
 
   /* Draw a hand and reflect it */
-  cogl_framebuffer_draw_textured_rectangle (framebuffer, material,
+  cogl_framebuffer_draw_textured_rectangle (framebuffer, pipeline,
                                             0, 0, tex_width, tex_height,
                                             0, 0, 1, 1);
-  test_coglbox_fade_texture (framebuffer, material,
+  test_coglbox_fade_texture (framebuffer, pipeline,
                              0, tex_height,
 			     tex_width, (tex_height * 3 / 2),
 			     0.0, 1.0,
@@ -236,13 +239,13 @@ test_coglbox_paint (ClutterActor        *self,
   cogl_framebuffer_translate (framebuffer, -tex_width / 2 - 10, 0, 0);
 
   /* Draw the texture split into two triangles */
-  test_coglbox_triangle_texture (framebuffer, material,
+  test_coglbox_triangle_texture (framebuffer, pipeline,
                                  tex_width, tex_height,
 				 0, 0,
 				 0, 0,
 				 0, 1,
 				 1, 1);
-  test_coglbox_triangle_texture (framebuffer, material,
+  test_coglbox_triangle_texture (framebuffer, pipeline,
                                  tex_width, tex_height,
 				 20, 0,
 				 0, 0,
@@ -251,7 +254,7 @@ test_coglbox_paint (ClutterActor        *self,
 
   cogl_framebuffer_pop_matrix (framebuffer);
 
-  cogl_object_unref (material);
+  cogl_object_unref (pipeline);
 }
 
 static void
diff --git a/src/tests/clutter/interactive/test-events.c b/src/tests/clutter/interactive/test-events.c
index e8408b5e2..03cae26b6 100644
--- a/src/tests/clutter/interactive/test-events.c
+++ b/src/tests/clutter/interactive/test-events.c
@@ -263,19 +263,17 @@ input_cb (ClutterActor *actor,
       break;
     case CLUTTER_BUTTON_PRESS:
       clutter_event_get_position (event, &position);
-      g_print ("[%s] BUTTON PRESS (button:%i, click count:%i coords:%.02f,%.02f device:%s/%s, state:%s)",
+      g_print ("[%s] BUTTON PRESS (button:%i, coords:%.02f,%.02f device:%s/%s, state:%s)",
                clutter_actor_get_name (source_actor),
                clutter_event_get_button (event),
-               clutter_event_get_click_count (event),
                position.x, position.y,
                device_name, source_name, state);
       break;
     case CLUTTER_BUTTON_RELEASE:
       clutter_event_get_position (event, &position);
-      g_print ("[%s] BUTTON RELEASE (button:%i, click count:%i coords:%.02f,%.02f device:%s/%s state:%s)",
+      g_print ("[%s] BUTTON RELEASE (button:%i, coords:%.02f,%.02f device:%s/%s state:%s)",
                clutter_actor_get_name (source_actor),
                clutter_event_get_button (event),
-               clutter_event_get_click_count (event),
                position.x, position.y,
                device_name, source_name, state);
 
@@ -344,6 +342,9 @@ input_cb (ClutterActor *actor,
     case CLUTTER_TOUCHPAD_SWIPE:
       g_print ("[%s] TOUCHPAD SWIPE", clutter_actor_get_name (source_actor));
       break;
+    case CLUTTER_TOUCHPAD_HOLD:
+      g_print ("[%s] TOUCHPAD HOLD", clutter_actor_get_name (source_actor));
+      break;
     case CLUTTER_PROXIMITY_IN:
       g_print ("[%s] PROXIMITY IN", clutter_actor_get_name (source_actor));
       break;
diff --git a/src/tests/clutter/interactive/test-grab.c b/src/tests/clutter/interactive/test-grab.c
index 1de60985b..d7f5eb710 100644
--- a/src/tests/clutter/interactive/test-grab.c
+++ b/src/tests/clutter/interactive/test-grab.c
@@ -41,8 +41,7 @@ debug_event_cb (ClutterActor *actor,
       printf("[%s] LEAVE", source);
       break;
     case CLUTTER_BUTTON_PRESS:
-      printf("[%s] BUTTON PRESS (click count:%i)", 
-	     source, event->button.click_count);
+      printf("[%s] BUTTON PRESS", source);
       break;
     case CLUTTER_BUTTON_RELEASE:
       printf("[%s] BUTTON RELEASE", source);
@@ -68,6 +67,9 @@ debug_event_cb (ClutterActor *actor,
     case CLUTTER_TOUCHPAD_SWIPE:
       g_print ("[%s] TOUCHPAD SWIPE", source);
       break;
+    case CLUTTER_TOUCHPAD_HOLD:
+      g_print ("[%s] TOUCHPAD HOLD", source);
+      break;
     case CLUTTER_PROXIMITY_IN:
       g_print ("[%s] PROXIMITY IN", source);
       break;
diff --git a/src/tests/clutter/interactive/test-stage-sizing.c b/src/tests/clutter/interactive/test-stage-sizing.c
index 020b4be86..2ea14b11d 100644
--- a/src/tests/clutter/interactive/test-stage-sizing.c
+++ b/src/tests/clutter/interactive/test-stage-sizing.c
@@ -71,10 +71,6 @@ test_stage_sizing_main (int argc, char *argv[])
   clutter_actor_add_child (rect, label);
   clutter_actor_add_child (box, rect);
 
-  clutter_stage_set_minimum_size (CLUTTER_STAGE (stage),
-                                  clutter_actor_get_width (box),
-                                  clutter_actor_get_height (box));
-
   clutter_actor_show (stage);
 
   clutter_test_main ();
diff --git a/src/tests/clutter/micro-bench/test-random-text.c b/src/tests/clutter/micro-bench/test-random-text.c
index c5612924f..6843ef80b 100644
--- a/src/tests/clutter/micro-bench/test-random-text.c
+++ b/src/tests/clutter/micro-bench/test-random-text.c
@@ -29,7 +29,7 @@ on_idle (gpointer data)
   static int frame_count = 0;
 
   /* Remove all of the children of the stage */
-  children = clutter_container_get_children (CLUTTER_CONTAINER (stage));
+  children = clutter_actor_get_children (stage);
   for (node = children; node; node = node->next)
     clutter_container_remove_actor (CLUTTER_CONTAINER (stage),
                                     CLUTTER_ACTOR (node->data));
diff --git a/src/tests/meson.build b/src/tests/meson.build
index 9b8d48563..3408d72b9 100644
--- a/src/tests/meson.build
+++ b/src/tests/meson.build
@@ -176,21 +176,6 @@ stage_view_tests = executable('mutter-stage-view-tests',
   install_dir: mutter_installed_tests_libexecdir,
 )
 
-wayland_tests = executable('mutter-wayland-tests',
-  sources: [
-    'meta-wayland-test-driver.c',
-    'meta-wayland-test-driver.h',
-    'wayland-unit-tests.c',
-    test_driver_server_header,
-    test_driver_protocol_code,
-  ],
-  include_directories: tests_includes,
-  c_args: tests_c_args,
-  dependencies: libmutter_test_dep,
-  install: have_installed_tests,
-  install_dir: mutter_installed_tests_libexecdir,
-)
-
 anonymous_file_test = executable('anonymous-file-tests',
   sources: [
     'anonymous-file.c',
@@ -273,6 +258,21 @@ if have_native_tests
     install: have_installed_tests,
     install_dir: mutter_installed_tests_libexecdir,
   )
+
+  wayland_tests = executable('mutter-wayland-tests',
+    sources: [
+      'meta-wayland-test-driver.c',
+      'meta-wayland-test-driver.h',
+      'wayland-unit-tests.c',
+      test_driver_server_header,
+      test_driver_protocol_code,
+    ],
+    include_directories: tests_includes,
+    c_args: tests_c_args,
+    dependencies: libmutter_test_dep,
+    install: have_installed_tests,
+    install_dir: mutter_installed_tests_libexecdir,
+  )
 endif
 
 stacking_tests = [
@@ -297,10 +297,12 @@ stacking_tests = [
   'restore-size',
   'unmaximize-new-size',
   'fullscreen-maximize',
+  'unfullscreen-strut-change',
   'restore-position',
   'default-size',
   'modals',
   'map-fixed-size',
+  'client-resize-respect-constraints',
 ]
 
 foreach stacking_test: stacking_tests
@@ -336,13 +338,6 @@ test('stage-view', stage_view_tests,
   timeout: 60,
 )
 
-test('wayland', wayland_tests,
-  suite: ['core', 'mutter/unit'],
-  env: test_env,
-  is_parallel: false,
-  timeout: 60,
-)
-
 test('anonymous-file', anonymous_file_test,
   suite: ['core', 'mutter/unit'],
   env: test_env,
@@ -378,4 +373,11 @@ if have_native_tests
     is_parallel: false,
     timeout: 60,
   )
+
+  test('wayland', wayland_tests,
+    suite: ['core', 'mutter/unit'],
+    env: test_env,
+    is_parallel: false,
+    timeout: 60,
+  )
 endif
diff --git a/src/tests/meta-context-test.c b/src/tests/meta-context-test.c
index 7ba6c6b51..863c20a98 100644
--- a/src/tests/meta-context-test.c
+++ b/src/tests/meta-context-test.c
@@ -72,10 +72,11 @@ meta_context_test_configure (MetaContext   *context,
     META_CONTEXT_CLASS (meta_context_test_parent_class);
   const char *plugin_name;
 
+  g_test_init (argc, argv, NULL);
+
   if (!context_class->configure (context, argc, argv, error))
     return FALSE;
 
-  g_test_init (argc, argv, NULL);
   g_test_bug_base ("https://gitlab.gnome.org/GNOME/mutter/issues/");
 
   if (priv->flags & META_CONTEXT_TEST_FLAG_TEST_CLIENT)
diff --git a/src/tests/meta-dbus-runner.py b/src/tests/meta-dbus-runner.py
index 2dbf315e1..493510a9a 100755
--- a/src/tests/meta-dbus-runner.py
+++ b/src/tests/meta-dbus-runner.py
@@ -12,19 +12,18 @@ from dbus.mainloop.glib import DBusGMainLoop
 DBusGMainLoop(set_as_default=True)
 
 
-def set_nonblock(fd):
-    '''Set a file object to non-blocking'''
-
-    flags = fcntl.fcntl(fd, fcntl.F_GETFL)
-    fcntl.fcntl(fd, fcntl.F_SETFL, flags | os.O_NONBLOCK)
-
-
 def get_templates_dir():
     return os.path.join(os.path.dirname(__file__), 'dbusmock-templates')
 
 def get_template_path(template_name):
     return os.path.join(get_templates_dir(), template_name + '.py')
 
+def get_subprocess_stdout():
+    if os.getenv('META_DBUS_RUNNER_VERBOSE') == '1':
+        return sys.stderr
+    else:
+        return subprocess.DEVNULL;
+
 
 class MutterDBusTestCase(DBusTestCase):
     @classmethod
@@ -63,8 +62,7 @@ class MutterDBusTestCase(DBusTestCase):
         mock_server, mock_obj = \
             klass.spawn_server_template(template,
                                         params,
-                                        stdout=subprocess.PIPE)
-        set_nonblock(mock_server.stdout)
+                                        get_subprocess_stdout())
 
         mocks = (mock_server, mock_obj)
         assert klass.mocks.setdefault(template, mocks) == mocks
@@ -91,8 +89,7 @@ class MutterDBusTestCase(DBusTestCase):
                                mock_class.MAIN_OBJ,
                                mock_class.MAIN_IFACE,
                                mock_class.SYSTEM_BUS,
-                               stdout=subprocess.PIPE)
-        set_nonblock(mock_server.stdout)
+                               stdout=get_subprocess_stdout())
 
         bus = klass.get_dbus(system_bus=mock_class.SYSTEM_BUS)
         mock_obj = bus.get_object(mock_class.BUS_NAME, mock_class.MAIN_OBJ)
diff --git a/src/tests/meta-wayland-test-driver.c b/src/tests/meta-wayland-test-driver.c
index 0eecf8d45..e8413e0b8 100644
--- a/src/tests/meta-wayland-test-driver.c
+++ b/src/tests/meta-wayland-test-driver.c
@@ -40,6 +40,8 @@ struct _MetaWaylandTestDriver
   GObject parent;
 
   struct wl_global *test_driver;
+
+  GList *resources;
 };
 
 G_DEFINE_TYPE (MetaWaylandTestDriver, meta_wayland_test_driver,
@@ -81,12 +83,14 @@ sync_actor_destroy (struct wl_client   *client,
 static void
 sync_point (struct wl_client   *client,
             struct wl_resource *resource,
-            uint32_t            sequence)
+            uint32_t            sequence,
+            struct wl_resource *surface_resource)
 {
   MetaWaylandTestDriver *test_driver = wl_resource_get_user_data (resource);
 
   g_signal_emit (test_driver, signals[SYNC_POINT], 0,
                  sequence,
+                 surface_resource,
                  client);
 }
 
@@ -95,6 +99,14 @@ static const struct test_driver_interface meta_test_driver_interface = {
   sync_point,
 };
 
+static void
+test_driver_destructor (struct wl_resource *resource)
+{
+  MetaWaylandTestDriver *test_driver = wl_resource_get_user_data (resource);
+
+  test_driver->resources = g_list_remove (test_driver->resources, resource);
+}
+
 static void
 bind_test_driver (struct wl_client *client,
                   void             *user_data,
@@ -107,7 +119,9 @@ bind_test_driver (struct wl_client *client,
   resource = wl_resource_create (client, &test_driver_interface,
                                  version, id);
   wl_resource_set_implementation (resource, &meta_test_driver_interface,
-                                  test_driver, NULL);
+                                  test_driver, test_driver_destructor);
+
+  test_driver->resources = g_list_prepend (test_driver->resources, resource);
 }
 
 static void
@@ -133,8 +147,9 @@ meta_wayland_test_driver_class_init (MetaWaylandTestDriverClass *klass)
                   G_SIGNAL_RUN_LAST,
                   0,
                   NULL, NULL, NULL,
-                  G_TYPE_NONE, 2,
+                  G_TYPE_NONE, 3,
                   G_TYPE_UINT,
+                  G_TYPE_POINTER,
                   G_TYPE_POINTER);
 }
 
@@ -158,3 +173,17 @@ meta_wayland_test_driver_new (MetaWaylandCompositor *compositor)
 
   return test_driver;
 }
+
+void
+meta_wayland_test_driver_emit_sync_event (MetaWaylandTestDriver *test_driver,
+                                          uint32_t               serial)
+{
+  GList *l;
+
+  for (l = test_driver->resources; l; l = l->next)
+    {
+      struct wl_resource *resource = l->data;
+
+      test_driver_send_sync_event (resource, serial);
+    }
+}
diff --git a/src/tests/meta-wayland-test-driver.h b/src/tests/meta-wayland-test-driver.h
index ccbfe1312..6d357650c 100644
--- a/src/tests/meta-wayland-test-driver.h
+++ b/src/tests/meta-wayland-test-driver.h
@@ -27,4 +27,7 @@ G_DECLARE_FINAL_TYPE (MetaWaylandTestDriver, meta_wayland_test_driver,
 
 MetaWaylandTestDriver * meta_wayland_test_driver_new (MetaWaylandCompositor *compositor);
 
+void meta_wayland_test_driver_emit_sync_event (MetaWaylandTestDriver *test_driver,
+                                               uint32_t               serial);
+
 #endif /* META_WAYLAND_TEST_DRIVER_H */
diff --git a/src/tests/monitor-unit-tests.c b/src/tests/monitor-unit-tests.c
index 1b4b201bb..15054fbc3 100644
--- a/src/tests/monitor-unit-tests.c
+++ b/src/tests/monitor-unit-tests.c
@@ -178,6 +178,12 @@ monitor_tests_alarm_filter (MetaX11Display        *x11_display,
                                              x11_display, event);
 }
 
+static void
+on_monitors_changed (gboolean *monitors_changed)
+{
+  *monitors_changed = TRUE;
+}
+
 static void
 create_monitor_test_clients (MetaContext *context)
 {
@@ -4377,6 +4383,7 @@ meta_test_monitor_orientation_changes (void)
   g_autoptr (MetaSensorsProxyAutoResetMock) orientation_mock = NULL;
   g_autoptr (MetaMonitorsConfig) initial_config = NULL;
   g_autoptr (MetaMonitorsConfig) previous_config = NULL;
+  gboolean got_monitors_changed = FALSE;
   MetaOrientation i;
   unsigned int times_signalled = 0;
 
@@ -4391,6 +4398,9 @@ meta_test_monitor_orientation_changes (void)
                 meta_monitor_config_manager_get_previous (config_manager));
   g_set_object (&initial_config,
                 meta_monitor_config_manager_get_current (config_manager));
+  g_signal_connect_swapped (monitor_manager, "monitors-changed",
+                            G_CALLBACK (on_monitors_changed),
+                            &got_monitors_changed);
 
   g_assert_cmpuint (
     meta_orientation_manager_get_orientation (orientation_manager),
@@ -4402,6 +4412,7 @@ meta_test_monitor_orientation_changes (void)
       MetaMonitorsConfig *current;
       MetaMonitorsConfig *previous;
 
+      got_monitors_changed = FALSE;
       meta_sensors_proxy_mock_set_orientation (orientation_mock, i);
       wait_for_orientation (orientation_manager, i, &times_signalled);
       g_assert_cmpuint (times_signalled, <=, 1);
@@ -4413,6 +4424,7 @@ meta_test_monitor_orientation_changes (void)
       current = meta_monitor_config_manager_get_current (config_manager);
       previous = meta_monitor_config_manager_get_previous (config_manager);
 
+      g_assert_true (got_monitors_changed);
       g_assert (previous == previous_config);
       g_assert (current != initial_config);
       g_assert_true (meta_monitors_config_key_equal (current->key,
@@ -4428,6 +4440,7 @@ meta_test_monitor_orientation_changes (void)
   g_set_object (&initial_config,
                 meta_monitor_config_manager_get_current (config_manager));
 
+  got_monitors_changed = FALSE;
   meta_sensors_proxy_mock_set_orientation (orientation_mock,
                                            META_ORIENTATION_NORMAL);
   wait_for_orientation (orientation_manager, META_ORIENTATION_NORMAL,
@@ -4438,6 +4451,7 @@ meta_test_monitor_orientation_changes (void)
                         &test_case, 0, META_ORIENTATION_NORMAL,
                         1024, 768));
 
+  g_assert_false (got_monitors_changed);
   g_assert (meta_monitor_config_manager_get_current (config_manager) ==
             initial_config);
 
@@ -4450,6 +4464,7 @@ meta_test_monitor_orientation_changes (void)
       MetaMonitorsConfig *current;
       MetaMonitorsConfig *previous;
 
+      got_monitors_changed = FALSE;
       meta_sensors_proxy_mock_set_orientation (orientation_mock, i);
       wait_for_orientation (orientation_manager, i, &times_signalled);
       g_assert_cmpuint (times_signalled, <=, 1);
@@ -4464,9 +4479,225 @@ meta_test_monitor_orientation_changes (void)
 
       g_assert (previous == previous_config);
       g_assert (current == initial_config);
+      g_assert_false (got_monitors_changed);
+    }
+
+  g_signal_handlers_disconnect_by_data (monitor_manager, &got_monitors_changed);
+}
+
+static void
+meta_test_monitor_orientation_changes_for_transformed_panel (void)
+{
+  MonitorTestCase test_case = {
+    .setup = {
+      .modes = {
+        {
+          .width = 1024,
+          .height = 768,
+          .refresh_rate = 60.000495910644531
+        }
+      },
+      .n_modes = 1,
+      .outputs = {
+        {
+          .crtc = 0,
+          .modes = { 0 },
+          .n_modes = 1,
+          .preferred_mode = 0,
+          .possible_crtcs = { 0 },
+          .n_possible_crtcs = 1,
+          .width_mm = 222,
+          .height_mm = 125,
+          .is_laptop_panel = TRUE,
+          .panel_orientation_transform = META_MONITOR_TRANSFORM_90,
+        },
+      },
+      .n_outputs = 1,
+      .crtcs = {
+        {
+          .current_mode = 0
+        },
+      },
+      .n_crtcs = 1
+    },
+
+    .expect = {
+      .monitors = {
+        {
+          .outputs = { 0 },
+          .n_outputs = 1,
+          .modes = {
+            {
+              .width = 768,
+              .height = 1024,
+              .refresh_rate = 60.000495910644531,
+              .crtc_modes = {
+                {
+                  .output = 0,
+                  .crtc_mode = 0
+                }
+              }
+            }
+          },
+          .n_modes = 1,
+          .current_mode = 0,
+          .width_mm = 222,
+          .height_mm = 125,
+        }
+      },
+      .n_monitors = 1,
+      .logical_monitors = {
+        {
+          .monitors = { 0 },
+          .n_monitors = 1,
+          .layout = { .x = 0, .y = 0, .width = 1024, .height = 768 },
+          .scale = 1
+        }
+      },
+      .n_logical_monitors = 1,
+      .primary_logical_monitor = 0,
+      .n_outputs = 1,
+      .crtcs = {
+        {
+          .current_mode = 0,
+        }
+      },
+      .n_crtcs = 1,
+      .n_tiled_monitors = 0,
+      .screen_width = 1024,
+      .screen_height = 768
+    }
+  };
+  MetaMonitorTestSetup *test_setup;
+  MetaBackend *backend = meta_get_backend ();
+  MetaMonitorManager *monitor_manager =
+    meta_backend_get_monitor_manager (backend);
+  MetaMonitorConfigManager *config_manager = monitor_manager->config_manager;
+  MetaOrientationManager *orientation_manager =
+    meta_backend_get_orientation_manager (backend);
+  g_autoptr (ClutterAutoRemoveInputDevice) touch_device = NULL;
+  g_autoptr (MetaSensorsProxyAutoResetMock) orientation_mock = NULL;
+  g_autoptr (MetaMonitorsConfig) initial_config = NULL;
+  g_autoptr (MetaMonitorsConfig) previous_config = NULL;
+  gboolean got_monitors_changed = FALSE;
+  MetaOrientation i;
+  unsigned int times_signalled = 0;
+
+  g_test_message ("%s", G_STRFUNC);
+  orientation_mock = meta_sensors_proxy_mock_get ();
+  touch_device = meta_test_add_touch_device (backend);
+  test_setup = create_monitor_test_setup (&test_case.setup,
+                                          MONITOR_TEST_FLAG_NO_STORED);
+  emulate_hotplug (test_setup);
+
+  g_set_object (&previous_config,
+                meta_monitor_config_manager_get_previous (config_manager));
+  g_set_object (&initial_config,
+                meta_monitor_config_manager_get_current (config_manager));
+  g_signal_connect_swapped (monitor_manager, "monitors-changed",
+                            G_CALLBACK (on_monitors_changed),
+                            &got_monitors_changed);
+
+  g_assert_cmpuint (
+    meta_orientation_manager_get_orientation (orientation_manager),
+    ==,
+    META_ORIENTATION_UNDEFINED);
+
+  for (i = META_N_ORIENTATIONS - 1; i > META_ORIENTATION_UNDEFINED; i--)
+    {
+      MetaMonitorsConfig *current;
+      MetaMonitorsConfig *previous;
+
+      got_monitors_changed = FALSE;
+      meta_sensors_proxy_mock_set_orientation (orientation_mock, i);
+      wait_for_orientation (orientation_manager, i, &times_signalled);
+      g_assert_cmpuint (times_signalled, <=, 1);
+
+      META_TEST_LOG_CALL ("Checking configuration per orientation",
+                          check_monitor_configuration_per_orientation (
+                            &test_case, 0, i, 1024, 768));
+
+      current = meta_monitor_config_manager_get_current (config_manager);
+      previous = meta_monitor_config_manager_get_previous (config_manager);
+
+      g_assert_true (got_monitors_changed);
+      g_assert (previous == previous_config);
+      g_assert (current != initial_config);
       g_assert_true (meta_monitors_config_key_equal (current->key,
                                                      initial_config->key));
     }
+
+  /* Ensure applying the current orientation doesn't change the config */
+  g_assert_cmpuint (
+    meta_orientation_manager_get_orientation (orientation_manager),
+    ==,
+    META_ORIENTATION_NORMAL);
+
+  g_set_object (&initial_config,
+                meta_monitor_config_manager_get_current (config_manager));
+
+  got_monitors_changed = FALSE;
+  meta_sensors_proxy_mock_set_orientation (orientation_mock,
+                                           META_ORIENTATION_NORMAL);
+  wait_for_orientation (orientation_manager, META_ORIENTATION_NORMAL,
+                        &times_signalled);
+  g_assert_cmpuint (times_signalled, ==, 0);
+  META_TEST_LOG_CALL ("Checking configuration per orientation",
+                      check_monitor_configuration_per_orientation (
+                        &test_case, 0, META_ORIENTATION_NORMAL,
+                        1024, 768));
+
+  g_assert_false (got_monitors_changed);
+  g_assert (meta_monitor_config_manager_get_current (config_manager) ==
+            initial_config);
+
+  /* When no touch device is available, the orientation changes are ignored */
+  g_test_message ("Removing touch device");
+  meta_backend_test_remove_device (META_BACKEND_TEST (backend), touch_device);
+
+  for (i = META_N_ORIENTATIONS - 1; i > META_ORIENTATION_UNDEFINED; i--)
+    {
+      MetaMonitorsConfig *current;
+      MetaMonitorsConfig *previous;
+
+      got_monitors_changed = FALSE;
+      meta_sensors_proxy_mock_set_orientation (orientation_mock, i);
+      wait_for_orientation (orientation_manager, i, &times_signalled);
+      g_assert_cmpuint (times_signalled, <=, 1);
+
+      META_TEST_LOG_CALL ("Checking configuration per orientation",
+                          check_monitor_configuration_per_orientation (
+                            &test_case, 0, META_ORIENTATION_NORMAL,
+                            1024, 768));
+
+      current = meta_monitor_config_manager_get_current (config_manager);
+      previous = meta_monitor_config_manager_get_previous (config_manager);
+
+      g_assert (previous == previous_config);
+      g_assert (current == initial_config);
+      g_assert_false (got_monitors_changed);
+    }
+
+  g_assert_cmpuint (
+    meta_orientation_manager_get_orientation (orientation_manager),
+    ==,
+    META_ORIENTATION_NORMAL);
+
+  meta_test_add_touch_device (backend);
+  got_monitors_changed = FALSE;
+  meta_sensors_proxy_mock_set_orientation (orientation_mock,
+                                           META_ORIENTATION_RIGHT_UP);
+  wait_for_orientation (orientation_manager,
+                        META_ORIENTATION_RIGHT_UP,
+                        &times_signalled);
+  g_assert_cmpuint (times_signalled, <=, 1);
+  META_TEST_LOG_CALL ("Checking configuration per orientation",
+                      check_monitor_configuration_per_orientation (
+                        &test_case, 0, META_ORIENTATION_RIGHT_UP,
+                        1024, 768));
+  g_assert_true (got_monitors_changed);
+
+  g_signal_handlers_disconnect_by_data (monitor_manager, &got_monitors_changed);
 }
 
 static void
@@ -8613,6 +8844,8 @@ init_monitor_tests (void)
                     meta_test_monitor_orientation_initial_stored_rotated_no_touch);
   add_monitor_test ("/backends/monitor/orientation/changes",
                     meta_test_monitor_orientation_changes);
+  add_monitor_test ("/backends/monitor/orientation/changes-transformed-panel",
+                    meta_test_monitor_orientation_changes_for_transformed_panel);
   add_monitor_test ("/backends/monitor/orientation/changes-with-hotplugging",
                     meta_test_monitor_orientation_changes_with_hotplugging);
 
diff --git a/src/tests/mutter-all.test.in b/src/tests/mutter-all.test.in
index 413d2acd5..f99dc29da 100644
--- a/src/tests/mutter-all.test.in
+++ b/src/tests/mutter-all.test.in
@@ -1,6 +1,9 @@
 [Test]
 Description=All Mutter tests
-TestEnvironment=GSETTINGS_BACKEND=memory;
-Exec=sh -c 'env XDG_RUNTIME_DIR="$(mktemp -d -t mutter-@apiversion@-all-tests-XXXXXX)" @libexecdir@/installed-tests/mutter-@apiversion@/meta-dbus-runner.py xvfb-run -a -s "+iglx -noreset" -- @libexecdir@/installed-tests/mutter-@apiversion@/mutter-test-runner --all'
+# Can't use TestEnvironment for GSETTINGS_BACKEND=memory until there's
+# a solution for
+# https://gitlab.gnome.org/GNOME/gnome-desktop-testing/-/issues/1,
+# and anyway that wouldn't be sufficient to handle XDG_RUNTIME_DIR
+Exec=sh -ec 'env GSETTINGS_BACKEND=memory XDG_RUNTIME_DIR="$(mktemp -d -t mutter-@apiversion@-all-tests-XXXXXX)" @libexecdir@/installed-tests/mutter-@apiversion@/meta-dbus-runner.py xvfb-run -a -s "+iglx -noreset" -- @libexecdir@/installed-tests/mutter-@apiversion@/mutter-test-runner --all'
 Type=session
 Output=TAP
diff --git a/src/tests/stacking/client-resize-respect-constraints.metatest b/src/tests/stacking/client-resize-respect-constraints.metatest
new file mode 100644
index 000000000..021e0ed0e
--- /dev/null
+++ b/src/tests/stacking/client-resize-respect-constraints.metatest
@@ -0,0 +1,43 @@
+# Tests that constraints are applied after a client initiated resize
+#  1. Create a window that does not extend beyond the screen
+#  2. Move it to a known position 
+#  3. Resize such that the following resize will extend beyond the screen
+#  4. Check that the window was moved to the position that would allow it to fit on the screen
+
+new_client w wayland
+create w/1 csd
+
+resize w/1 500 400
+show w/1
+wait
+
+assert_size w/1 500 400
+
+move w/1 300 200
+assert_position w/1 300 200
+
+resize w/1 600 500
+wait_reconfigure
+assert_position w/1 200 100
+
+destroy w/1
+
+
+new_client x x11
+create x/1 csd
+
+resize x/1 500 400
+show x/1
+wait
+
+assert_size x/1 500 400
+
+move x/1 300 200
+assert_position x/1 300 200
+
+resize x/1 600 500
+wait_reconfigure
+assert_position x/1 200 100
+
+destroy x/1
+
diff --git a/src/tests/stacking/unfullscreen-strut-change.metatest b/src/tests/stacking/unfullscreen-strut-change.metatest
new file mode 100644
index 000000000..1a0005428
--- /dev/null
+++ b/src/tests/stacking/unfullscreen-strut-change.metatest
@@ -0,0 +1,49 @@
+# Tests that the following works, both on Wayland and X11
+#  1. Create a window with a known size
+#  2. Fullscreen window results in fullscreen size
+#  3. Unfullscreen window followed by a strut change returns to known size
+
+new_client w wayland
+create w/1 csd
+
+resize w/1 500 400
+show w/1
+wait
+
+assert_size w/1 500 400
+
+fullscreen w/1
+wait_reconfigure
+assert_size w/1 MONITOR_WIDTH MONITOR_HEIGHT
+
+stop_after_next w
+unfullscreen w/1
+wait
+set_strut 0 0 1 1 top
+continue w
+wait_reconfigure
+assert_size w/1 500 400
+
+clear_struts
+wait
+
+new_client x x11
+create x/1 csd
+
+resize x/1 500 400
+show x/1
+wait
+
+assert_size x/1 500 400
+
+fullscreen x/1
+wait_reconfigure
+assert_size x/1 MONITOR_WIDTH MONITOR_HEIGHT
+
+stop_after_next x
+unfullscreen x/1
+wait
+set_strut 0 0 1 1 top
+continue x
+wait_reconfigure
+assert_size x/1 500 400
diff --git a/src/tests/test-client.c b/src/tests/test-client.c
index 73931375e..0007d61ea 100644
--- a/src/tests/test-client.c
+++ b/src/tests/test-client.c
@@ -34,6 +34,7 @@ GHashTable *windows;
 GQuark event_source_quark;
 GQuark event_handlers_quark;
 GQuark can_take_focus_quark;
+gboolean sync_after_lines = -1;
 
 typedef void (*XEventHandler) (GtkWidget *window, XEvent *event);
 
@@ -824,6 +825,26 @@ process_line (const char *line)
           goto out;
         }
     }
+  else if (strcmp (argv[0], "stop_after_next") == 0)
+    {
+      if (sync_after_lines != -1)
+        {
+          g_print ("Can't invoke 'stop_after_next' while already stopped");
+          goto out;
+        }
+
+      sync_after_lines = 1;
+    }
+  else if (strcmp (argv[0], "continue") == 0)
+    {
+      if (sync_after_lines != 0)
+        {
+          g_print ("Can only invoke 'continue' while stopped");
+          goto out;
+        }
+
+      sync_after_lines = -1;
+    }
   else
     {
       g_print ("Unknown command %s\n", argv[0]);
@@ -862,6 +883,30 @@ on_line_received (GObject      *source,
 static void
 read_next_line (GDataInputStream *in)
 {
+  while (sync_after_lines == 0)
+    {
+      GdkDisplay *display = gdk_display_get_default ();
+      g_autoptr (GError) error = NULL;
+      g_autofree char *line = NULL;
+      size_t length;
+
+      gdk_display_flush (display);
+
+      line = g_data_input_stream_read_line (in, &length, NULL, &error);
+      if (!line)
+        {
+          if (error)
+            g_printerr ("Error reading from stdin: %s\n", error->message);
+          gtk_main_quit ();
+          return;
+        }
+
+      process_line (line);
+    }
+
+  if (sync_after_lines >= 0)
+    sync_after_lines--;
+
   g_data_input_stream_read_line_async (in, G_PRIORITY_DEFAULT, NULL,
                                        on_line_received, NULL);
 }
@@ -890,6 +935,8 @@ main(int argc, char **argv)
   GtkCssProvider *provider;
   GError *error = NULL;
 
+  g_log_writer_default_set_use_stderr (TRUE);
+
   g_option_context_add_main_entries (context, options, NULL);
 
   if (!g_option_context_parse (context,
diff --git a/src/tests/test-runner.c b/src/tests/test-runner.c
index bdf2ef109..edaf84f81 100644
--- a/src/tests/test-runner.c
+++ b/src/tests/test-runner.c
@@ -28,6 +28,7 @@
 #include "meta-test/meta-context-test.h"
 #include "meta/util.h"
 #include "meta/window.h"
+#include "meta/meta-workspace-manager.h"
 #include "tests/meta-test-utils.h"
 #include "ui/ui.h"
 #include "wayland/meta-wayland.h"
@@ -810,6 +811,64 @@ test_case_do (TestCase *test,
       if (!test_case_sleep (test, (guint32) interval, error))
         return FALSE;
     }
+  else if (strcmp (argv[0], "set_strut") == 0)
+    {
+      if (argc != 6)
+        BAD_COMMAND("usage: %s <x> <y> <width> <height> <side>", argv[0]);
+
+      int x = atoi (argv[1]);
+      int y = atoi (argv[2]);
+      int width = atoi (argv[3]);
+      int height = atoi (argv[4]);
+
+      MetaSide side;
+      if (strcmp (argv[5], "left") == 0)
+        side = META_SIDE_LEFT;
+      else if (strcmp (argv[5], "right") == 0)
+        side = META_SIDE_RIGHT;
+      else if (strcmp (argv[5], "top") == 0)
+        side = META_SIDE_TOP;
+      else if (strcmp (argv[5], "bottom") == 0)
+        side = META_SIDE_BOTTOM;
+      else
+        return FALSE;
+
+      MetaDisplay *display = meta_get_display ();
+      MetaWorkspaceManager *workspace_manager =
+        meta_display_get_workspace_manager (display);
+      MetaRectangle rect = { x, y, width, height };
+      MetaStrut strut = { rect, side };
+      GSList *struts = g_slist_append (NULL, &strut);
+      GList *workspaces =
+        meta_workspace_manager_get_workspaces (workspace_manager);
+      GList *l;
+
+      for (l = workspaces; l; l = l->next)
+        {
+          MetaWorkspace *workspace = l->data;
+          meta_workspace_set_builtin_struts (workspace, struts);
+        }
+
+      g_slist_free (struts);
+    }
+  else if (strcmp (argv[0], "clear_struts") == 0)
+    {
+      if (argc != 1)
+        BAD_COMMAND("usage: %s", argv[0]);
+
+      MetaDisplay *display = meta_get_display ();
+      MetaWorkspaceManager *workspace_manager =
+        meta_display_get_workspace_manager (display);
+      GList *workspaces =
+        meta_workspace_manager_get_workspaces (workspace_manager);
+      GList *l;
+
+      for (l = workspaces; l; l = l->next)
+        {
+          MetaWorkspace *workspace = l->data;
+          meta_workspace_set_builtin_struts (workspace, NULL);
+        }
+    }
   else if (strcmp (argv[0], "assert_stacking") == 0)
     {
       if (!test_case_assert_stacking (test, argv + 1, argc - 1, error))
@@ -901,6 +960,19 @@ test_case_do (TestCase *test,
           return FALSE;
         }
     }
+  else if (strcmp (argv[0], "stop_after_next") == 0 ||
+           strcmp (argv[0], "continue") == 0)
+    {
+      if (argc != 2)
+        BAD_COMMAND("usage: %s <client-id>", argv[0]);
+
+      MetaTestClient *client = test_case_lookup_client (test, argv[1], error);
+      if (!client)
+        return FALSE;
+
+      if (!meta_test_client_do (client, error, argv[0], NULL))
+        return FALSE;
+    }
   else
     {
       BAD_COMMAND("Unknown command %s", argv[0]);
diff --git a/src/tests/unit-tests.c b/src/tests/unit-tests.c
index 0dba16535..dfad2bdc7 100644
--- a/src/tests/unit-tests.c
+++ b/src/tests/unit-tests.c
@@ -239,10 +239,12 @@ int
 main (int argc, char *argv[])
 {
   g_autoptr (MetaContext) context = NULL;
+  g_autoptr (GError) error = NULL;
 
   context = meta_create_test_context (META_CONTEXT_TEST_TYPE_NESTED,
                                       META_CONTEXT_TEST_FLAG_TEST_CLIENT);
-  g_assert (meta_context_configure (context, &argc, &argv, NULL));
+  if (!meta_context_configure (context, &argc, &argv, &error))
+    g_error ("Failed to configure test context: %s", error->message);
 
   test_context = context;
 
diff --git a/src/tests/wayland-test-clients/invalid-xdg-shell-actions.c b/src/tests/wayland-test-clients/invalid-xdg-shell-actions.c
index 67ff3671e..da9a6b971 100644
--- a/src/tests/wayland-test-clients/invalid-xdg-shell-actions.c
+++ b/src/tests/wayland-test-clients/invalid-xdg-shell-actions.c
@@ -173,10 +173,17 @@ handle_xdg_surface_configure (void               *data,
                               struct xdg_surface *xdg_surface,
                               uint32_t            serial)
 {
+  static gboolean sent_invalid_once = FALSE;
+
+  if (sent_invalid_once)
+    return;
+
   xdg_surface_set_window_geometry (xdg_surface, 0, 0, 0, 0);
   draw_main ();
   wl_surface_commit (surface);
 
+  sent_invalid_once = TRUE;
+
   g_assert_cmpint (wl_display_roundtrip (display), !=, -1);
   running = FALSE;
 }
diff --git a/src/tests/wayland-test-clients/meson.build b/src/tests/wayland-test-clients/meson.build
index 51fe52061..2b3c83389 100644
--- a/src/tests/wayland-test-clients/meson.build
+++ b/src/tests/wayland-test-clients/meson.build
@@ -48,6 +48,7 @@ common_sources = [
 wayland_test_clients = [
   'subsurface-remap-toplevel',
   'subsurface-reparenting',
+  'subsurface-parent-unmapped',
   'invalid-subsurfaces',
   'invalid-xdg-shell-actions',
   'xdg-apply-limits',
diff --git a/src/tests/wayland-test-clients/subsurface-parent-unmapped.c b/src/tests/wayland-test-clients/subsurface-parent-unmapped.c
new file mode 100644
index 000000000..0618e65c0
--- /dev/null
+++ b/src/tests/wayland-test-clients/subsurface-parent-unmapped.c
@@ -0,0 +1,494 @@
+/*
+ * Copyright (C) 2019 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "config.h"
+
+#include <glib.h>
+#include <linux/input-event-codes.h>
+#include <sys/mman.h>
+#include <unistd.h>
+#include <wayland-client.h>
+
+#include "wayland-test-client-utils.h"
+
+#include "test-driver-client-protocol.h"
+#include "xdg-shell-client-protocol.h"
+
+static struct wl_display *display;
+static struct wl_registry *registry;
+static struct wl_compositor *compositor;
+static struct wl_subcompositor *subcompositor;
+static struct xdg_wm_base *xdg_wm_base;
+static struct wl_shm *shm;
+static struct wl_seat *seat;
+static struct wl_pointer *pointer;
+static struct test_driver *test_driver;
+
+static struct wl_surface *toplevel_surface;
+static struct xdg_surface *toplevel_xdg_surface;
+static struct xdg_toplevel *xdg_toplevel;
+
+static struct wl_surface *popup_surface;
+static struct xdg_surface *popup_xdg_surface;
+static struct xdg_popup *xdg_popup;
+
+static struct wl_surface *subsurface_surface;
+static struct wl_subsurface *subsurface;
+
+static void
+handle_buffer_release (void             *data,
+                       struct wl_buffer *buffer)
+{
+  wl_buffer_destroy (buffer);
+}
+
+static const struct wl_buffer_listener buffer_listener = {
+  handle_buffer_release
+};
+
+static gboolean
+create_shm_buffer (int                width,
+                   int                height,
+                   struct wl_buffer **out_buffer,
+                   void             **out_data,
+                   int               *out_size)
+{
+  struct wl_shm_pool *pool;
+  static struct wl_buffer *buffer;
+  int fd, size, stride;
+  int bytes_per_pixel;
+  void *data;
+
+  bytes_per_pixel = 4;
+  stride = width * bytes_per_pixel;
+  size = stride * height;
+
+  fd = create_anonymous_file (size);
+  if (fd < 0)
+    {
+      fprintf (stderr, "Creating a buffer file for %d B failed: %m\n",
+               size);
+      return FALSE;
+    }
+
+  data = mmap (NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+  if (data == MAP_FAILED)
+    {
+      fprintf (stderr, "mmap failed: %m\n");
+      close (fd);
+      return FALSE;
+    }
+
+  pool = wl_shm_create_pool (shm, fd, size);
+  buffer = wl_shm_pool_create_buffer (pool, 0,
+                                      width, height,
+                                      stride,
+                                      WL_SHM_FORMAT_ARGB8888);
+  wl_buffer_add_listener (buffer, &buffer_listener, buffer);
+  wl_shm_pool_destroy (pool);
+  close (fd);
+
+  *out_buffer = buffer;
+  *out_data = data;
+  *out_size = size;
+
+  return TRUE;
+}
+
+static void
+fill (void    *buffer_data,
+      int      width,
+      int      height,
+      uint32_t color)
+{
+  uint32_t *pixels = buffer_data;
+  int x, y;
+
+  for (y = 0; y < height; y++)
+    {
+      for (x = 0; x < width; x++)
+        pixels[y * width + x] = color;
+    }
+}
+
+static void
+draw (struct wl_surface *surface,
+      int                width,
+      int                height,
+      uint32_t           color)
+{
+  struct wl_buffer *buffer;
+  void *buffer_data;
+  int size;
+
+  if (!create_shm_buffer (width, height,
+                          &buffer, &buffer_data, &size))
+    g_error ("Failed to create shm buffer");
+
+  fill (buffer_data, width, height, color);
+
+  wl_surface_attach (surface, buffer, 0, 0);
+}
+
+static void
+draw_main (void)
+{
+  draw (toplevel_surface, 200, 200, 0xff00ffff);
+}
+
+static void
+draw_popup (void)
+{
+  draw (popup_surface, 100, 100, 0xff005500);
+}
+
+static void
+draw_subsurface (void)
+{
+  draw (subsurface_surface, 100, 50, 0xff001f00);
+}
+
+static void
+handle_xdg_toplevel_configure (void                *data,
+                               struct xdg_toplevel *xdg_toplevel,
+                               int32_t              width,
+                               int32_t              height,
+                               struct wl_array     *state)
+{
+}
+
+static void
+handle_xdg_toplevel_close(void                *data,
+                          struct xdg_toplevel *xdg_toplevel)
+{
+  g_assert_not_reached ();
+}
+
+static const struct xdg_toplevel_listener xdg_toplevel_listener = {
+  handle_xdg_toplevel_configure,
+  handle_xdg_toplevel_close,
+};
+
+static void
+handle_toplevel_xdg_surface_configure (void               *data,
+                                       struct xdg_surface *xdg_surface,
+                                       uint32_t            serial)
+{
+  xdg_surface_ack_configure (xdg_surface, serial);
+  draw_main ();
+  wl_surface_commit (toplevel_surface);
+  wl_display_flush (display);
+}
+
+static const struct xdg_surface_listener toplevel_xdg_surface_listener = {
+  handle_toplevel_xdg_surface_configure,
+};
+
+static void
+handle_xdg_wm_base_ping (void               *data,
+                         struct xdg_wm_base *xdg_wm_base,
+                         uint32_t            serial)
+{
+  xdg_wm_base_pong (xdg_wm_base, serial);
+}
+
+static const struct xdg_wm_base_listener xdg_wm_base_listener = {
+  handle_xdg_wm_base_ping,
+};
+
+static void
+pointer_handle_enter (void              *data,
+                      struct wl_pointer *pointer,
+                      uint32_t           serial,
+                      struct wl_surface *surface,
+                      wl_fixed_t         sx,
+                      wl_fixed_t         sy)
+{
+}
+
+static void
+pointer_handle_leave (void              *data,
+                      struct wl_pointer *pointer,
+                      uint32_t           serial,
+                      struct wl_surface *surface)
+{
+}
+
+static void
+pointer_handle_motion (void              *data,
+                       struct wl_pointer *pointer,
+                       uint32_t           time,
+                       wl_fixed_t         sx,
+                       wl_fixed_t         sy)
+{
+}
+
+static void
+handle_popup_frame_callback (void               *data,
+                             struct wl_callback *callback,
+                             uint32_t            time)
+{
+  wl_callback_destroy (callback);
+  test_driver_sync_point (test_driver, 0, popup_surface);
+}
+
+static const struct wl_callback_listener frame_listener = {
+  handle_popup_frame_callback,
+};
+
+static void
+handle_popup_xdg_surface_configure (void               *data,
+                                    struct xdg_surface *xdg_surface,
+                                    uint32_t            serial)
+{
+  struct wl_callback *frame_callback;
+
+  draw_popup ();
+
+  draw_subsurface ();
+  wl_surface_commit (subsurface_surface);
+
+  xdg_surface_ack_configure (xdg_surface, serial);
+  frame_callback = wl_surface_frame (popup_surface);
+  wl_callback_add_listener (frame_callback, &frame_listener, NULL);
+  wl_surface_commit (popup_surface);
+  wl_display_flush (display);
+}
+
+static const struct xdg_surface_listener popup_xdg_surface_listener = {
+  handle_popup_xdg_surface_configure,
+};
+
+static void
+pointer_handle_button (void              *data,
+                       struct wl_pointer *pointer,
+                       uint32_t           serial,
+                       uint32_t           time,
+                       uint32_t           button,
+                       uint32_t           state)
+{
+  struct xdg_positioner *positioner;
+  static int click_count = 0;
+
+  if (button != BTN_LEFT || state != 1)
+    return;
+
+  /* Create a grabbing popup surface */
+  popup_xdg_surface = xdg_wm_base_get_xdg_surface (xdg_wm_base,
+                                                   popup_surface);
+  xdg_surface_add_listener (popup_xdg_surface,
+                            &popup_xdg_surface_listener, NULL);
+  positioner = xdg_wm_base_create_positioner (xdg_wm_base);
+  xdg_positioner_set_size (positioner, 100, 100);
+  xdg_positioner_set_anchor_rect (positioner, 0, 0, 1, 1);
+  xdg_popup = xdg_surface_get_popup (popup_xdg_surface, toplevel_xdg_surface,
+                                     positioner);
+  xdg_positioner_destroy (positioner);
+  xdg_popup_grab (xdg_popup, seat, serial);
+  wl_surface_commit (popup_surface);
+
+  if (click_count == 1)
+    {
+      /* This ensure that the second time the popup is opened, the commit
+       * is handled accurately. This passing verifies we don't reproduce
+       * https://gitlab.gnome.org/GNOME/mutter/-/issues/1828.
+       */
+      wl_display_roundtrip (display);
+      exit (EXIT_SUCCESS);
+    }
+
+  click_count++;
+}
+
+static void
+pointer_handle_axis (void              *data,
+                     struct wl_pointer *pointer,
+                     uint32_t           time,
+                     uint32_t           axis,
+                     wl_fixed_t         value)
+{
+}
+
+static const struct wl_pointer_listener pointer_listener = {
+  pointer_handle_enter,
+  pointer_handle_leave,
+  pointer_handle_motion,
+  pointer_handle_button,
+  pointer_handle_axis,
+};
+
+static void
+seat_handle_capabilities (void                    *data,
+                          struct wl_seat          *wl_seat,
+                          enum wl_seat_capability  caps)
+{
+  if (caps & WL_SEAT_CAPABILITY_POINTER)
+    {
+      pointer = wl_seat_get_pointer (wl_seat);
+      wl_pointer_add_listener (pointer, &pointer_listener, NULL);
+    }
+}
+
+static void
+seat_handle_name (void           *data,
+                  struct wl_seat *seat,
+                  const char     *name)
+{
+}
+
+static const struct wl_seat_listener seat_listener = {
+  seat_handle_capabilities,
+  seat_handle_name,
+};
+
+static void
+test_driver_handle_sync_event (void               *data,
+                               struct test_driver *test_driver,
+                               uint32_t            serial)
+{
+  g_assert (serial == 0);
+
+  /* Sync event 0 is sent when the popup window actor is destryed;
+   * prepare for opening a popup for the same wl_surface.
+   */
+  wl_surface_attach (popup_surface, NULL, 0, 0);
+  wl_surface_commit (popup_surface);
+  g_clear_pointer (&xdg_popup, xdg_popup_destroy);
+  g_clear_pointer (&popup_xdg_surface, xdg_surface_destroy);
+
+  /* This will trigger a click again, opening the popup a second time. */
+  test_driver_sync_point (test_driver, 1, toplevel_surface);
+}
+
+static const struct test_driver_listener test_driver_listener = {
+  test_driver_handle_sync_event,
+};
+
+static void
+handle_registry_global (void               *data,
+                        struct wl_registry *registry,
+                        uint32_t            id,
+                        const char         *interface,
+                        uint32_t            version)
+{
+  if (strcmp (interface, "wl_compositor") == 0)
+    {
+      compositor = wl_registry_bind (registry, id, &wl_compositor_interface, 1);
+    }
+  else if (strcmp (interface, "wl_subcompositor") == 0)
+    {
+      subcompositor = wl_registry_bind (registry,
+                                        id, &wl_subcompositor_interface, 1);
+    }
+  else if (strcmp (interface, "xdg_wm_base") == 0)
+    {
+      xdg_wm_base = wl_registry_bind (registry, id,
+                                      &xdg_wm_base_interface, 1);
+      xdg_wm_base_add_listener (xdg_wm_base, &xdg_wm_base_listener, NULL);
+    }
+  else if (strcmp (interface, "wl_shm") == 0)
+    {
+      shm = wl_registry_bind (registry,
+                              id, &wl_shm_interface, 1);
+    }
+  else if (strcmp (interface, "wl_seat") == 0)
+    {
+      seat = wl_registry_bind (registry, id, &wl_seat_interface, 1);
+      wl_seat_add_listener (seat, &seat_listener, NULL);
+    }
+  else if (strcmp (interface, "test_driver") == 0)
+    {
+      test_driver = wl_registry_bind (registry, id, &test_driver_interface, 1);
+      test_driver_add_listener (test_driver, &test_driver_listener, NULL);
+    }
+}
+
+static void
+handle_registry_global_remove (void               *data,
+                               struct wl_registry *registry,
+                               uint32_t            name)
+{
+}
+
+static const struct wl_registry_listener registry_listener = {
+  handle_registry_global,
+  handle_registry_global_remove
+};
+
+int
+main (int    argc,
+      char **argv)
+{
+  display = wl_display_connect (NULL);
+  registry = wl_display_get_registry (display);
+  wl_registry_add_listener (registry, &registry_listener, NULL);
+  wl_display_roundtrip (display);
+
+  if (!shm)
+    {
+      fprintf (stderr, "No wl_shm global\n");
+      return EXIT_FAILURE;
+    }
+
+  if (!xdg_wm_base)
+    {
+      fprintf (stderr, "No xdg_wm_base global\n");
+      return EXIT_FAILURE;
+    }
+
+  wl_display_roundtrip (display);
+
+  g_assert_nonnull (test_driver);
+
+  /*
+   * This test case does the following:
+   *
+   *  1) Open a toplevel
+   *  2) Open a popup in response to a pointer click
+   *  3) Place a subsurface on that popup
+   *  4) After painting, get the popup dismissed by the compositor
+   *  5) Once the popup window actor is destroyed, trigger a new pointer click
+   *  6) Open the popup again using the same wl_surface, thus with the same
+   *     subsurface association set up.
+   */
+
+  toplevel_surface = wl_compositor_create_surface (compositor);
+  toplevel_xdg_surface = xdg_wm_base_get_xdg_surface (xdg_wm_base,
+                                                      toplevel_surface);
+  xdg_surface_add_listener (toplevel_xdg_surface,
+                            &toplevel_xdg_surface_listener, NULL);
+  xdg_toplevel = xdg_surface_get_toplevel (toplevel_xdg_surface);
+  xdg_toplevel_add_listener (xdg_toplevel, &xdg_toplevel_listener, NULL);
+  xdg_toplevel_set_title (xdg_toplevel, "subsurface-parent-unmapped");
+  wl_surface_commit (toplevel_surface);
+
+  popup_surface = wl_compositor_create_surface (compositor);
+  subsurface_surface = wl_compositor_create_surface (compositor);
+  subsurface = wl_subcompositor_get_subsurface (subcompositor,
+                                                subsurface_surface,
+                                                popup_surface);
+  wl_subsurface_set_position (subsurface, 0, 0);
+  wl_subsurface_set_desync (subsurface);
+
+  while (TRUE)
+    {
+      if (wl_display_dispatch (display) == -1)
+        return EXIT_FAILURE;
+    }
+
+  return EXIT_SUCCESS;
+}
diff --git a/src/tests/wayland-test-clients/test-driver.xml b/src/tests/wayland-test-clients/test-driver.xml
index 2433cf111..763e1f674 100644
--- a/src/tests/wayland-test-clients/test-driver.xml
+++ b/src/tests/wayland-test-clients/test-driver.xml
@@ -8,6 +8,11 @@
 
     <request name="sync_point">
       <arg name="sequence" type="uint"/>
+      <arg name="surface" type="object" interface="wl_surface" allow-null="true"/>
     </request>
+
+    <event name="sync_event">
+      <arg name="sequence" type="uint"/>
+    </event>
   </interface>
 </protocol>
diff --git a/src/tests/wayland-test-clients/xdg-apply-limits.c b/src/tests/wayland-test-clients/xdg-apply-limits.c
index aa5ab6e70..80fca5798 100644
--- a/src/tests/wayland-test-clients/xdg-apply-limits.c
+++ b/src/tests/wayland-test-clients/xdg-apply-limits.c
@@ -216,8 +216,8 @@ handle_xdg_toplevel_configure (void                *data,
 }
 
 static void
-handle_xdg_toplevel_close(void                *data,
-                          struct xdg_toplevel *xdg_toplevel)
+handle_xdg_toplevel_close (void                *data,
+                           struct xdg_toplevel *xdg_toplevel)
 {
   g_assert_not_reached ();
 }
@@ -236,7 +236,7 @@ handle_frame_callback (void               *data,
     {
     case STATE_WAIT_FOR_FRAME_1:
       reset_surface ();
-      test_driver_sync_point (test_driver, 1);
+      test_driver_sync_point (test_driver, 1, NULL);
       break;
     case STATE_WAIT_FOR_FRAME_2:
       exit (EXIT_SUCCESS);
@@ -371,7 +371,7 @@ main (int    argc,
 
   wl_display_roundtrip (display);
 
-  // g_assert_nonnull (test_driver);
+  g_assert_nonnull (test_driver);
 
   surface = wl_compositor_create_surface (compositor);
   xdg_surface = xdg_wm_base_get_xdg_surface (xdg_wm_base, surface);
@@ -391,11 +391,11 @@ main (int    argc,
   state = STATE_WAIT_FOR_CONFIGURE_1;
 
   /* set minimum and maximum size and commit */
-  xdg_toplevel_set_min_size(xdg_toplevel, 700, 500);
-  xdg_toplevel_set_max_size(xdg_toplevel, 700, 500);
+  xdg_toplevel_set_min_size (xdg_toplevel, 700, 500);
+  xdg_toplevel_set_max_size (xdg_toplevel, 700, 500);
   wl_surface_commit (surface);
 
-  test_driver_sync_point (test_driver, 0);
+  test_driver_sync_point (test_driver, 0, NULL);
 
   running = TRUE;
   while (running)
diff --git a/src/tests/wayland-unit-tests.c b/src/tests/wayland-unit-tests.c
index d001db2ad..87fb5d4c8 100644
--- a/src/tests/wayland-unit-tests.c
+++ b/src/tests/wayland-unit-tests.c
@@ -19,6 +19,8 @@
 
 #include <gio/gio.h>
 
+#include "backends/meta-virtual-monitor.h"
+#include "compositor/meta-window-actor-private.h"
 #include "core/display-private.h"
 #include "core/window-private.h"
 #include "meta-test/meta-context-test.h"
@@ -33,7 +35,10 @@ typedef struct _WaylandTestClient
   GMainLoop *main_loop;
 } WaylandTestClient;
 
+static MetaContext *test_context;
 static MetaWaylandTestDriver *test_driver;
+static MetaVirtualMonitor *virtual_monitor;
+static ClutterVirtualInputDevice *virtual_pointer;
 
 static char *
 get_test_client_path (const char *test_client_name)
@@ -182,6 +187,187 @@ subsurface_invalid_xdg_shell_actions (void)
   g_test_assert_expected_messages ();
 }
 
+static void
+on_after_paint (ClutterStage     *stage,
+                ClutterStageView *view,
+                gboolean         *was_painted)
+{
+  *was_painted = TRUE;
+}
+
+static void
+wait_for_paint (ClutterActor *stage)
+{
+  gboolean was_painted = FALSE;
+  gulong was_painted_id;
+
+  was_painted_id = g_signal_connect (CLUTTER_STAGE (stage),
+                                     "after-paint",
+                                     G_CALLBACK (on_after_paint),
+                                     &was_painted);
+
+  while (!was_painted)
+    g_main_context_iteration (NULL, TRUE);
+
+  g_signal_handler_disconnect (stage, was_painted_id);
+}
+
+static gboolean
+on_effects_completed_idle (gpointer user_data)
+{
+  MetaWindowActor *actor = user_data;
+  MetaBackend *backend = meta_context_get_backend (test_context);
+  ClutterActor *stage = meta_backend_get_stage (backend);
+  MetaWindow *window = meta_window_actor_get_meta_window (actor);
+  MetaRectangle buffer_rect;
+
+  /* Move the window to a known position and perform a mouse click, allowing a
+   * popup to be mapped. */
+
+  meta_window_move_frame (window, FALSE, 0, 0);
+
+  clutter_actor_queue_redraw (stage);
+  clutter_stage_schedule_update (CLUTTER_STAGE (stage));
+
+  wait_for_paint (stage);
+
+  meta_window_get_buffer_rect (window, &buffer_rect);
+  clutter_virtual_input_device_notify_absolute_motion (virtual_pointer,
+                                                       CLUTTER_CURRENT_TIME,
+                                                       buffer_rect.x + 10,
+                                                       buffer_rect.y + 10);
+
+  clutter_virtual_input_device_notify_button (virtual_pointer,
+                                              CLUTTER_CURRENT_TIME,
+                                              CLUTTER_BUTTON_PRIMARY,
+                                              CLUTTER_BUTTON_STATE_PRESSED);
+  clutter_virtual_input_device_notify_button (virtual_pointer,
+                                              CLUTTER_CURRENT_TIME,
+                                              CLUTTER_BUTTON_PRIMARY,
+                                              CLUTTER_BUTTON_STATE_RELEASED);
+
+  return G_SOURCE_REMOVE;
+}
+
+static void
+on_effects_completed (MetaWindowActor *actor)
+{
+  g_idle_add (on_effects_completed_idle, actor);
+}
+
+static void
+on_window_added (MetaStack  *stack,
+                 MetaWindow *window)
+{
+  MetaWindowActor *actor = meta_window_actor_from_window (window);
+
+  g_assert_nonnull (actor);
+
+  if (g_strcmp0 (meta_window_get_title (window),
+                 "subsurface-parent-unmapped") != 0)
+    return;
+
+  g_signal_connect (actor, "effects-completed",
+                    G_CALLBACK (on_effects_completed),
+                    NULL);
+}
+
+static void
+on_window_actor_destroyed (MetaWindowActor       *actor,
+                           MetaWaylandTestDriver *test_driver)
+{
+  meta_wayland_test_driver_emit_sync_event (test_driver, 0);
+}
+
+static void
+on_unmap_sync_point (MetaWaylandTestDriver *test_driver,
+                     unsigned int           sequence,
+                     struct wl_resource    *surface_resource,
+                     struct wl_client      *wl_client)
+{
+  if (sequence == 0)
+    {
+      /* Dismiss popup by clicking outside. */
+
+      clutter_virtual_input_device_notify_absolute_motion (virtual_pointer,
+                                                           CLUTTER_CURRENT_TIME,
+                                                           390, 390);
+
+      clutter_virtual_input_device_notify_button (virtual_pointer,
+                                                  CLUTTER_CURRENT_TIME,
+                                                  CLUTTER_BUTTON_PRIMARY,
+                                                  CLUTTER_BUTTON_STATE_PRESSED);
+      clutter_virtual_input_device_notify_button (virtual_pointer,
+                                                  CLUTTER_CURRENT_TIME,
+                                                  CLUTTER_BUTTON_PRIMARY,
+                                                  CLUTTER_BUTTON_STATE_RELEASED);
+
+      MetaWaylandSurface *surface = wl_resource_get_user_data (surface_resource);
+      ClutterActor *actor = CLUTTER_ACTOR (meta_wayland_surface_get_actor (surface));
+      MetaWindowActor *window_actor = meta_window_actor_from_actor (actor);
+      g_signal_connect (window_actor, "destroy",
+                        G_CALLBACK (on_window_actor_destroyed),
+                        test_driver);
+    }
+  else if (sequence == 1)
+    {
+      MetaWaylandSurface *surface = wl_resource_get_user_data (surface_resource);
+      ClutterActor *actor = CLUTTER_ACTOR (meta_wayland_surface_get_actor (surface));
+      MetaWindowActor *window_actor = meta_window_actor_from_actor (actor);
+      MetaWindow *window = meta_window_actor_get_meta_window (window_actor);
+      MetaRectangle buffer_rect;
+
+      /* Click inside the window to allow mapping a popup. */
+
+      meta_window_get_buffer_rect (window, &buffer_rect);
+      clutter_virtual_input_device_notify_absolute_motion (virtual_pointer,
+                                                           CLUTTER_CURRENT_TIME,
+                                                           buffer_rect.x + 10,
+                                                           buffer_rect.y + 10);
+
+      clutter_virtual_input_device_notify_button (virtual_pointer,
+                                                  CLUTTER_CURRENT_TIME,
+                                                  CLUTTER_BUTTON_PRIMARY,
+                                                  CLUTTER_BUTTON_STATE_PRESSED);
+      clutter_virtual_input_device_notify_button (virtual_pointer,
+                                                  CLUTTER_CURRENT_TIME,
+                                                  CLUTTER_BUTTON_PRIMARY,
+                                                  CLUTTER_BUTTON_STATE_RELEASED);
+    }
+}
+
+static void
+subsurface_parent_unmapped (void)
+{
+  MetaBackend *backend = meta_context_get_backend (test_context);
+  MetaDisplay *display = meta_context_get_display (test_context);
+  WaylandTestClient *wayland_test_client;
+  ClutterSeat *seat;
+  gulong window_added_id;
+  gulong sync_point_id;
+
+  seat = meta_backend_get_default_seat (backend);
+  virtual_pointer = clutter_seat_create_virtual_device (seat,
+                                                        CLUTTER_POINTER_DEVICE);
+
+  wayland_test_client = wayland_test_client_new ("subsurface-parent-unmapped");
+
+  window_added_id =
+    g_signal_connect (display->stack, "window-added",
+                      G_CALLBACK (on_window_added),
+                      virtual_pointer);
+  sync_point_id =
+    g_signal_connect (test_driver, "sync-point",
+                      G_CALLBACK (on_unmap_sync_point),
+                      NULL);
+
+  wayland_test_client_finish (wayland_test_client);
+
+  g_clear_object (&virtual_pointer);
+  g_signal_handler_disconnect (test_driver, sync_point_id);
+  g_signal_handler_disconnect (display->stack, window_added_id);
+}
+
 typedef enum _ApplyLimitState
 {
   APPLY_LIMIT_STATE_INIT,
@@ -199,6 +385,7 @@ typedef struct _ApplyLimitData
 static void
 on_sync_point (MetaWaylandTestDriver *test_driver,
                unsigned int           sequence,
+               struct wl_resource    *surface_resource,
                struct wl_client      *wl_client,
                ApplyLimitData        *data)
 {
@@ -237,14 +424,17 @@ static void
 toplevel_apply_limits (void)
 {
   ApplyLimitData data = {};
+  gulong handler_id;
 
   data.loop = g_main_loop_new (NULL, FALSE);
   data.wayland_test_client = wayland_test_client_new ("xdg-apply-limits");
-  g_signal_connect (test_driver, "sync-point", G_CALLBACK (on_sync_point), &data);
+  handler_id = g_signal_connect (test_driver, "sync-point",
+                                 G_CALLBACK (on_sync_point), &data);
   g_main_loop_run (data.loop);
   g_assert_cmpint (data.state, ==, APPLY_LIMIT_STATE_FINISH);
   wayland_test_client_finish (data.wayland_test_client);
   g_test_assert_expected_messages ();
+  g_signal_handler_disconnect (test_driver, handler_id);
 }
 
 static void
@@ -259,18 +449,37 @@ toplevel_activation (void)
 }
 
 static void
-pre_run_wayland_tests (void)
+on_before_tests (void)
 {
-  MetaWaylandCompositor *compositor;
-
-  compositor = meta_wayland_compositor_get_default ();
-  g_assert_nonnull (compositor);
+  MetaBackend *backend = meta_context_get_backend (test_context);
+  MetaMonitorManager *monitor_manager = meta_backend_get_monitor_manager (backend);
+  MetaWaylandCompositor *compositor =
+    meta_context_get_wayland_compositor (test_context);
+  g_autoptr (MetaVirtualMonitorInfo) monitor_info = NULL;
+  g_autoptr (GError) error = NULL;
 
   test_driver = meta_wayland_test_driver_new (compositor);
+
+  monitor_info = meta_virtual_monitor_info_new (400, 400, 60.0,
+                                                "MetaTestVendor",
+                                                "MetaVirtualMonitor",
+                                                "0x1234");
+  virtual_monitor = meta_monitor_manager_create_virtual_monitor (monitor_manager,
+                                                                 monitor_info,
+                                                                 &error);
+  if (!virtual_monitor)
+    g_error ("Failed to create virtual monitor: %s", error->message);
+  meta_monitor_manager_reload (monitor_manager);
 }
 
 static void
-init_wayland_tests (void)
+on_after_tests (void)
+{
+  g_clear_object (&virtual_monitor);
+}
+
+static void
+init_tests (void)
 {
   g_test_add_func ("/wayland/subsurface/remap-toplevel",
                    subsurface_remap_toplevel);
@@ -280,6 +489,8 @@ init_wayland_tests (void)
                    subsurface_invalid_subsurfaces);
   g_test_add_func ("/wayland/subsurface/invalid-xdg-shell-actions",
                    subsurface_invalid_xdg_shell_actions);
+  g_test_add_func ("/wayland/subsurface/parent-unmapped",
+                   subsurface_parent_unmapped);
   g_test_add_func ("/wayland/toplevel/apply-limits",
                    toplevel_apply_limits);
   g_test_add_func ("/wayland/toplevel/activation",
@@ -287,18 +498,23 @@ init_wayland_tests (void)
 }
 
 int
-main (int argc, char *argv[])
+main (int   argc,
+      char *argv[])
 {
   g_autoptr (MetaContext) context = NULL;
 
-  context = meta_create_test_context (META_CONTEXT_TEST_TYPE_NESTED,
-                                      META_CONTEXT_TEST_FLAG_TEST_CLIENT);
+  context = meta_create_test_context (META_CONTEXT_TEST_TYPE_HEADLESS,
+                                      META_CONTEXT_TEST_FLAG_NO_X11);
   g_assert (meta_context_configure (context, &argc, &argv, NULL));
 
-  init_wayland_tests ();
+  test_context = context;
+
+  init_tests ();
 
   g_signal_connect (context, "before-tests",
-                    G_CALLBACK (pre_run_wayland_tests), NULL);
+                    G_CALLBACK (on_before_tests), NULL);
+  g_signal_connect (context, "after-tests",
+                    G_CALLBACK (on_after_tests), NULL);
 
   return meta_context_test_run_tests (META_CONTEXT_TEST (context));
 }
diff --git a/src/ui/frames.c b/src/ui/frames.c
index 48b2a361c..0213395f6 100644
--- a/src/ui/frames.c
+++ b/src/ui/frames.c
@@ -972,8 +972,42 @@ grab_op_from_resize_control (MetaFrameControl control)
     }
 }
 
+static int
+meta_ui_frame_update_click_count (MetaUIFrame        *frame,
+                                  const ClutterEvent *event)
+{
+  MetaFrames *frames = frame->frames;
+  ClutterSettings *settings;
+  int double_click_time, double_click_distance;
+  uint32_t evtime;
+  float x, y;
+
+  settings = clutter_settings_get_default ();
+  clutter_event_get_coords (event, &x, &y);
+  evtime = clutter_event_get_time (event);
+
+  g_object_get (settings,
+                "double-click-distance", &double_click_distance,
+                "double-click-time", &double_click_time,
+                NULL);
+
+  if (evtime > (frames->last_click_time + double_click_time) ||
+      (ABS (x - frames->last_click_x) > double_click_distance) ||
+      (ABS (y - frames->last_click_y) > double_click_distance))
+    frames->click_count = 0;
+
+  frames->last_click_time = evtime;
+  frames->last_click_x = x;
+  frames->last_click_y = y;
+
+  frames->click_count = (frames->click_count % 2) + 1;
+
+  return frames->click_count;
+}
+
 static guint
-get_action (const ClutterEvent *event)
+get_action (MetaUIFrame        *frame,
+            const ClutterEvent *event)
 {
   if (event->type == CLUTTER_BUTTON_PRESS ||
       event->type == CLUTTER_BUTTON_RELEASE)
@@ -981,7 +1015,7 @@ get_action (const ClutterEvent *event)
       switch (event->button.button)
         {
         case CLUTTER_BUTTON_PRIMARY:
-          if (clutter_event_get_click_count (event) == 2)
+          if (meta_ui_frame_update_click_count (frame, event) == 2)
             return META_ACTION_DOUBLE_CLICK;
           else
             return META_ACTION_CLICK;
@@ -1138,7 +1172,7 @@ handle_press_event (MetaUIFrame        *frame,
   g_assert (event->type == CLUTTER_BUTTON_PRESS ||
             event->type == CLUTTER_TOUCH_BEGIN);
 
-  action = get_action (event);
+  action = get_action (frame, event);
   if (action == META_ACTION_IGNORE)
     return FALSE;
 
diff --git a/src/ui/frames.h b/src/ui/frames.h
index d81be1c72..89b399265 100644
--- a/src/ui/frames.h
+++ b/src/ui/frames.h
@@ -105,6 +105,11 @@ struct _MetaFrames
   gdouble grab_y;
 
   ClutterEventSequence *grab_touch;
+
+  float last_click_x;
+  float last_click_y;
+  uint32_t last_click_time;
+  int click_count;
 };
 
 struct _MetaFramesClass
diff --git a/src/wayland/meta-cursor-sprite-wayland.c b/src/wayland/meta-cursor-sprite-wayland.c
index f1a599151..fc265114b 100644
--- a/src/wayland/meta-cursor-sprite-wayland.c
+++ b/src/wayland/meta-cursor-sprite-wayland.c
@@ -25,15 +25,27 @@ struct _MetaCursorSpriteWayland
   MetaCursorSprite parent;
 
   MetaWaylandSurface *surface;
+  gboolean invalidated;
 };
 
 G_DEFINE_TYPE (MetaCursorSpriteWayland,
                meta_cursor_sprite_wayland,
                META_TYPE_CURSOR_SPRITE)
 
-static void
+static gboolean
 meta_cursor_sprite_wayland_realize_texture (MetaCursorSprite *sprite)
 {
+  MetaCursorSpriteWayland *sprite_wayland;
+
+  sprite_wayland = META_CURSOR_SPRITE_WAYLAND (sprite);
+
+  if (sprite_wayland->invalidated)
+    {
+      sprite_wayland->invalidated = FALSE;
+      return TRUE;
+    }
+
+  return FALSE;
 }
 
 static gboolean
@@ -42,6 +54,15 @@ meta_cursor_sprite_wayland_is_animated (MetaCursorSprite *sprite)
   return FALSE;
 }
 
+static void
+meta_cursor_sprite_wayland_invalidate (MetaCursorSprite *sprite)
+{
+  MetaCursorSpriteWayland *sprite_wayland;
+
+  sprite_wayland = META_CURSOR_SPRITE_WAYLAND (sprite);
+  sprite_wayland->invalidated = TRUE;
+}
+
 MetaCursorSpriteWayland *
 meta_cursor_sprite_wayland_new (MetaWaylandSurface *surface,
                                 MetaCursorTracker  *cursor_tracker)
@@ -74,5 +95,7 @@ meta_cursor_sprite_wayland_class_init (MetaCursorSpriteWaylandClass *klass)
 
   cursor_sprite_class->realize_texture =
     meta_cursor_sprite_wayland_realize_texture;
+  cursor_sprite_class->invalidate =
+    meta_cursor_sprite_wayland_invalidate;
   cursor_sprite_class->is_animated = meta_cursor_sprite_wayland_is_animated;
 }
diff --git a/src/wayland/meta-wayland-buffer.c b/src/wayland/meta-wayland-buffer.c
index 2b6fe6b6e..8b354e7aa 100644
--- a/src/wayland/meta-wayland-buffer.c
+++ b/src/wayland/meta-wayland-buffer.c
@@ -691,10 +691,8 @@ try_acquire_egl_image_scanout (MetaWaylandBuffer *buffer,
   MetaDeviceFile *device_file;
   struct gbm_device *gbm_device;
   struct gbm_bo *gbm_bo;
-  uint32_t drm_format;
-  uint64_t drm_modifier;
-  uint32_t stride;
-  MetaDrmBufferGbm *fb;
+  MetaDrmBufferFlags flags;
+  g_autoptr (MetaDrmBufferGbm) fb = NULL;
   g_autoptr (GError) error = NULL;
 
   gpu_kms = meta_renderer_native_get_primary_gpu (renderer_native);
@@ -707,22 +705,11 @@ try_acquire_egl_image_scanout (MetaWaylandBuffer *buffer,
   if (!gbm_bo)
     return NULL;
 
-  drm_format = gbm_bo_get_format (gbm_bo);
-  drm_modifier = gbm_bo_get_modifier (gbm_bo);
-  stride = gbm_bo_get_stride (gbm_bo);
-  if (!meta_onscreen_native_is_buffer_scanout_compatible (onscreen,
-                                                          drm_format,
-                                                          drm_modifier,
-                                                          stride))
-    {
-      gbm_bo_destroy (gbm_bo);
-      return NULL;
-    }
+  flags = META_DRM_BUFFER_FLAG_NONE;
+  if (gbm_bo_get_modifier (gbm_bo) == DRM_FORMAT_MOD_INVALID)
+    flags |= META_DRM_BUFFER_FLAG_DISABLE_MODIFIERS;
 
-  fb = meta_drm_buffer_gbm_new_take (device_file,
-                                     gbm_bo,
-                                     drm_modifier != DRM_FORMAT_MOD_INVALID,
-                                     &error);
+  fb = meta_drm_buffer_gbm_new_take (device_file, gbm_bo, flags, &error);
   if (!fb)
     {
       g_debug ("Failed to create scanout buffer: %s", error->message);
@@ -730,7 +717,11 @@ try_acquire_egl_image_scanout (MetaWaylandBuffer *buffer,
       return NULL;
     }
 
-  return COGL_SCANOUT (fb);
+  if (!meta_onscreen_native_is_buffer_scanout_compatible (onscreen,
+                                                          META_DRM_BUFFER (fb)))
+    return NULL;
+
+  return COGL_SCANOUT (g_steal_pointer (&fb));
 #else
   return NULL;
 #endif
@@ -740,6 +731,9 @@ CoglScanout *
 meta_wayland_buffer_try_acquire_scanout (MetaWaylandBuffer *buffer,
                                          CoglOnscreen      *onscreen)
 {
+  COGL_TRACE_BEGIN_SCOPED (MetaWaylandBufferTryScanout,
+                           "WaylandBuffer (try scanout)");
+
   switch (buffer->type)
     {
     case META_WAYLAND_BUFFER_TYPE_SHM:
diff --git a/src/wayland/meta-wayland-cursor-surface.c b/src/wayland/meta-wayland-cursor-surface.c
index f7763884f..87d55535c 100644
--- a/src/wayland/meta-wayland-cursor-surface.c
+++ b/src/wayland/meta-wayland-cursor-surface.c
@@ -25,7 +25,6 @@
 
 #include "backends/meta-backend-private.h"
 #include "backends/meta-logical-monitor.h"
-#include "cogl/cogl-wayland-server.h"
 #include "cogl/cogl.h"
 #include "core/boxes-private.h"
 #include "wayland/meta-cursor-sprite-wayland.h"
@@ -223,7 +222,13 @@ meta_wayland_cursor_surface_dispose (GObject *object)
                                         cursor_sprite_prepare_at, cursor_surface);
 
   g_clear_object (&priv->cursor_renderer);
-  g_clear_object (&priv->cursor_sprite);
+
+  if (priv->cursor_sprite)
+    {
+      meta_cursor_sprite_set_prepare_func (META_CURSOR_SPRITE (priv->cursor_sprite),
+                                           NULL, NULL);
+      g_clear_object (&priv->cursor_sprite);
+    }
 
   if (priv->buffer)
     {
@@ -262,11 +267,9 @@ meta_wayland_cursor_surface_constructed (GObject *object)
 
   priv->cursor_sprite = meta_cursor_sprite_wayland_new (surface,
                                                         cursor_tracker);
-  g_signal_connect_object (priv->cursor_sprite,
-                           "prepare-at",
-                           G_CALLBACK (cursor_sprite_prepare_at),
-                           cursor_surface,
-                           0);
+  meta_cursor_sprite_set_prepare_func (META_CURSOR_SPRITE (priv->cursor_sprite),
+                                       (MetaCursorPrepareFunc) cursor_sprite_prepare_at,
+                                       cursor_surface);
 }
 
 static void
diff --git a/src/wayland/meta-wayland-data-offer.c b/src/wayland/meta-wayland-data-offer.c
index c4ec2a701..f490b8551 100644
--- a/src/wayland/meta-wayland-data-offer.c
+++ b/src/wayland/meta-wayland-data-offer.c
@@ -125,7 +125,7 @@ data_offer_destroy (struct wl_client   *client,
 
 static void
 data_offer_finish (struct wl_client   *client,
-		   struct wl_resource *resource)
+                   struct wl_resource *resource)
 {
   MetaWaylandDataOffer *offer = wl_resource_get_user_data (resource);
   enum wl_data_device_manager_dnd_action current_action;
diff --git a/src/wayland/meta-wayland-dma-buf.c b/src/wayland/meta-wayland-dma-buf.c
index 0d30684b7..f7b334b49 100644
--- a/src/wayland/meta-wayland-dma-buf.c
+++ b/src/wayland/meta-wayland-dma-buf.c
@@ -40,6 +40,9 @@
 #include "wayland/meta-wayland-dma-buf.h"
 
 #include <drm_fourcc.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
 
 #include "backends/meta-backend-private.h"
 #include "backends/meta-egl-ext.h"
@@ -66,6 +69,62 @@
 
 #define META_WAYLAND_DMA_BUF_MAX_FDS 4
 
+/* Compatible with zwp_linux_dmabuf_feedback_v1.tranche_flags */
+typedef enum _MetaWaylandDmaBufTrancheFlags
+{
+  META_WAYLAND_DMA_BUF_TRANCHE_FLAG_NONE = 0,
+  META_WAYLAND_DMA_BUF_TRANCHE_FLAG_SCANOUT = 1,
+} MetaWaylandDmaBufTrancheFlags;
+
+typedef enum _MetaWaylandDmaBufTranchePriority
+{
+  META_WAYLAND_DMA_BUF_TRANCHE_PRIORITY_HIGH = 0,
+  META_WAYLAND_DMA_BUF_TRANCHE_PRIORITY_DEFAULT = 10,
+} MetaWaylandDmaBufTranchePriority;
+
+typedef struct _MetaWaylandDmaBufFormat
+{
+  uint32_t drm_format;
+  uint64_t drm_modifier;
+  uint16_t table_index;
+} MetaWaylandDmaBufFormat;
+
+typedef struct _MetaWaylandDmaBufTranche
+{
+  MetaWaylandDmaBufTranchePriority priority;
+  dev_t target_device_id;
+  GArray *formats;
+  MetaWaylandDmaBufTrancheFlags flags;
+  uint64_t scanout_crtc_id;
+} MetaWaylandDmaBufTranche;
+
+typedef struct _MetaWaylandDmaBufFeedback
+{
+  dev_t main_device_id;
+  GList *tranches;
+} MetaWaylandDmaBufFeedback;
+
+typedef struct _MetaWaylandDmaBufSurfaceFeedback
+{
+  MetaWaylandDmaBufManager *dma_buf_manager;
+  MetaWaylandSurface *surface;
+  MetaWaylandDmaBufFeedback *feedback;
+  GList *resources;
+  gulong scanout_candidate_changed_id;
+} MetaWaylandDmaBufSurfaceFeedback;
+
+struct _MetaWaylandDmaBufManager
+{
+  GObject parent;
+
+  MetaWaylandCompositor *compositor;
+  dev_t main_device_id;
+
+  GArray *formats;
+  MetaAnonymousFile *format_table_file;
+  MetaWaylandDmaBufFeedback *default_feedback;
+};
+
 struct _MetaWaylandDmaBufBuffer
 {
   GObject parent;
@@ -82,6 +141,185 @@ struct _MetaWaylandDmaBufBuffer
 
 G_DEFINE_TYPE (MetaWaylandDmaBufBuffer, meta_wayland_dma_buf_buffer, G_TYPE_OBJECT);
 
+G_DEFINE_TYPE (MetaWaylandDmaBufManager, meta_wayland_dma_buf_manager,
+               G_TYPE_OBJECT)
+
+static GQuark quark_dma_buf_surface_feedback;
+
+static gboolean
+should_send_modifiers (MetaBackend *backend)
+{
+  MetaSettings *settings = meta_backend_get_settings (backend);
+
+  if (meta_settings_is_experimental_feature_enabled (
+        settings, META_EXPERIMENTAL_FEATURE_KMS_MODIFIERS))
+    return TRUE;
+
+#ifdef HAVE_NATIVE_BACKEND
+  if (META_IS_BACKEND_NATIVE (backend))
+    {
+      MetaRenderer *renderer = meta_backend_get_renderer (backend);
+      MetaRendererNative *renderer_native = META_RENDERER_NATIVE (renderer);
+      return meta_renderer_native_use_modifiers (renderer_native);
+    }
+#endif
+
+  return FALSE;
+}
+
+static gint
+compare_tranches (gconstpointer a,
+                  gconstpointer b)
+{
+  const MetaWaylandDmaBufTranche *tranche_a = a;
+  const MetaWaylandDmaBufTranche *tranche_b = b;
+
+  if (tranche_a->priority > tranche_b->priority)
+    return 1;
+  if (tranche_a->priority < tranche_b->priority)
+    return -1;
+  else
+    return 0;
+}
+
+static MetaWaylandDmaBufTranche *
+meta_wayland_dma_buf_tranche_new (dev_t                             device_id,
+                                  GArray                           *formats,
+                                  MetaWaylandDmaBufTranchePriority  priority,
+                                  MetaWaylandDmaBufTrancheFlags     flags)
+{
+  MetaWaylandDmaBufTranche *tranche;
+
+  tranche = g_new0 (MetaWaylandDmaBufTranche, 1);
+  tranche->target_device_id = device_id;
+  tranche->formats = g_array_copy (formats);
+  tranche->priority = priority;
+  tranche->flags = flags;
+
+  return tranche;
+}
+
+static void
+meta_wayland_dma_buf_tranche_free (MetaWaylandDmaBufTranche *tranche)
+{
+  g_clear_pointer (&tranche->formats, g_array_unref);
+  g_free (tranche);
+}
+
+static MetaWaylandDmaBufTranche *
+meta_wayland_dma_buf_tranche_copy (MetaWaylandDmaBufTranche *tranche)
+{
+  return meta_wayland_dma_buf_tranche_new (tranche->target_device_id,
+                                           tranche->formats,
+                                           tranche->priority,
+                                           tranche->flags);
+}
+
+static void
+meta_wayland_dma_buf_tranche_send (MetaWaylandDmaBufTranche *tranche,
+                                   struct wl_resource       *resource)
+{
+  struct wl_array target_device_buf;
+  dev_t *device_id_ptr;
+  struct wl_array formats_array;
+  unsigned int i;
+
+  wl_array_init (&target_device_buf);
+  device_id_ptr = wl_array_add (&target_device_buf, sizeof (*device_id_ptr));
+  *device_id_ptr = tranche->target_device_id;
+  zwp_linux_dmabuf_feedback_v1_send_tranche_target_device (resource,
+                                                           &target_device_buf);
+  wl_array_release (&target_device_buf);
+  zwp_linux_dmabuf_feedback_v1_send_tranche_flags (resource, tranche->flags);
+
+  wl_array_init (&formats_array);
+  for (i = 0; i < tranche->formats->len; i++)
+    {
+      MetaWaylandDmaBufFormat *format =
+        &g_array_index (tranche->formats,
+                        MetaWaylandDmaBufFormat,
+                        i);
+      uint16_t *format_index_ptr;
+
+      format_index_ptr = wl_array_add (&formats_array,
+                                       sizeof (*format_index_ptr));
+      *format_index_ptr = format->table_index;
+    }
+  zwp_linux_dmabuf_feedback_v1_send_tranche_formats (resource, &formats_array);
+  wl_array_release (&formats_array);
+
+  zwp_linux_dmabuf_feedback_v1_send_tranche_done (resource);
+}
+
+static void
+meta_wayland_dma_buf_feedback_send (MetaWaylandDmaBufFeedback *feedback,
+                                    MetaWaylandDmaBufManager  *dma_buf_manager,
+                                    struct wl_resource        *resource)
+{
+  size_t size;
+  int fd;
+  struct wl_array main_device_buf;
+  dev_t *device_id_ptr;
+
+  fd = meta_anonymous_file_open_fd (dma_buf_manager->format_table_file,
+                                    META_ANONYMOUS_FILE_MAPMODE_PRIVATE);
+  size = meta_anonymous_file_size (dma_buf_manager->format_table_file);
+  zwp_linux_dmabuf_feedback_v1_send_format_table (resource, fd, size);
+  meta_anonymous_file_close_fd (fd);
+
+  wl_array_init (&main_device_buf);
+  device_id_ptr = wl_array_add (&main_device_buf, sizeof (*device_id_ptr));
+  *device_id_ptr = feedback->main_device_id;
+  zwp_linux_dmabuf_feedback_v1_send_main_device (resource, &main_device_buf);
+
+  g_list_foreach (feedback->tranches,
+                  (GFunc) meta_wayland_dma_buf_tranche_send,
+                  resource);
+
+  zwp_linux_dmabuf_feedback_v1_send_done (resource);
+}
+
+static void
+meta_wayland_dma_buf_feedback_add_tranche (MetaWaylandDmaBufFeedback *feedback,
+                                           MetaWaylandDmaBufTranche  *tranche)
+{
+  feedback->tranches = g_list_insert_sorted (feedback->tranches, tranche,
+                                             compare_tranches);
+}
+
+static MetaWaylandDmaBufFeedback *
+meta_wayland_dma_buf_feedback_new (dev_t device_id)
+{
+  MetaWaylandDmaBufFeedback *feedback;
+
+  feedback = g_new0 (MetaWaylandDmaBufFeedback, 1);
+  feedback->main_device_id = device_id;
+
+  return feedback;
+}
+
+static void
+meta_wayland_dma_buf_feedback_free (MetaWaylandDmaBufFeedback *feedback)
+{
+  g_clear_list (&feedback->tranches,
+                (GDestroyNotify) meta_wayland_dma_buf_tranche_free);
+  g_free (feedback);
+}
+
+static MetaWaylandDmaBufFeedback *
+meta_wayland_dma_buf_feedback_copy (MetaWaylandDmaBufFeedback *feedback)
+{
+  MetaWaylandDmaBufFeedback *new_feedback;
+
+  new_feedback = meta_wayland_dma_buf_feedback_new (feedback->main_device_id);
+  new_feedback->tranches =
+    g_list_copy_deep (feedback->tranches,
+                      (GCopyFunc) meta_wayland_dma_buf_tranche_copy,
+                      NULL);
+
+  return new_feedback;
+}
+
 static gboolean
 meta_wayland_dma_buf_realize_texture (MetaWaylandBuffer  *buffer,
                                       GError            **error)
@@ -98,7 +336,9 @@ meta_wayland_dma_buf_realize_texture (MetaWaylandBuffer  *buffer,
   EGLImageKHR egl_image;
   CoglEglImageFlags flags;
   CoglTexture2D *texture;
+#ifdef HAVE_NATIVE_BACKEND
   MetaDrmFormatBuf format_buf;
+#endif
 
   if (buffer->dma_buf.texture)
     return TRUE;
@@ -158,11 +398,13 @@ meta_wayland_dma_buf_realize_texture (MetaWaylandBuffer  *buffer,
       return FALSE;
     }
 
+#ifdef HAVE_NATIVE_BACKEND
   meta_topic (META_DEBUG_WAYLAND,
               "[dma-buf] wl_buffer@%u DRM format %s -> CoglPixelFormat %s",
               wl_resource_get_id (meta_wayland_buffer_get_resource (buffer)),
               meta_drm_format_to_string (&format_buf, dma_buf->drm_format),
               cogl_pixel_format_to_string (cogl_format));
+#endif
 
   for (n_planes = 0; n_planes < META_WAYLAND_DMA_BUF_MAX_FDS; n_planes++)
     {
@@ -286,16 +528,14 @@ meta_wayland_dma_buf_try_acquire_scanout (MetaWaylandDmaBufBuffer *dma_buf,
   MetaBackend *backend = meta_get_backend ();
   MetaRenderer *renderer = meta_backend_get_renderer (backend);
   MetaRendererNative *renderer_native = META_RENDERER_NATIVE (renderer);
+  int n_planes;
   MetaDeviceFile *device_file;
   MetaGpuKms *gpu_kms;
-  int n_planes;
-  uint32_t drm_format;
-  uint64_t drm_modifier;
-  uint32_t stride;
   struct gbm_bo *gbm_bo;
   gboolean use_modifier;
   g_autoptr (GError) error = NULL;
-  MetaDrmBufferGbm *fb;
+  MetaDrmBufferFlags flags;
+  g_autoptr (MetaDrmBufferGbm) fb = NULL;
 
   for (n_planes = 0; n_planes < META_WAYLAND_DMA_BUF_MAX_FDS; n_planes++)
     {
@@ -303,15 +543,6 @@ meta_wayland_dma_buf_try_acquire_scanout (MetaWaylandDmaBufBuffer *dma_buf,
         break;
     }
 
-  drm_format = dma_buf->drm_format;
-  drm_modifier = dma_buf->drm_modifier;
-  stride = dma_buf->strides[0];
-  if (!meta_onscreen_native_is_buffer_scanout_compatible (onscreen,
-                                                          drm_format,
-                                                          drm_modifier,
-                                                          stride))
-    return NULL;
-
   device_file = meta_renderer_native_get_primary_device_file (renderer_native);
   gpu_kms = meta_renderer_native_get_primary_gpu (renderer_native);
   gbm_bo = import_scanout_gbm_bo (dma_buf, gpu_kms, n_planes, &use_modifier);
@@ -321,10 +552,11 @@ meta_wayland_dma_buf_try_acquire_scanout (MetaWaylandDmaBufBuffer *dma_buf,
       return NULL;
     }
 
-  fb = meta_drm_buffer_gbm_new_take (device_file,
-                                     gbm_bo,
-                                     use_modifier,
-                                     &error);
+  flags = META_DRM_BUFFER_FLAG_NONE;
+  if (!use_modifier)
+    flags |= META_DRM_BUFFER_FLAG_DISABLE_MODIFIERS;
+
+  fb = meta_drm_buffer_gbm_new_take (device_file, gbm_bo, flags, &error);
   if (!fb)
     {
       g_debug ("Failed to create scanout buffer: %s", error->message);
@@ -332,7 +564,11 @@ meta_wayland_dma_buf_try_acquire_scanout (MetaWaylandDmaBufBuffer *dma_buf,
       return NULL;
     }
 
-  return COGL_SCANOUT (fb);
+  if (!meta_onscreen_native_is_buffer_scanout_compatible (onscreen,
+                                                          META_DRM_BUFFER (fb)))
+    return NULL;
+
+  return COGL_SCANOUT (g_steal_pointer (&fb));
 #else
   return NULL;
 #endif
@@ -611,161 +847,641 @@ dma_buf_handle_create_buffer_params (struct wl_client   *client,
                                   buffer_params_destructor);
 }
 
-static const struct zwp_linux_dmabuf_v1_interface dma_buf_implementation =
+static void
+feedback_destroy (struct wl_client   *client,
+                  struct wl_resource *resource)
 {
-  dma_buf_handle_destroy,
-  dma_buf_handle_create_buffer_params,
+  wl_resource_destroy (resource);
+}
+
+static const struct zwp_linux_dmabuf_feedback_v1_interface feedback_implementation =
+{
+  feedback_destroy,
 };
 
-static gboolean
-should_send_modifiers (MetaBackend *backend)
+static void
+feedback_destructor (struct wl_resource *resource)
 {
-  MetaSettings *settings = meta_backend_get_settings (backend);
+}
 
-  if (meta_settings_is_experimental_feature_enabled (
-      settings, META_EXPERIMENTAL_FEATURE_KMS_MODIFIERS))
-    return TRUE;
+static void
+dma_buf_handle_get_default_feedback (struct wl_client   *client,
+                                     struct wl_resource *dma_buf_resource,
+                                     uint32_t            feedback_id)
+{
+  MetaWaylandDmaBufManager *dma_buf_manager =
+    wl_resource_get_user_data (dma_buf_resource);
+  struct wl_resource *feedback_resource;
+
+  feedback_resource =
+    wl_resource_create (client,
+                        &zwp_linux_dmabuf_feedback_v1_interface,
+                        wl_resource_get_version (dma_buf_resource),
+                        feedback_id);
+
+  wl_resource_set_implementation (feedback_resource,
+                                  &feedback_implementation,
+                                  NULL,
+                                  feedback_destructor);
+
+  meta_wayland_dma_buf_feedback_send (dma_buf_manager->default_feedback,
+                                      dma_buf_manager,
+                                      feedback_resource);
+}
 
 #ifdef HAVE_NATIVE_BACKEND
-  if (META_IS_BACKEND_NATIVE (backend))
+static int
+find_scanout_tranche_func (gconstpointer a,
+                           gconstpointer b)
+{
+  const MetaWaylandDmaBufTranche *tranche = a;
+
+  if (tranche->scanout_crtc_id)
+    return 0;
+  else
+    return -1;
+}
+
+static gboolean
+has_modifier (GArray   *modifiers,
+              uint64_t  drm_modifier)
+{
+  int i;
+
+  for (i = 0; i < modifiers->len; i++)
     {
-      MetaRenderer *renderer = meta_backend_get_renderer (backend);
-      MetaRendererNative *renderer_native = META_RENDERER_NATIVE (renderer);
-      return meta_renderer_native_use_modifiers (renderer_native);
+      if (drm_modifier == g_array_index (modifiers, uint64_t, i))
+        return TRUE;
     }
-#endif
-
   return FALSE;
 }
 
+static gboolean
+crtc_supports_modifier (MetaCrtcKms *crtc_kms,
+                        uint32_t     drm_format,
+                        uint64_t     drm_modifier)
+{
+  GArray *crtc_modifiers;
+
+  crtc_modifiers = meta_crtc_kms_get_modifiers (crtc_kms, drm_format);
+  if (!crtc_modifiers)
+    return FALSE;
+
+  return has_modifier (crtc_modifiers, drm_modifier);
+}
+
 static void
-send_modifiers (struct wl_resource *resource,
-                uint32_t            format)
+ensure_scanout_tranche (MetaWaylandDmaBufSurfaceFeedback *surface_feedback,
+                        MetaCrtc                         *crtc)
 {
-  MetaBackend *backend = meta_get_backend ();
-  MetaEgl *egl = meta_backend_get_egl (backend);
-  ClutterBackend *clutter_backend = meta_backend_get_clutter_backend (backend);
-  CoglContext *cogl_context = clutter_backend_get_cogl_context (clutter_backend);
-  EGLDisplay egl_display = cogl_egl_context_get_egl_display (cogl_context);
-  EGLint num_modifiers;
-  EGLuint64KHR *modifiers;
-  GError *error = NULL;
-  gboolean ret;
+  MetaWaylandDmaBufManager *dma_buf_manager = surface_feedback->dma_buf_manager;
+  MetaWaylandDmaBufFeedback *feedback = surface_feedback->feedback;
+  MetaCrtcKms *crtc_kms;
+  MetaWaylandDmaBufTranche *tranche;
+  GList *el;
   int i;
+  g_autoptr (GArray) formats = NULL;
+  MetaWaylandDmaBufTranchePriority priority;
+  MetaWaylandDmaBufTrancheFlags flags;
 
-  zwp_linux_dmabuf_v1_send_format (resource, format);
+  g_return_if_fail (META_IS_CRTC_KMS (crtc));
+  crtc_kms = META_CRTC_KMS (crtc);
 
-  /* The modifier event was only added in v3; v1 and v2 only have the format
-   * event. */
-  if (wl_resource_get_version (resource) < ZWP_LINUX_DMABUF_V1_MODIFIER_SINCE_VERSION)
-    return;
+  el = g_list_find_custom (feedback->tranches, NULL, find_scanout_tranche_func);
+  if (el)
+    {
+      tranche = el->data;
 
-  if (!should_send_modifiers (backend))
+      if (tranche->scanout_crtc_id == meta_crtc_get_id (crtc))
+        return;
+
+      meta_wayland_dma_buf_tranche_free (tranche);
+      feedback->tranches = g_list_delete_link (feedback->tranches, el);
+    }
+
+  formats = g_array_new (FALSE, FALSE, sizeof (MetaWaylandDmaBufFormat));
+  if (should_send_modifiers (meta_get_backend ()))
     {
-      zwp_linux_dmabuf_v1_send_modifier (resource, format,
-                                         DRM_FORMAT_MOD_INVALID >> 32,
-                                         DRM_FORMAT_MOD_INVALID & 0xffffffff);
-      return;
+      for (i = 0; i < dma_buf_manager->formats->len; i++)
+        {
+          MetaWaylandDmaBufFormat format =
+            g_array_index (dma_buf_manager->formats,
+                           MetaWaylandDmaBufFormat,
+                           i);
+
+          if (!crtc_supports_modifier (crtc_kms,
+                                       format.drm_format,
+                                       format.drm_modifier))
+            continue;
+
+          g_array_append_val (formats, format);
+        }
+
+      if (formats->len == 0)
+        return;
     }
+  else
+    {
+      for (i = 0; i < dma_buf_manager->formats->len; i++)
+        {
+          MetaWaylandDmaBufFormat format =
+            g_array_index (dma_buf_manager->formats,
+                           MetaWaylandDmaBufFormat,
+                           i);
 
-  /* First query the number of available modifiers, then allocate an array,
-   * then fill the array. */
-  ret = meta_egl_query_dma_buf_modifiers (egl, egl_display, format, 0, NULL,
-                                          NULL, &num_modifiers, NULL);
-  if (!ret)
+          if (format.drm_modifier != DRM_FORMAT_MOD_INVALID)
+            continue;
+
+          if (!meta_crtc_kms_get_modifiers (crtc_kms, format.drm_format))
+            continue;
+
+          g_array_append_val (formats, format);
+        }
+
+      if (formats->len == 0)
+        return;
+    }
+
+  priority = META_WAYLAND_DMA_BUF_TRANCHE_PRIORITY_HIGH;
+  flags = META_WAYLAND_DMA_BUF_TRANCHE_FLAG_SCANOUT;
+  tranche = meta_wayland_dma_buf_tranche_new (feedback->main_device_id,
+                                              formats,
+                                              priority,
+                                              flags);
+  tranche->scanout_crtc_id = meta_crtc_get_id (crtc);
+  meta_wayland_dma_buf_feedback_add_tranche (feedback, tranche);
+}
+
+static void
+clear_scanout_tranche (MetaWaylandDmaBufSurfaceFeedback *surface_feedback)
+{
+  MetaWaylandDmaBufFeedback *feedback = surface_feedback->feedback;
+  MetaWaylandDmaBufTranche *tranche;
+  GList *el;
+
+  el = g_list_find_custom (feedback->tranches, NULL, find_scanout_tranche_func);
+  if (!el)
     return;
 
-  if (num_modifiers == 0)
+  tranche = el->data;
+  meta_wayland_dma_buf_tranche_free (tranche);
+  feedback->tranches = g_list_delete_link (feedback->tranches, el);
+}
+#endif /* HAVE_NATIVE_BACKEND */
+
+static void
+update_surface_feedback_tranches (MetaWaylandDmaBufSurfaceFeedback *surface_feedback)
+{
+#ifdef HAVE_NATIVE_BACKEND
+  MetaCrtc *crtc;
+
+  crtc = meta_wayland_surface_get_scanout_candidate (surface_feedback->surface);
+  if (crtc)
+    ensure_scanout_tranche (surface_feedback, crtc);
+  else
+    clear_scanout_tranche (surface_feedback);
+#endif /* HAVE_NATIVE_BACKEND */
+}
+
+static void
+on_scanout_candidate_changed (MetaWaylandSurface               *surface,
+                              GParamSpec                       *pspec,
+                              MetaWaylandDmaBufSurfaceFeedback *surface_feedback)
+{
+  GList *l;
+
+  update_surface_feedback_tranches (surface_feedback);
+
+  for (l = surface_feedback->resources; l; l = l->next)
     {
-      zwp_linux_dmabuf_v1_send_modifier (resource, format,
-                                         DRM_FORMAT_MOD_INVALID >> 32,
-                                         DRM_FORMAT_MOD_INVALID & 0xffffffff);
-      return;
+      struct wl_resource *resource = l->data;
+
+      meta_wayland_dma_buf_feedback_send (surface_feedback->feedback,
+                                          surface_feedback->dma_buf_manager,
+                                          resource);
     }
+}
 
-  modifiers = g_new0 (uint64_t, num_modifiers);
-  ret = meta_egl_query_dma_buf_modifiers (egl, egl_display, format,
-                                          num_modifiers, modifiers, NULL,
-                                          &num_modifiers, &error);
-  if (!ret)
+static void
+surface_feedback_surface_destroyed_cb (gpointer user_data)
+{
+  MetaWaylandDmaBufSurfaceFeedback *surface_feedback = user_data;
+
+  g_list_foreach (surface_feedback->resources,
+                  (GFunc) wl_resource_set_user_data,
+                  NULL);
+  g_list_free (surface_feedback->resources);
+
+  g_free (surface_feedback);
+}
+
+static MetaWaylandDmaBufSurfaceFeedback *
+ensure_surface_feedback (MetaWaylandDmaBufManager *dma_buf_manager,
+                         MetaWaylandSurface       *surface)
+{
+  MetaWaylandDmaBufSurfaceFeedback *surface_feedback;
+
+  surface_feedback = g_object_get_qdata (G_OBJECT (surface),
+                                         quark_dma_buf_surface_feedback);
+  if (surface_feedback)
+    return surface_feedback;
+
+  surface_feedback = g_new0 (MetaWaylandDmaBufSurfaceFeedback, 1);
+  surface_feedback->dma_buf_manager = dma_buf_manager;
+  surface_feedback->surface = surface;
+  surface_feedback->feedback =
+    meta_wayland_dma_buf_feedback_copy (dma_buf_manager->default_feedback);
+
+  surface_feedback->scanout_candidate_changed_id =
+    g_signal_connect (surface, "notify::scanout-candidate",
+                      G_CALLBACK (on_scanout_candidate_changed),
+                      surface_feedback);
+
+  g_object_set_qdata_full (G_OBJECT (surface),
+                           quark_dma_buf_surface_feedback,
+                           surface_feedback,
+                           surface_feedback_surface_destroyed_cb);
+
+  return surface_feedback;
+}
+
+static void
+surface_feedback_destructor (struct wl_resource *resource)
+{
+  MetaWaylandDmaBufSurfaceFeedback *surface_feedback =
+
+  surface_feedback = wl_resource_get_user_data (resource);
+  if (!surface_feedback)
+    return;
+
+  surface_feedback->resources = g_list_remove (surface_feedback->resources,
+                                               resource);
+  if (!surface_feedback->resources)
     {
-      g_warning ("Failed to query modifiers for format 0x%" PRIu32 ": %s",
-                 format, error ? error->message : "unknown error");
-      g_free (modifiers);
-      return;
+      g_clear_signal_handler (&surface_feedback->scanout_candidate_changed_id,
+                              surface_feedback->surface);
+      g_object_set_qdata (G_OBJECT (surface_feedback->surface),
+                          quark_dma_buf_surface_feedback, NULL);
     }
+}
 
-  for (i = 0; i < num_modifiers; i++)
+static void
+dma_buf_handle_get_surface_feedback (struct wl_client   *client,
+                                     struct wl_resource *dma_buf_resource,
+                                     uint32_t            feedback_id,
+                                     struct wl_resource *surface_resource)
+{
+  MetaWaylandDmaBufManager *dma_buf_manager =
+    wl_resource_get_user_data (dma_buf_resource);
+  MetaWaylandSurface *surface =
+    wl_resource_get_user_data (surface_resource);
+  MetaWaylandDmaBufSurfaceFeedback *surface_feedback;
+  struct wl_resource *feedback_resource;
+
+  surface_feedback = ensure_surface_feedback (dma_buf_manager, surface);
+
+  feedback_resource =
+    wl_resource_create (client,
+                        &zwp_linux_dmabuf_feedback_v1_interface,
+                        wl_resource_get_version (dma_buf_resource),
+                        feedback_id);
+
+  wl_resource_set_implementation (feedback_resource,
+                                  &feedback_implementation,
+                                  surface_feedback,
+                                  surface_feedback_destructor);
+  surface_feedback->resources = g_list_prepend (surface_feedback->resources,
+                                                feedback_resource);
+
+  meta_wayland_dma_buf_feedback_send (surface_feedback->feedback,
+                                      dma_buf_manager,
+                                      feedback_resource);
+}
+
+static const struct zwp_linux_dmabuf_v1_interface dma_buf_implementation =
+{
+  dma_buf_handle_destroy,
+  dma_buf_handle_create_buffer_params,
+  dma_buf_handle_get_default_feedback,
+  dma_buf_handle_get_surface_feedback,
+};
+
+static void
+send_modifiers (struct wl_resource      *resource,
+                MetaWaylandDmaBufFormat *format,
+                GHashTable              *sent_formats)
+{
+  g_assert (wl_resource_get_version (resource) <
+            ZWP_LINUX_DMABUF_V1_GET_DEFAULT_FEEDBACK_SINCE_VERSION);
+
+  if (!g_hash_table_contains (sent_formats,
+                              GUINT_TO_POINTER (format->drm_format)))
     {
-      zwp_linux_dmabuf_v1_send_modifier (resource, format,
-                                         modifiers[i] >> 32,
-                                         modifiers[i] & 0xffffffff);
+      g_hash_table_add (sent_formats, GUINT_TO_POINTER (format->drm_format));
+      zwp_linux_dmabuf_v1_send_format (resource, format->drm_format);
     }
 
-  g_free (modifiers);
+  if (wl_resource_get_version (resource) <
+      ZWP_LINUX_DMABUF_V1_MODIFIER_SINCE_VERSION)
+    return;
+
+  zwp_linux_dmabuf_v1_send_modifier (resource,
+                                     format->drm_format,
+                                     format->drm_modifier >> 32,
+                                     format->drm_modifier & 0xffffffff);
 }
 
 static void
 dma_buf_bind (struct wl_client *client,
-              void             *data,
+              void             *user_data,
               uint32_t          version,
               uint32_t          id)
 {
-  MetaWaylandCompositor *compositor = data;
+  MetaWaylandDmaBufManager *dma_buf_manager = user_data;
   struct wl_resource *resource;
 
   resource = wl_resource_create (client, &zwp_linux_dmabuf_v1_interface,
                                  version, id);
   wl_resource_set_implementation (resource, &dma_buf_implementation,
-                                  compositor, NULL);
-  send_modifiers (resource, DRM_FORMAT_ARGB8888);
-  send_modifiers (resource, DRM_FORMAT_ABGR8888);
-  send_modifiers (resource, DRM_FORMAT_XRGB8888);
-  send_modifiers (resource, DRM_FORMAT_XBGR8888);
-  send_modifiers (resource, DRM_FORMAT_ARGB2101010);
-  send_modifiers (resource, DRM_FORMAT_ABGR2101010);
-  send_modifiers (resource, DRM_FORMAT_XRGB2101010);
-  send_modifiers (resource, DRM_FORMAT_ABGR2101010);
-  send_modifiers (resource, DRM_FORMAT_RGB565);
-  send_modifiers (resource, DRM_FORMAT_ABGR16161616F);
-  send_modifiers (resource, DRM_FORMAT_XBGR16161616F);
-  send_modifiers (resource, DRM_FORMAT_XRGB16161616F);
-  send_modifiers (resource, DRM_FORMAT_ARGB16161616F);
+                                  dma_buf_manager, NULL);
+
+  if (version < ZWP_LINUX_DMABUF_V1_GET_DEFAULT_FEEDBACK_SINCE_VERSION)
+    {
+      g_autoptr (GHashTable) sent_formats = NULL;
+      unsigned int i;
+
+      sent_formats = g_hash_table_new (NULL, NULL);
+
+      for (i = 0; i < dma_buf_manager->formats->len; i++)
+        {
+          MetaWaylandDmaBufFormat *format =
+            &g_array_index (dma_buf_manager->formats,
+                            MetaWaylandDmaBufFormat,
+                            i);
+
+          send_modifiers (resource, format, sent_formats);
+        }
+    }
+}
+
+static void
+add_format (MetaWaylandDmaBufManager *dma_buf_manager,
+            EGLDisplay                egl_display,
+            uint32_t                  drm_format)
+{
+  MetaContext *context = dma_buf_manager->compositor->context;
+  MetaBackend *backend = meta_context_get_backend (context);
+  MetaEgl *egl = meta_backend_get_egl (backend);
+  EGLint num_modifiers;
+  g_autofree EGLuint64KHR *modifiers = NULL;
+  g_autoptr (GError) error = NULL;
+  int i;
+  MetaWaylandDmaBufFormat format;
+
+  if (!should_send_modifiers (backend))
+    goto add_fallback;
+
+  /* First query the number of available modifiers, then allocate an array,
+   * then fill the array. */
+  if (!meta_egl_query_dma_buf_modifiers (egl, egl_display, drm_format, 0, NULL,
+                                         NULL, &num_modifiers, NULL))
+    goto add_fallback;
+
+  if (num_modifiers == 0)
+    goto add_fallback;
+
+  modifiers = g_new0 (uint64_t, num_modifiers);
+  if (!meta_egl_query_dma_buf_modifiers (egl, egl_display, drm_format,
+                                         num_modifiers, modifiers, NULL,
+                                         &num_modifiers, &error))
+    {
+      g_warning ("Failed to query modifiers for format 0x%" PRIu32 ": %s",
+                 drm_format, error ? error->message : "unknown error");
+      goto add_fallback;
+    }
+
+  for (i = 0; i < num_modifiers; i++)
+    {
+      format = (MetaWaylandDmaBufFormat) {
+        .drm_format = drm_format,
+        .drm_modifier = modifiers[i],
+        .table_index = dma_buf_manager->formats->len,
+      };
+      g_array_append_val (dma_buf_manager->formats, format);
+    }
+
+add_fallback:
+  format = (MetaWaylandDmaBufFormat) {
+    .drm_format = drm_format,
+    .drm_modifier = DRM_FORMAT_MOD_INVALID,
+    .table_index = dma_buf_manager->formats->len,
+  };
+  g_array_append_val (dma_buf_manager->formats, format);
+}
+
+/*
+ * This is the structure the data is expected to have in the shared memory file
+ * shared with clients, according to the Wayland Linux DMA buffer protocol.
+ * It's structured as 16 bytes (128 bits) per entry, where each entry consists
+ * of the following:
+ *
+ * [ 32 bit format  ][ 32 bit padding ][          64 bit modifier         ]
+ */
+typedef struct _MetaMetaWaylanDmaBdufFormatEntry
+{
+  uint32_t drm_format;
+  uint32_t unused_padding;
+  uint64_t drm_modifier;
+} MetaWaylandDmaBufFormatEntry;
+
+G_STATIC_ASSERT (sizeof (MetaWaylandDmaBufFormatEntry) == 16);
+G_STATIC_ASSERT (offsetof (MetaWaylandDmaBufFormatEntry, drm_format) == 0);
+G_STATIC_ASSERT (offsetof (MetaWaylandDmaBufFormatEntry, drm_modifier) == 8);
+
+static void
+init_format_table (MetaWaylandDmaBufManager *dma_buf_manager)
+{
+  g_autofree MetaWaylandDmaBufFormatEntry *format_table = NULL;
+  size_t size;
+  int i;
+
+  size = sizeof (MetaWaylandDmaBufFormatEntry) * dma_buf_manager->formats->len;
+  format_table = g_malloc0 (size);
+
+  for (i = 0; i < dma_buf_manager->formats->len; i++)
+    {
+      MetaWaylandDmaBufFormat *format =
+        &g_array_index (dma_buf_manager->formats, MetaWaylandDmaBufFormat, i);
+
+      format_table[i].drm_format = format->drm_format;
+      format_table[i].drm_modifier = format->drm_modifier;
+    }
+
+  dma_buf_manager->format_table_file =
+    meta_anonymous_file_new (size, (uint8_t *) format_table);
+}
+
+static void
+init_formats (MetaWaylandDmaBufManager *dma_buf_manager,
+              EGLDisplay                egl_display)
+{
+  dma_buf_manager->formats = g_array_new (FALSE, FALSE,
+                                          sizeof (MetaWaylandDmaBufFormat));
+
+  add_format (dma_buf_manager, egl_display, DRM_FORMAT_ARGB8888);
+  add_format (dma_buf_manager, egl_display, DRM_FORMAT_ABGR8888);
+  add_format (dma_buf_manager, egl_display, DRM_FORMAT_XRGB8888);
+  add_format (dma_buf_manager, egl_display, DRM_FORMAT_XBGR8888);
+  add_format (dma_buf_manager, egl_display, DRM_FORMAT_ARGB2101010);
+  add_format (dma_buf_manager, egl_display, DRM_FORMAT_ABGR2101010);
+  add_format (dma_buf_manager, egl_display, DRM_FORMAT_XRGB2101010);
+  add_format (dma_buf_manager, egl_display, DRM_FORMAT_XBGR2101010);
+  add_format (dma_buf_manager, egl_display, DRM_FORMAT_RGB565);
+  add_format (dma_buf_manager, egl_display, DRM_FORMAT_ABGR16161616F);
+  add_format (dma_buf_manager, egl_display, DRM_FORMAT_XBGR16161616F);
+  add_format (dma_buf_manager, egl_display, DRM_FORMAT_XRGB16161616F);
+  add_format (dma_buf_manager, egl_display, DRM_FORMAT_ARGB16161616F);
+
+  init_format_table (dma_buf_manager);
+}
+
+static void
+init_default_feedback (MetaWaylandDmaBufManager *dma_buf_manager)
+{
+  MetaWaylandDmaBufTranchePriority priority;
+  MetaWaylandDmaBufTrancheFlags flags;
+  MetaWaylandDmaBufTranche *tranche;
+
+  dma_buf_manager->default_feedback =
+    meta_wayland_dma_buf_feedback_new (dma_buf_manager->main_device_id);
+
+  priority = META_WAYLAND_DMA_BUF_TRANCHE_PRIORITY_DEFAULT;
+  flags = META_WAYLAND_DMA_BUF_TRANCHE_FLAG_NONE;
+  tranche = meta_wayland_dma_buf_tranche_new (dma_buf_manager->main_device_id,
+                                              dma_buf_manager->formats,
+                                              priority,
+                                              flags);
+  meta_wayland_dma_buf_feedback_add_tranche (dma_buf_manager->default_feedback,
+                                             tranche);
 }
 
 /**
- * meta_wayland_dma_buf_init:
+ * meta_wayland_dma_buf_manager_new:
  * @compositor: The #MetaWaylandCompositor
  *
  * Creates the global Wayland object that exposes the linux-dmabuf protocol.
  *
- * Returns: Whether the initialization was successful. If this is %FALSE,
- * clients won't be able to use the linux-dmabuf protocol to pass buffers.
+ * Returns: (transfer full): The MetaWaylandDmaBufManager instance.
  */
-gboolean
-meta_wayland_dma_buf_init (MetaWaylandCompositor *compositor)
+MetaWaylandDmaBufManager *
+meta_wayland_dma_buf_manager_new (MetaWaylandCompositor  *compositor,
+                                  GError                **error)
 {
   MetaBackend *backend = meta_get_backend ();
   MetaEgl *egl = meta_backend_get_egl (backend);
   ClutterBackend *clutter_backend = meta_backend_get_clutter_backend (backend);
   CoglContext *cogl_context = clutter_backend_get_cogl_context (clutter_backend);
   EGLDisplay egl_display = cogl_egl_context_get_egl_display (cogl_context);
+  dev_t device_id = 0;
+  int protocol_version;
+  EGLDeviceEXT egl_device;
+  EGLAttrib attrib;
+  g_autoptr (GError) local_error = NULL;
+  g_autoptr (MetaWaylandDmaBufManager) dma_buf_manager = NULL;
+  const char *device_path = NULL;
+  struct stat device_stat;
 
   g_assert (backend && egl && clutter_backend && cogl_context && egl_display);
 
   if (!meta_egl_has_extensions (egl, egl_display, NULL,
                                 "EGL_EXT_image_dma_buf_import_modifiers",
                                 NULL))
-    return FALSE;
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
+                   "Missing 'EGL_EXT_image_dma_buf_import_modifiers'");
+      return NULL;
+    }
+
+  if (!meta_egl_query_display_attrib (egl, egl_display,
+                                      EGL_DEVICE_EXT, &attrib,
+                                      &local_error))
+    {
+      g_warning ("Failed to query EGL device from primary EGL display: %s",
+                 local_error->message);
+      protocol_version = 3;
+      goto initialize;
+    }
+  egl_device = (EGLDeviceEXT) attrib;
+
+  if (meta_egl_egl_device_has_extensions (egl, egl_device, NULL,
+                                          "EGL_EXT_device_drm_render_node",
+                                          NULL))
+    {
+      device_path = meta_egl_query_device_string (egl, egl_device,
+                                                  EGL_DRM_RENDER_NODE_FILE_EXT,
+                                                  &local_error);
+    }
+  else if (meta_egl_egl_device_has_extensions (egl, egl_device, NULL,
+                                               "EGL_EXT_device_drm",
+                                               NULL))
+    {
+      device_path = meta_egl_query_device_string (egl, egl_device,
+                                                  EGL_DRM_DEVICE_FILE_EXT,
+                                                  &local_error);
+    }
+  else
+    {
+      meta_topic (META_DEBUG_WAYLAND,
+                  "Only advertising zwp_linux_dmabuf_v1 interface version 3 "
+                  "support, missing 'EGL_EXT_device_drm' and "
+                  "'EGL_EXT_device_drm_render_node'");
+      protocol_version = 3;
+      goto initialize;
+    }
+
+  if (!device_path)
+    {
+      g_warning ("Failed to query EGL device path: %s",
+                 local_error->message);
+      protocol_version = 3;
+      goto initialize;
+    }
+
+  if (stat (device_path, &device_stat) != 0)
+    {
+      g_warning ("Failed to fetch device file ID for '%s': %s",
+                 device_path,
+                 g_strerror (errno));
+      protocol_version = 3;
+      goto initialize;
+    }
+
+  device_id = device_stat.st_rdev;
+
+  protocol_version = 4;
+
+initialize:
+
+  dma_buf_manager = g_object_new (META_TYPE_WAYLAND_DMA_BUF_MANAGER, NULL);
 
   if (!wl_global_create (compositor->wayland_display,
                          &zwp_linux_dmabuf_v1_interface,
-                         META_ZWP_LINUX_DMABUF_V1_VERSION,
-                         compositor,
+                         protocol_version,
+                         dma_buf_manager,
                          dma_buf_bind))
-    return FALSE;
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "Failed to create zwp_linux_dmabuf_v1 global");
+      return NULL;
+    }
 
-  return TRUE;
+  dma_buf_manager->compositor = compositor;
+  dma_buf_manager->main_device_id = device_id;
+
+  init_formats (dma_buf_manager, egl_display);
+  init_default_feedback (dma_buf_manager);
+
+  return g_steal_pointer (&dma_buf_manager);
 }
 
 static void
@@ -801,3 +1517,34 @@ meta_wayland_dma_buf_buffer_class_init (MetaWaylandDmaBufBufferClass *klass)
 
   object_class->finalize = meta_wayland_dma_buf_buffer_finalize;
 }
+
+static void
+meta_wayland_dma_buf_manager_finalize (GObject *object)
+{
+  MetaWaylandDmaBufManager *dma_buf_manager =
+    META_WAYLAND_DMA_BUF_MANAGER (object);
+
+  g_clear_pointer (&dma_buf_manager->format_table_file,
+                   meta_anonymous_file_free);
+  g_clear_pointer (&dma_buf_manager->formats, g_array_unref);
+  g_clear_pointer (&dma_buf_manager->default_feedback,
+                   meta_wayland_dma_buf_feedback_free);
+
+  G_OBJECT_CLASS (meta_wayland_dma_buf_manager_parent_class)->finalize (object);
+}
+
+static void
+meta_wayland_dma_buf_manager_class_init (MetaWaylandDmaBufManagerClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  object_class->finalize = meta_wayland_dma_buf_manager_finalize;
+
+  quark_dma_buf_surface_feedback =
+    g_quark_from_static_string ("-meta-wayland-dma-buf-surface-feedback");
+}
+
+static void
+meta_wayland_dma_buf_manager_init (MetaWaylandDmaBufManager *dma_buf)
+{
+}
diff --git a/src/wayland/meta-wayland-dma-buf.h b/src/wayland/meta-wayland-dma-buf.h
index cdc65aeb5..dc1231560 100644
--- a/src/wayland/meta-wayland-dma-buf.h
+++ b/src/wayland/meta-wayland-dma-buf.h
@@ -37,9 +37,14 @@
 G_DECLARE_FINAL_TYPE (MetaWaylandDmaBufBuffer, meta_wayland_dma_buf_buffer,
                       META, WAYLAND_DMA_BUF_BUFFER, GObject);
 
+#define META_TYPE_WAYLAND_DMA_BUF_MANAGER (meta_wayland_dma_buf_manager_get_type ())
+G_DECLARE_FINAL_TYPE (MetaWaylandDmaBufManager, meta_wayland_dma_buf_manager,
+                      META, WAYLAND_DMA_BUF_MANAGER, GObject)
+
 typedef struct _MetaWaylandDmaBufBuffer MetaWaylandDmaBufBuffer;
 
-gboolean meta_wayland_dma_buf_init (MetaWaylandCompositor *compositor);
+MetaWaylandDmaBufManager * meta_wayland_dma_buf_manager_new (MetaWaylandCompositor  *compositor,
+                                                             GError                **error);
 
 gboolean
 meta_wayland_dma_buf_buffer_attach (MetaWaylandBuffer  *buffer,
diff --git a/src/wayland/meta-wayland-gtk-shell.c b/src/wayland/meta-wayland-gtk-shell.c
index 3d85c3f88..1ec5ffdf4 100644
--- a/src/wayland/meta-wayland-gtk-shell.c
+++ b/src/wayland/meta-wayland-gtk-shell.c
@@ -253,9 +253,6 @@ gtk_surface_titlebar_gesture (struct wl_client   *client,
   switch (action)
     {
     case G_DESKTOP_TITLEBAR_ACTION_TOGGLE_MAXIMIZE:
-      if (!window->has_maximize_func)
-        break;
-
       if (META_WINDOW_MAXIMIZED (window))
         meta_window_unmaximize (window, META_MAXIMIZE_BOTH);
       else
@@ -263,9 +260,6 @@ gtk_surface_titlebar_gesture (struct wl_client   *client,
       break;
 
     case G_DESKTOP_TITLEBAR_ACTION_TOGGLE_MAXIMIZE_HORIZONTALLY:
-      if (!window->has_maximize_func)
-        break;
-
       if (META_WINDOW_MAXIMIZED_HORIZONTALLY (window))
         meta_window_unmaximize (window, META_MAXIMIZE_HORIZONTAL);
       else
@@ -273,9 +267,6 @@ gtk_surface_titlebar_gesture (struct wl_client   *client,
       break;
 
     case G_DESKTOP_TITLEBAR_ACTION_TOGGLE_MAXIMIZE_VERTICALLY:
-      if (!window->has_maximize_func)
-        break;
-
       if (META_WINDOW_MAXIMIZED_VERTICALLY (window))
         meta_window_unmaximize (window, META_MAXIMIZE_VERTICAL);
       else
@@ -283,9 +274,6 @@ gtk_surface_titlebar_gesture (struct wl_client   *client,
       break;
 
     case G_DESKTOP_TITLEBAR_ACTION_MINIMIZE:
-      if (!window->has_minimize_func)
-        break;
-
       meta_window_minimize (window);
       break;
 
diff --git a/src/wayland/meta-wayland-outputs.c b/src/wayland/meta-wayland-outputs.c
index 4d07c87f7..6c8baa0df 100644
--- a/src/wayland/meta-wayland-outputs.c
+++ b/src/wayland/meta-wayland-outputs.c
@@ -312,15 +312,16 @@ bind_output (struct wl_client *client,
 #endif
 
   resource = wl_resource_create (client, &wl_output_interface, version, id);
-  wayland_output->resources = g_list_prepend (wayland_output->resources, resource);
-
-  wl_resource_set_user_data (resource, wayland_output);
-  wl_resource_set_destructor (resource, output_resource_destroy);
 
   monitor = wayland_output->monitor;
   if (!monitor)
     return;
 
+  wayland_output->resources = g_list_prepend (wayland_output->resources,
+                                              resource);
+  wl_resource_set_user_data (resource, wayland_output);
+  wl_resource_set_destructor (resource, output_resource_destroy);
+
 #ifdef WITH_VERBOSE_MODE
   logical_monitor = meta_monitor_get_logical_monitor (monitor);
   meta_verbose ("Binding monitor %p/%s (%u, %u, %u, %u) x %f",
@@ -430,6 +431,8 @@ make_output_resources_inert (MetaWaylandOutput *wayland_output)
 {
   GList *l;
 
+  wl_global_remove (wayland_output->global);
+
   for (l = wayland_output->resources; l; l = l->next)
     {
       struct wl_resource *output_resource = l->data;
@@ -531,12 +534,10 @@ meta_wayland_output_finalize (GObject *object)
 {
   MetaWaylandOutput *wayland_output = META_WAYLAND_OUTPUT (object);
 
-  wl_global_destroy (wayland_output->global);
+  g_warn_if_fail (!wayland_output->resources);
+  g_warn_if_fail (!wayland_output->xdg_output_resources);
 
-  /* Make sure the wl_output destructor doesn't try to access MetaWaylandOutput
-   * after we have freed it.
-   */
-  make_output_resources_inert (wayland_output);
+  wl_global_destroy (wayland_output->global);
 
   G_OBJECT_CLASS (meta_wayland_output_parent_class)->finalize (object);
 }
diff --git a/src/wayland/meta-wayland-pointer-gesture-hold.c b/src/wayland/meta-wayland-pointer-gesture-hold.c
new file mode 100644
index 000000000..904b0654b
--- /dev/null
+++ b/src/wayland/meta-wayland-pointer-gesture-hold.c
@@ -0,0 +1,135 @@
+/*
+ * Wayland Support
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author: José Expósito <jose.exposito89@gmail.com>
+ */
+
+#include "config.h"
+
+#include "wayland/meta-wayland-pointer-gesture-hold.h"
+
+#include <glib.h>
+
+#include "wayland/meta-wayland-pointer.h"
+#include "wayland/meta-wayland-seat.h"
+#include "wayland/meta-wayland-surface.h"
+
+#include "pointer-gestures-unstable-v1-server-protocol.h"
+
+static void
+handle_hold_begin (MetaWaylandPointer *pointer,
+                   const ClutterEvent *event)
+{
+  MetaWaylandPointerClient *pointer_client;
+  MetaWaylandSeat *seat;
+  struct wl_resource *resource;
+  uint32_t serial, fingers;
+
+  pointer_client = pointer->focus_client;
+  seat = meta_wayland_pointer_get_seat (pointer);
+  serial = wl_display_next_serial (seat->wl_display);
+  fingers = clutter_event_get_touchpad_gesture_finger_count (event);
+
+  wl_resource_for_each (resource, &pointer_client->hold_gesture_resources)
+    {
+      zwp_pointer_gesture_hold_v1_send_begin (resource, serial,
+                                              clutter_event_get_time (event),
+                                              pointer->focus_surface->resource,
+                                              fingers);
+    }
+}
+
+static void
+handle_hold_end (MetaWaylandPointer *pointer,
+                 const ClutterEvent *event)
+{
+  MetaWaylandPointerClient *pointer_client;
+  MetaWaylandSeat *seat;
+  struct wl_resource *resource;
+  gboolean cancelled = FALSE;
+  uint32_t serial;
+
+  pointer_client = pointer->focus_client;
+  seat = meta_wayland_pointer_get_seat (pointer);
+  serial = wl_display_next_serial (seat->wl_display);
+
+  if (event->touchpad_hold.phase == CLUTTER_TOUCHPAD_GESTURE_PHASE_CANCEL)
+    cancelled = TRUE;
+
+  wl_resource_for_each (resource, &pointer_client->hold_gesture_resources)
+    {
+      zwp_pointer_gesture_hold_v1_send_end (resource, serial,
+                                            clutter_event_get_time (event),
+                                            cancelled);
+    }
+}
+
+gboolean
+meta_wayland_pointer_gesture_hold_handle_event (MetaWaylandPointer *pointer,
+                                                const ClutterEvent *event)
+{
+  if (event->type != CLUTTER_TOUCHPAD_HOLD)
+    return FALSE;
+
+  if (!pointer->focus_client)
+    return FALSE;
+
+  switch (event->touchpad_hold.phase)
+    {
+    case CLUTTER_TOUCHPAD_GESTURE_PHASE_BEGIN:
+      handle_hold_begin (pointer, event);
+      break;
+    case CLUTTER_TOUCHPAD_GESTURE_PHASE_END:
+    case CLUTTER_TOUCHPAD_GESTURE_PHASE_CANCEL:
+      handle_hold_end (pointer, event);
+      break;
+    default:
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+static void
+pointer_gesture_hold_release (struct wl_client   *client,
+                              struct wl_resource *resource)
+{
+  wl_resource_destroy (resource);
+}
+
+static const struct zwp_pointer_gesture_hold_v1_interface pointer_gesture_hold_interface = {
+  pointer_gesture_hold_release
+};
+
+void
+meta_wayland_pointer_gesture_hold_create_new_resource (MetaWaylandPointer *pointer,
+                                                       struct wl_client   *client,
+                                                       struct wl_resource *pointer_resource,
+                                                       uint32_t            id)
+{
+  MetaWaylandPointerClient *pointer_client;
+  struct wl_resource *res;
+
+  pointer_client = meta_wayland_pointer_get_pointer_client (pointer, client);
+  g_return_if_fail (pointer_client != NULL);
+
+  res = wl_resource_create (client, &zwp_pointer_gesture_hold_v1_interface,
+                            wl_resource_get_version (pointer_resource), id);
+  wl_resource_set_implementation (res, &pointer_gesture_hold_interface, pointer,
+                                  meta_wayland_pointer_unbind_pointer_client_resource);
+  wl_list_insert (&pointer_client->hold_gesture_resources,
+                  wl_resource_get_link (res));
+}
diff --git a/src/wayland/meta-wayland-pointer-gesture-hold.h b/src/wayland/meta-wayland-pointer-gesture-hold.h
new file mode 100644
index 000000000..55846bff6
--- /dev/null
+++ b/src/wayland/meta-wayland-pointer-gesture-hold.h
@@ -0,0 +1,37 @@
+/*
+ * Wayland Support
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author: José Expósito <jose.exposito89@gmail.com>
+ */
+
+#ifndef META_WAYLAND_POINTER_GESTURE_HOLD_H
+#define META_WAYLAND_POINTER_GESTURE_HOLD_H
+
+#include <glib.h>
+#include <wayland-server.h>
+
+#include "clutter/clutter.h"
+#include "wayland/meta-wayland-types.h"
+
+gboolean meta_wayland_pointer_gesture_hold_handle_event (MetaWaylandPointer *pointer,
+                                                         const ClutterEvent *event);
+
+void meta_wayland_pointer_gesture_hold_create_new_resource (MetaWaylandPointer *pointer,
+                                                            struct wl_client   *client,
+                                                            struct wl_resource *gestures_resource,
+                                                            uint32_t            id);
+
+#endif /* META_WAYLAND_POINTER_GESTURE_HOLD_H */
diff --git a/src/wayland/meta-wayland-pointer-gestures.c b/src/wayland/meta-wayland-pointer-gestures.c
index 7222a8a8c..559531d34 100644
--- a/src/wayland/meta-wayland-pointer-gestures.c
+++ b/src/wayland/meta-wayland-pointer-gestures.c
@@ -54,9 +54,29 @@ gestures_get_pinch (struct wl_client   *client,
   meta_wayland_pointer_gesture_pinch_create_new_resource (pointer, client, resource, id);
 }
 
+static void
+gestures_get_hold (struct wl_client   *client,
+                   struct wl_resource *resource,
+                   uint32_t            id,
+                   struct wl_resource *pointer_resource)
+{
+  MetaWaylandPointer *pointer = wl_resource_get_user_data (pointer_resource);
+
+  meta_wayland_pointer_gesture_hold_create_new_resource (pointer, client, resource, id);
+}
+
+static void
+gestures_release (struct wl_client   *client,
+                  struct wl_resource *resource)
+{
+  wl_resource_destroy (resource);
+}
+
 static const struct zwp_pointer_gestures_v1_interface pointer_gestures_interface = {
   gestures_get_swipe,
-  gestures_get_pinch
+  gestures_get_pinch,
+  gestures_release,
+  gestures_get_hold
 };
 
 static void
diff --git a/src/wayland/meta-wayland-pointer.c b/src/wayland/meta-wayland-pointer.c
index abd779ad7..3ae907a54 100644
--- a/src/wayland/meta-wayland-pointer.c
+++ b/src/wayland/meta-wayland-pointer.c
@@ -51,10 +51,10 @@
 #include "backends/meta-cursor-tracker-private.h"
 #include "backends/meta-cursor.h"
 #include "clutter/clutter.h"
-#include "cogl/cogl-wayland-server.h"
 #include "cogl/cogl.h"
 #include "compositor/meta-surface-actor-wayland.h"
 #include "meta/meta-cursor-tracker.h"
+#include "wayland/meta-cursor-sprite-wayland.h"
 #include "wayland/meta-wayland-buffer.h"
 #include "wayland/meta-wayland-cursor-surface.h"
 #include "wayland/meta-wayland-pointer.h"
@@ -103,6 +103,7 @@ meta_wayland_pointer_client_new (void)
   wl_list_init (&pointer_client->pointer_resources);
   wl_list_init (&pointer_client->swipe_gesture_resources);
   wl_list_init (&pointer_client->pinch_gesture_resources);
+  wl_list_init (&pointer_client->hold_gesture_resources);
   wl_list_init (&pointer_client->relative_pointer_resources);
 
   return pointer_client;
@@ -135,6 +136,11 @@ meta_wayland_pointer_make_resources_inert (MetaWaylandPointerClient *pointer_cli
       wl_list_init (wl_resource_get_link (resource));
       wl_resource_set_user_data (resource, NULL);
     }
+  wl_resource_for_each_safe (resource, next, &pointer_client->hold_gesture_resources)
+    {
+      wl_list_remove (wl_resource_get_link (resource));
+      wl_list_init (wl_resource_get_link (resource));
+    }
   wl_resource_for_each_safe (resource, next, &pointer_client->relative_pointer_resources)
     {
       wl_list_remove (wl_resource_get_link (resource));
@@ -166,6 +172,7 @@ meta_wayland_pointer_client_is_empty (MetaWaylandPointerClient *pointer_client)
   return (wl_list_empty (&pointer_client->pointer_resources) &&
           wl_list_empty (&pointer_client->swipe_gesture_resources) &&
           wl_list_empty (&pointer_client->pinch_gesture_resources) &&
+          wl_list_empty (&pointer_client->hold_gesture_resources) &&
           wl_list_empty (&pointer_client->relative_pointer_resources));
 }
 
@@ -241,6 +248,18 @@ meta_wayland_pointer_unbind_pointer_client_resource (struct wl_resource *resourc
                                                client);
 }
 
+static MetaWindow *
+surface_get_effective_window (MetaWaylandSurface *surface)
+{
+  MetaWaylandSurface *toplevel;
+
+  toplevel = meta_wayland_surface_get_toplevel (surface);
+  if (!toplevel)
+    return NULL;
+
+  return meta_wayland_surface_get_window (toplevel);
+}
+
 static void
 sync_focus_surface (MetaWaylandPointer *pointer)
 {
@@ -446,6 +465,17 @@ default_grab_focus (MetaWaylandPointerGrab *grab,
       break;
     }
 
+  if (surface)
+    {
+      MetaWindow *window = NULL;
+
+      window = surface_get_effective_window (surface);
+
+      /* Avoid focusing a non-alive surface */
+      if (!window || !meta_window_get_alive (window))
+        surface = NULL;
+    }
+
   meta_wayland_pointer_set_focus (pointer, surface);
 }
 
@@ -691,10 +721,15 @@ handle_scroll_event (MetaWaylandPointer *pointer,
   wl_fixed_t x_value = 0, y_value = 0;
   int x_discrete = 0, y_discrete = 0;
   enum wl_pointer_axis_source source = -1;
+  MetaWaylandPointerClient *client;
 
   if (clutter_event_is_pointer_emulated (event))
     return;
 
+  client = pointer->focus_client;
+  if (!client)
+    return;
+
   switch (event->scroll.scroll_source)
     {
     case CLUTTER_SCROLL_SOURCE_WHEEL:
@@ -750,49 +785,48 @@ handle_scroll_event (MetaWaylandPointer *pointer,
       return;
     }
 
-  if (pointer->focus_client)
+  wl_resource_for_each (resource, &client->pointer_resources)
     {
-      wl_resource_for_each (resource, &pointer->focus_client->pointer_resources)
-        {
-          if (wl_resource_get_version (resource) >= WL_POINTER_AXIS_SOURCE_SINCE_VERSION)
-            wl_pointer_send_axis_source (resource, source);
-
-          /* X axis */
-          if (x_discrete != 0 &&
-              wl_resource_get_version (resource) >= WL_POINTER_AXIS_DISCRETE_SINCE_VERSION)
-            wl_pointer_send_axis_discrete (resource,
-                                           WL_POINTER_AXIS_HORIZONTAL_SCROLL,
-                                           x_discrete);
-
-          if (x_value)
-            wl_pointer_send_axis (resource, clutter_event_get_time (event),
-                                  WL_POINTER_AXIS_HORIZONTAL_SCROLL, x_value);
-
-          if ((event->scroll.finish_flags & CLUTTER_SCROLL_FINISHED_HORIZONTAL) &&
-              wl_resource_get_version (resource) >= WL_POINTER_AXIS_STOP_SINCE_VERSION)
-            wl_pointer_send_axis_stop (resource,
-                                       clutter_event_get_time (event),
-                                       WL_POINTER_AXIS_HORIZONTAL_SCROLL);
-          /* Y axis */
-          if (y_discrete != 0 &&
-              wl_resource_get_version (resource) >= WL_POINTER_AXIS_DISCRETE_SINCE_VERSION)
-            wl_pointer_send_axis_discrete (resource,
-                                           WL_POINTER_AXIS_VERTICAL_SCROLL,
-                                           y_discrete);
-
-          if (y_value)
-            wl_pointer_send_axis (resource, clutter_event_get_time (event),
-                                  WL_POINTER_AXIS_VERTICAL_SCROLL, y_value);
-
-          if ((event->scroll.finish_flags & CLUTTER_SCROLL_FINISHED_VERTICAL) &&
-              wl_resource_get_version (resource) >= WL_POINTER_AXIS_STOP_SINCE_VERSION)
-            wl_pointer_send_axis_stop (resource,
-                                       clutter_event_get_time (event),
-                                       WL_POINTER_AXIS_VERTICAL_SCROLL);
-        }
-
-      meta_wayland_pointer_broadcast_frame (pointer);
+      int client_version = wl_resource_get_version (resource);
+
+      if (client_version >= WL_POINTER_AXIS_SOURCE_SINCE_VERSION)
+        wl_pointer_send_axis_source (resource, source);
+
+      /* X axis */
+      if (x_discrete != 0 &&
+          client_version >= WL_POINTER_AXIS_DISCRETE_SINCE_VERSION)
+        wl_pointer_send_axis_discrete (resource,
+                                       WL_POINTER_AXIS_HORIZONTAL_SCROLL,
+                                       x_discrete);
+
+      if (x_value)
+        wl_pointer_send_axis (resource, clutter_event_get_time (event),
+                              WL_POINTER_AXIS_HORIZONTAL_SCROLL, x_value);
+
+      if ((event->scroll.finish_flags & CLUTTER_SCROLL_FINISHED_HORIZONTAL) &&
+          client_version >= WL_POINTER_AXIS_STOP_SINCE_VERSION)
+        wl_pointer_send_axis_stop (resource,
+                                   clutter_event_get_time (event),
+                                   WL_POINTER_AXIS_HORIZONTAL_SCROLL);
+      /* Y axis */
+      if (y_discrete != 0 &&
+          client_version >= WL_POINTER_AXIS_DISCRETE_SINCE_VERSION)
+        wl_pointer_send_axis_discrete (resource,
+                                       WL_POINTER_AXIS_VERTICAL_SCROLL,
+                                       y_discrete);
+
+      if (y_value)
+        wl_pointer_send_axis (resource, clutter_event_get_time (event),
+                              WL_POINTER_AXIS_VERTICAL_SCROLL, y_value);
+
+      if ((event->scroll.finish_flags & CLUTTER_SCROLL_FINISHED_VERTICAL) &&
+          client_version >= WL_POINTER_AXIS_STOP_SINCE_VERSION)
+        wl_pointer_send_axis_stop (resource,
+                                   clutter_event_get_time (event),
+                                   WL_POINTER_AXIS_VERTICAL_SCROLL);
     }
+
+  meta_wayland_pointer_broadcast_frame (pointer);
 }
 
 gboolean
@@ -822,6 +856,10 @@ meta_wayland_pointer_handle_event (MetaWaylandPointer *pointer,
       meta_wayland_pointer_gesture_pinch_handle_event (pointer, event);
       break;
 
+    case CLUTTER_TOUCHPAD_HOLD:
+      meta_wayland_pointer_gesture_hold_handle_event (pointer, event);
+      break;
+
     default:
       break;
     }
@@ -890,6 +928,16 @@ focus_surface_destroyed (MetaWaylandSurface *surface,
   meta_wayland_pointer_set_focus (pointer, NULL);
 }
 
+static void
+focus_surface_alive_notify (MetaWindow         *window,
+                            GParamSpec         *pspec,
+                            MetaWaylandPointer *pointer)
+{
+  if (!meta_window_get_alive (window))
+    meta_wayland_pointer_set_focus (pointer, NULL);
+  sync_focus_surface (pointer);
+}
+
 void
 meta_wayland_pointer_set_focus (MetaWaylandPointer *pointer,
                                 MetaWaylandSurface *surface)
@@ -899,6 +947,7 @@ meta_wayland_pointer_set_focus (MetaWaylandPointer *pointer,
   MetaCursorTracker *cursor_tracker = meta_backend_get_cursor_tracker (backend);
   ClutterBackend *clutter_backend = clutter_get_default_backend ();
   ClutterSeat *clutter_seat = clutter_backend_get_default_seat (clutter_backend);
+  MetaWindow *toplevel_window;
 
   g_return_if_fail (meta_cursor_tracker_get_pointer_visible (cursor_tracker) ||
                     clutter_seat_is_unfocus_inhibited (clutter_seat) ||
@@ -921,6 +970,13 @@ meta_wayland_pointer_set_focus (MetaWaylandPointer *pointer,
           pointer->focus_client = NULL;
         }
 
+      toplevel_window = surface_get_effective_window (pointer->focus_surface);
+      if (toplevel_window)
+        {
+          g_clear_signal_handler (&pointer->focus_surface_alive_notify_id,
+                                  toplevel_window);
+        }
+
       g_clear_signal_handler (&pointer->focus_surface_destroyed_handler_id,
                               pointer->focus_surface);
       pointer->focus_surface = NULL;
@@ -949,6 +1005,15 @@ meta_wayland_pointer_set_focus (MetaWaylandPointer *pointer,
                                   clutter_get_current_event_time (),
                                   pos.x, pos.y);
 
+      toplevel_window = surface_get_effective_window (pointer->focus_surface);
+      if (toplevel_window)
+        {
+          pointer->focus_surface_alive_notify_id =
+            g_signal_connect (toplevel_window, "notify::is-alive",
+                              G_CALLBACK (focus_surface_alive_notify),
+                              pointer);
+        }
+
       pointer->focus_client =
         meta_wayland_pointer_get_pointer_client (pointer, client);
       if (pointer->focus_client)
@@ -1162,12 +1227,16 @@ pointer_set_cursor (struct wl_client *client,
         meta_backend_get_cursor_renderer_for_device (meta_get_backend (),
                                                      device);
       MetaWaylandCursorSurface *cursor_surface;
+      MetaCursorSprite *cursor_sprite;
 
       cursor_surface = META_WAYLAND_CURSOR_SURFACE (surface->role);
       meta_wayland_cursor_surface_set_renderer (cursor_surface,
                                                 cursor_renderer);
       meta_wayland_cursor_surface_set_hotspot (cursor_surface,
                                                hot_x, hot_y);
+
+      cursor_sprite = meta_wayland_cursor_surface_get_sprite (cursor_surface);
+      meta_cursor_sprite_invalidate (cursor_sprite);
     }
 
   meta_wayland_pointer_set_cursor_surface (pointer, surface);
diff --git a/src/wayland/meta-wayland-pointer.h b/src/wayland/meta-wayland-pointer.h
index 5eda5276f..088312f2f 100644
--- a/src/wayland/meta-wayland-pointer.h
+++ b/src/wayland/meta-wayland-pointer.h
@@ -25,6 +25,7 @@
 
 #include "meta/meta-cursor-tracker.h"
 #include "wayland/meta-wayland-pointer-constraints.h"
+#include "wayland/meta-wayland-pointer-gesture-hold.h"
 #include "wayland/meta-wayland-pointer-gesture-pinch.h"
 #include "wayland/meta-wayland-pointer-gesture-swipe.h"
 #include "wayland/meta-wayland-seat.h"
@@ -58,6 +59,7 @@ struct _MetaWaylandPointerClient
   struct wl_list pointer_resources;
   struct wl_list swipe_gesture_resources;
   struct wl_list pinch_gesture_resources;
+  struct wl_list hold_gesture_resources;
   struct wl_list relative_pointer_resources;
 };
 
@@ -70,6 +72,7 @@ struct _MetaWaylandPointer
 
   MetaWaylandSurface *focus_surface;
   gulong focus_surface_destroyed_handler_id;
+  gulong focus_surface_alive_notify_id;
   guint32 focus_serial;
   guint32 click_serial;
 
diff --git a/src/wayland/meta-wayland-private.h b/src/wayland/meta-wayland-private.h
index 5272b530f..9836e11f1 100644
--- a/src/wayland/meta-wayland-private.h
+++ b/src/wayland/meta-wayland-private.h
@@ -86,6 +86,8 @@ struct _MetaWaylandCompositor
 
   struct wl_display *wayland_display;
   char *display_name;
+  GSource *source;
+
   GHashTable *outputs;
   GList *frame_callback_surfaces;
 
@@ -98,6 +100,7 @@ struct _MetaWaylandCompositor
   GHashTable *scheduled_surface_associations;
 
   MetaWaylandPresentationTime presentation_time;
+  MetaWaylandDmaBufManager *dma_buf_manager;
 };
 
 #define META_TYPE_WAYLAND_COMPOSITOR (meta_wayland_compositor_get_type ())
diff --git a/src/wayland/meta-wayland-seat.c b/src/wayland/meta-wayland-seat.c
index efce6d6d6..63c6b34ab 100644
--- a/src/wayland/meta-wayland-seat.c
+++ b/src/wayland/meta-wayland-seat.c
@@ -234,7 +234,6 @@ meta_wayland_seat_new (MetaWaylandCompositor *compositor,
                               NULL);
 
   seat->text_input = meta_wayland_text_input_new (seat);
-  seat->gtk_text_input = meta_wayland_gtk_text_input_new (seat);
 
   meta_wayland_data_device_init (&seat->data_device);
   meta_wayland_data_device_primary_init (&seat->primary_data_device);
@@ -277,7 +276,6 @@ meta_wayland_seat_free (MetaWaylandSeat *seat)
   meta_wayland_touch_disable (seat->touch);
   g_object_unref (seat->touch);
 
-  meta_wayland_gtk_text_input_destroy (seat->gtk_text_input);
   meta_wayland_text_input_destroy (seat->text_input);
 
   g_free (seat);
@@ -388,8 +386,6 @@ meta_wayland_seat_handle_event (MetaWaylandSeat *seat,
       event->type == CLUTTER_TOUCH_BEGIN)
     {
       meta_wayland_text_input_handle_event (seat->text_input, event);
-      meta_wayland_gtk_text_input_handle_event (seat->gtk_text_input,
-                                                event);
     }
 
   switch (event->type)
@@ -400,6 +396,7 @@ meta_wayland_seat_handle_event (MetaWaylandSeat *seat,
     case CLUTTER_SCROLL:
     case CLUTTER_TOUCHPAD_SWIPE:
     case CLUTTER_TOUCHPAD_PINCH:
+    case CLUTTER_TOUCHPAD_HOLD:
       if (meta_wayland_seat_has_pointer (seat))
         return meta_wayland_pointer_handle_event (seat->pointer, event);
 
@@ -409,10 +406,6 @@ meta_wayland_seat_handle_event (MetaWaylandSeat *seat,
       if (meta_wayland_text_input_handle_event (seat->text_input, event))
         return TRUE;
 
-      if (meta_wayland_gtk_text_input_handle_event (seat->gtk_text_input,
-                                                    event))
-        return TRUE;
-
       if (meta_wayland_seat_has_keyboard (seat))
         return meta_wayland_keyboard_handle_event (seat->keyboard,
                                                    (const ClutterKeyEvent *) event);
@@ -429,9 +422,6 @@ meta_wayland_seat_handle_event (MetaWaylandSeat *seat,
     case CLUTTER_IM_PREEDIT:
       if (meta_wayland_text_input_handle_event (seat->text_input, event))
         return TRUE;
-      if (meta_wayland_gtk_text_input_handle_event (seat->gtk_text_input,
-                                                    event))
-        return TRUE;
 
       break;
     default:
@@ -460,7 +450,6 @@ meta_wayland_seat_set_input_focus (MetaWaylandSeat    *seat,
   meta_wayland_tablet_seat_set_pad_focus (tablet_seat, surface);
 
   meta_wayland_text_input_set_focus (seat->text_input, surface);
-  meta_wayland_gtk_text_input_set_focus (seat->gtk_text_input, surface);
 }
 
 gboolean
diff --git a/src/wayland/meta-wayland-seat.h b/src/wayland/meta-wayland-seat.h
index ae4e1076b..7f8b087ec 100644
--- a/src/wayland/meta-wayland-seat.h
+++ b/src/wayland/meta-wayland-seat.h
@@ -33,7 +33,6 @@
 #include "wayland/meta-wayland-pointer.h"
 #include "wayland/meta-wayland-tablet-tool.h"
 #include "wayland/meta-wayland-text-input.h"
-#include "wayland/meta-wayland-text-input-legacy.h"
 #include "wayland/meta-wayland-touch.h"
 #include "wayland/meta-wayland-types.h"
 
@@ -50,7 +49,6 @@ struct _MetaWaylandSeat
   MetaWaylandDataDevicePrimary primary_data_device;
   MetaWaylandDataDevicePrimaryLegacy primary_legacy_data_device;
 
-  MetaWaylandGtkTextInput *gtk_text_input;
   MetaWaylandTextInput *text_input;
 
   guint capabilities;
diff --git a/src/wayland/meta-wayland-subsurface.c b/src/wayland/meta-wayland-subsurface.c
index 1e9b65528..7e996f4d3 100644
--- a/src/wayland/meta-wayland-subsurface.c
+++ b/src/wayland/meta-wayland-subsurface.c
@@ -468,18 +468,14 @@ wl_subsurface_set_desync (struct wl_client   *client,
                           struct wl_resource *resource)
 {
   MetaWaylandSurface *surface = wl_resource_get_user_data (resource);
-  gboolean is_parent_effectively_synchronized;
+  gboolean was_effectively_synchronized;
 
-  if (!surface->sub.synchronous)
-    return;
-
-  is_parent_effectively_synchronized =
-    is_surface_effectively_synchronized (surface->sub.parent);
+  was_effectively_synchronized = is_surface_effectively_synchronized (surface);
+  surface->sub.synchronous = FALSE;
 
-  if (!is_parent_effectively_synchronized)
+  if (was_effectively_synchronized &&
+      !is_surface_effectively_synchronized (surface))
     meta_wayland_surface_apply_cached_state (surface);
-
-  surface->sub.synchronous = FALSE;
 }
 
 static const struct wl_subsurface_interface meta_wayland_wl_subsurface_interface = {
diff --git a/src/wayland/meta-wayland-surface.c b/src/wayland/meta-wayland-surface.c
index 871aded3a..5bd0d684d 100644
--- a/src/wayland/meta-wayland-surface.c
+++ b/src/wayland/meta-wayland-surface.c
@@ -29,7 +29,6 @@
 
 #include "backends/meta-cursor-tracker-private.h"
 #include "clutter/clutter.h"
-#include "cogl/cogl-wayland-server.h"
 #include "cogl/cogl.h"
 #include "compositor/meta-surface-actor-wayland.h"
 #include "compositor/meta-surface-actor.h"
@@ -51,7 +50,6 @@
 #include "wayland/meta-wayland-seat.h"
 #include "wayland/meta-wayland-subsurface.h"
 #include "wayland/meta-wayland-viewporter.h"
-#include "wayland/meta-wayland-wl-shell.h"
 #include "wayland/meta-wayland-xdg-shell.h"
 #include "wayland/meta-window-wayland.h"
 #include "wayland/meta-xwayland-private.h"
@@ -78,6 +76,17 @@ typedef struct _MetaWaylandSurfaceRolePrivate
   MetaWaylandSurface *surface;
 } MetaWaylandSurfaceRolePrivate;
 
+enum
+{
+  PROP_0,
+
+  PROP_SCANOUT_CANDIDATE,
+
+  N_PROPS
+};
+
+static GParamSpec *obj_props[N_PROPS];
+
 G_DEFINE_TYPE (MetaWaylandSurface, meta_wayland_surface, G_TYPE_OBJECT);
 
 G_DEFINE_ABSTRACT_TYPE_WITH_PRIVATE (MetaWaylandSurfaceRole,
@@ -949,7 +958,9 @@ cleanup:
 void
 meta_wayland_surface_apply_cached_state (MetaWaylandSurface *surface)
 {
-  meta_wayland_surface_ensure_cached_state (surface);
+  if (!surface->cached_state)
+    return;
+
   meta_wayland_surface_apply_state (surface, surface->cached_state);
 }
 
@@ -1016,20 +1027,17 @@ wl_surface_destroy (struct wl_client *client,
 }
 
 static void
-wl_surface_attach (struct wl_client *client,
+wl_surface_attach (struct wl_client   *client,
                    struct wl_resource *surface_resource,
                    struct wl_resource *buffer_resource,
-                   gint32 dx, gint32 dy)
+                   int32_t             dx,
+                   int32_t             dy)
 {
   MetaWaylandSurface *surface =
     wl_resource_get_user_data (surface_resource);
   MetaWaylandSurfaceState *pending = surface->pending_state;
   MetaWaylandBuffer *buffer;
 
-  /* X11 unmanaged window */
-  if (!surface)
-    return;
-
   if (buffer_resource)
     buffer = meta_wayland_buffer_from_resource (buffer_resource);
   else
@@ -1067,10 +1075,6 @@ wl_surface_damage (struct wl_client   *client,
   MetaWaylandSurfaceState *pending = surface->pending_state;
   cairo_rectangle_int_t rectangle;
 
-  /* X11 unmanaged window */
-  if (!surface)
-    return;
-
   rectangle = (cairo_rectangle_int_t) {
     .x = x,
     .y = y,
@@ -1091,18 +1095,14 @@ destroy_frame_callback (struct wl_resource *callback_resource)
 }
 
 static void
-wl_surface_frame (struct wl_client *client,
+wl_surface_frame (struct wl_client   *client,
                   struct wl_resource *surface_resource,
-                  guint32 callback_id)
+                  uint32_t            callback_id)
 {
   MetaWaylandFrameCallback *callback;
   MetaWaylandSurface *surface = wl_resource_get_user_data (surface_resource);
   MetaWaylandSurfaceState *pending = surface->pending_state;
 
-  /* X11 unmanaged window */
-  if (!surface)
-    return;
-
   callback = g_new0 (MetaWaylandFrameCallback, 1);
   callback->surface = surface;
   callback->resource = wl_resource_create (client,
@@ -1116,17 +1116,13 @@ wl_surface_frame (struct wl_client *client,
 }
 
 static void
-wl_surface_set_opaque_region (struct wl_client *client,
+wl_surface_set_opaque_region (struct wl_client   *client,
                               struct wl_resource *surface_resource,
                               struct wl_resource *region_resource)
 {
   MetaWaylandSurface *surface = wl_resource_get_user_data (surface_resource);
   MetaWaylandSurfaceState *pending = surface->pending_state;
 
-  /* X11 unmanaged window */
-  if (!surface)
-    return;
-
   g_clear_pointer (&pending->opaque_region, cairo_region_destroy);
   if (region_resource)
     {
@@ -1138,17 +1134,13 @@ wl_surface_set_opaque_region (struct wl_client *client,
 }
 
 static void
-wl_surface_set_input_region (struct wl_client *client,
+wl_surface_set_input_region (struct wl_client   *client,
                              struct wl_resource *surface_resource,
                              struct wl_resource *region_resource)
 {
   MetaWaylandSurface *surface = wl_resource_get_user_data (surface_resource);
   MetaWaylandSurfaceState *pending = surface->pending_state;
 
-  /* X11 unmanaged window */
-  if (!surface)
-    return;
-
   g_clear_pointer (&pending->input_region, cairo_region_destroy);
   if (region_resource)
     {
@@ -1160,15 +1152,11 @@ wl_surface_set_input_region (struct wl_client *client,
 }
 
 static void
-wl_surface_commit (struct wl_client *client,
+wl_surface_commit (struct wl_client   *client,
                    struct wl_resource *resource)
 {
   MetaWaylandSurface *surface = wl_resource_get_user_data (resource);
 
-  /* X11 unmanaged window */
-  if (!surface)
-    return;
-
   meta_wayland_surface_commit (surface);
 }
 
@@ -1256,10 +1244,6 @@ wl_surface_damage_buffer (struct wl_client   *client,
   MetaWaylandSurfaceState *pending = surface->pending_state;
   cairo_rectangle_int_t rectangle;
 
-  /* X11 unmanaged window */
-  if (!surface)
-    return;
-
   rectangle = (cairo_rectangle_int_t) {
     .x = x,
     .y = y,
@@ -1438,6 +1422,7 @@ wl_surface_destructor (struct wl_resource *resource)
 
   g_signal_emit (surface, surface_signals[SURFACE_DESTROY], 0);
 
+  g_clear_object (&surface->scanout_candidate);
   g_clear_object (&surface->role);
 
   if (surface->unassigned.buffer)
@@ -1475,9 +1460,6 @@ wl_surface_destructor (struct wl_resource *resource)
 
   meta_wayland_surface_discard_presentation_feedback (surface);
 
-  if (surface->resource)
-    wl_resource_set_user_data (surface->resource, NULL);
-
   if (surface->wl_subsurface)
     wl_resource_destroy (surface->wl_subsurface);
 
@@ -1553,14 +1535,13 @@ meta_wayland_surface_begin_grab_op (MetaWaylandSurface *surface,
  * @compositor: The #MetaWaylandCompositor object
  *
  * Initializes the Wayland interfaces providing features that deal with
- * desktop-specific conundrums, like XDG shell, wl_shell (deprecated), etc.
+ * desktop-specific conundrums, like XDG shell, etc.
  */
 void
 meta_wayland_shell_init (MetaWaylandCompositor *compositor)
 {
   meta_wayland_xdg_shell_init (compositor);
   meta_wayland_legacy_xdg_shell_init (compositor);
-  meta_wayland_wl_shell_init (compositor);
   meta_wayland_init_gtk_shell (compositor);
   meta_wayland_init_viewporter (compositor);
 }
@@ -1722,11 +1703,41 @@ meta_wayland_surface_init (MetaWaylandSurface *surface)
     g_node_prepend_data (surface->subsurface_branch_node, surface);
 }
 
+static void
+meta_wayland_surface_get_property (GObject    *object,
+                                   guint       prop_id,
+                                   GValue     *value,
+                                   GParamSpec *pspec)
+{
+  MetaWaylandSurface *surface = META_WAYLAND_SURFACE (object);
+
+  switch (prop_id)
+    {
+    case PROP_SCANOUT_CANDIDATE:
+      g_value_set_object (value, surface->scanout_candidate);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+}
+
 static void
 meta_wayland_surface_class_init (MetaWaylandSurfaceClass *klass)
 {
   GObjectClass *object_class = G_OBJECT_CLASS (klass);
 
+  object_class->get_property = meta_wayland_surface_get_property;
+
+  obj_props[PROP_SCANOUT_CANDIDATE] =
+    g_param_spec_object ("scanout-candidate",
+                         "scanout-candidate",
+                         "Scanout candidate for given CRTC",
+                         META_TYPE_CRTC,
+                         G_PARAM_READABLE |
+                         G_PARAM_STATIC_STRINGS);
+  g_object_class_install_properties (object_class, N_PROPS, obj_props);
+
   surface_signals[SURFACE_DESTROY] =
     g_signal_new ("destroy",
                   G_TYPE_FROM_CLASS (object_class),
@@ -2129,3 +2140,21 @@ meta_wayland_surface_try_acquire_scanout (MetaWaylandSurface *surface,
 
   return scanout;
 }
+
+MetaCrtc *
+meta_wayland_surface_get_scanout_candidate (MetaWaylandSurface *surface)
+{
+  return surface->scanout_candidate;
+}
+
+void
+meta_wayland_surface_set_scanout_candidate (MetaWaylandSurface *surface,
+                                            MetaCrtc           *crtc)
+{
+  if (surface->scanout_candidate == crtc)
+    return;
+
+  g_set_object (&surface->scanout_candidate, crtc);
+  g_object_notify_by_pspec (G_OBJECT (surface),
+                            obj_props[PROP_SCANOUT_CANDIDATE]);
+}
diff --git a/src/wayland/meta-wayland-surface.h b/src/wayland/meta-wayland-surface.h
index f0153b23b..25b619977 100644
--- a/src/wayland/meta-wayland-surface.h
+++ b/src/wayland/meta-wayland-surface.h
@@ -247,6 +247,9 @@ struct _MetaWaylandSurface
      */
     uint64_t sequence;
   } presentation_time;
+
+  /* dma-buf feedback */
+  MetaCrtc *scanout_candidate;
 };
 
 void                meta_wayland_shell_init     (MetaWaylandCompositor *compositor);
@@ -348,6 +351,7 @@ gboolean            meta_wayland_surface_is_shortcuts_inhibited (MetaWaylandSurf
 
 CoglTexture *       meta_wayland_surface_get_texture (MetaWaylandSurface *surface);
 
+META_EXPORT_TEST
 MetaSurfaceActor *  meta_wayland_surface_get_actor (MetaWaylandSurface *surface);
 
 void                meta_wayland_surface_notify_geometry_changed (MetaWaylandSurface *surface);
@@ -362,6 +366,11 @@ int                 meta_wayland_surface_get_height (MetaWaylandSurface *surface
 CoglScanout *       meta_wayland_surface_try_acquire_scanout (MetaWaylandSurface *surface,
                                                               CoglOnscreen       *onscreen);
 
+MetaCrtc * meta_wayland_surface_get_scanout_candidate (MetaWaylandSurface *surface);
+
+void meta_wayland_surface_set_scanout_candidate (MetaWaylandSurface *surface,
+                                                 MetaCrtc           *crtc);
+
 static inline GNode *
 meta_get_next_subsurface_sibling (GNode *n)
 {
diff --git a/src/wayland/meta-wayland-tablet-tool.c b/src/wayland/meta-wayland-tablet-tool.c
index 2b2b1d659..eeacd9bf9 100644
--- a/src/wayland/meta-wayland-tablet-tool.c
+++ b/src/wayland/meta-wayland-tablet-tool.c
@@ -401,9 +401,9 @@ meta_wayland_tablet_tool_new (MetaWaylandTabletSeat  *seat,
 
   tool->default_sprite = meta_cursor_sprite_xcursor_new (META_CURSOR_CROSSHAIR,
                                                          cursor_tracker);
-  tool->prepare_at_signal_id =
-    g_signal_connect (tool->default_sprite, "prepare-at",
-                      G_CALLBACK (tool_cursor_prepare_at), tool);
+  meta_cursor_sprite_set_prepare_func (META_CURSOR_SPRITE (tool->default_sprite),
+                                       (MetaCursorPrepareFunc) tool_cursor_prepare_at,
+                                       tool);
 
   return tool;
 }
@@ -424,7 +424,8 @@ meta_wayland_tablet_tool_free (MetaWaylandTabletTool *tool)
       wl_list_init (wl_resource_get_link (resource));
     }
 
-  g_clear_signal_handler (&tool->prepare_at_signal_id, tool->default_sprite);
+  meta_cursor_sprite_set_prepare_func (META_CURSOR_SPRITE (tool->default_sprite),
+                                       NULL, NULL);
   g_object_unref (tool->default_sprite);
 
   g_free (tool);
diff --git a/src/wayland/meta-wayland-tablet-tool.h b/src/wayland/meta-wayland-tablet-tool.h
index e9ad7db40..9fc704851 100644
--- a/src/wayland/meta-wayland-tablet-tool.h
+++ b/src/wayland/meta-wayland-tablet-tool.h
@@ -44,7 +44,6 @@ struct _MetaWaylandTabletTool
   struct wl_listener cursor_surface_destroy_listener;
   MetaCursorRenderer *cursor_renderer;
   MetaCursorSpriteXcursor *default_sprite;
-  gulong prepare_at_signal_id;
 
   MetaWaylandSurface *current;
   guint32 pressed_buttons;
diff --git a/src/wayland/meta-wayland-text-input-legacy.c b/src/wayland/meta-wayland-text-input-legacy.c
deleted file mode 100644
index 442708e0f..000000000
--- a/src/wayland/meta-wayland-text-input-legacy.c
+++ /dev/null
@@ -1,633 +0,0 @@
-/*
- * Copyright (C) 2017, 2018 Red Hat
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- *
- * Author: Carlos Garnacho <carlosg@gnome.org>
- */
-
-#include "config.h"
-
-#include <wayland-server.h>
-
-#include "wayland/meta-wayland-private.h"
-#include "wayland/meta-wayland-seat.h"
-#include "wayland/meta-wayland-text-input-legacy.h"
-#include "wayland/meta-wayland-versions.h"
-
-#include "gtk-text-input-server-protocol.h"
-
-#define META_TYPE_WAYLAND_GTK_TEXT_INPUT_FOCUS (meta_wayland_gtk_text_input_focus_get_type ())
-
-typedef enum
-{
-  META_WAYLAND_PENDING_STATE_NONE             = 0,
-  META_WAYLAND_PENDING_STATE_INPUT_RECT       = 1 << 0,
-  META_WAYLAND_PENDING_STATE_CONTENT_TYPE     = 1 << 1,
-  META_WAYLAND_PENDING_STATE_SURROUNDING_TEXT = 1 << 2,
-} MetaWaylandTextInputPendingState;
-
-typedef struct _MetaWaylandGtkTextInput MetaWaylandGtkTextInput;
-
-struct _MetaWaylandGtkTextInput
-{
-  MetaWaylandSeat *seat;
-  ClutterInputFocus *input_focus;
-
-  struct wl_list resource_list;
-  struct wl_list focus_resource_list;
-  MetaWaylandSurface *surface;
-  struct wl_listener surface_listener;
-  uint32_t focus_serial;
-
-  MetaWaylandTextInputPendingState pending_state;
-
-  struct
-  {
-    char *text;
-    uint32_t cursor;
-    uint32_t anchor;
-  } surrounding;
-
-  cairo_rectangle_int_t cursor_rect;
-
-  uint32_t content_type_hint;
-  uint32_t content_type_purpose;
-};
-
-struct _MetaWaylandGtkTextInputFocus
-{
-  ClutterInputFocus parent_instance;
-  MetaWaylandGtkTextInput *text_input;
-};
-
-G_DECLARE_FINAL_TYPE (MetaWaylandGtkTextInputFocus,
-                      meta_wayland_gtk_text_input_focus,
-                      META, WAYLAND_GTK_TEXT_INPUT_FOCUS, ClutterInputFocus)
-G_DEFINE_TYPE (MetaWaylandGtkTextInputFocus, meta_wayland_gtk_text_input_focus,
-               CLUTTER_TYPE_INPUT_FOCUS)
-
-static void
-meta_wayland_text_input_focus_request_surrounding (ClutterInputFocus *focus)
-{
-  MetaWaylandGtkTextInput *text_input;
-
-  text_input = META_WAYLAND_GTK_TEXT_INPUT_FOCUS (focus)->text_input;
-  clutter_input_focus_set_surrounding (focus,
-				       text_input->surrounding.text,
-				       text_input->surrounding.cursor,
-                                       text_input->surrounding.anchor);
-}
-
-static void
-meta_wayland_text_input_focus_delete_surrounding (ClutterInputFocus *focus,
-                                                  int                offset,
-                                                  guint              len)
-{
-  MetaWaylandGtkTextInput *text_input;
-  uint32_t before_length;
-  uint32_t after_length;
-  struct wl_resource *resource;
-
-  text_input = META_WAYLAND_GTK_TEXT_INPUT_FOCUS (focus)->text_input;
-  before_length = ABS (MIN (offset, 0));
-  after_length = MAX (0, offset + len);
-  g_warn_if_fail (ABS (offset) <= len);
-
-  wl_resource_for_each (resource, &text_input->focus_resource_list)
-    {
-      gtk_text_input_send_delete_surrounding_text (resource,
-                                                   before_length,
-                                                   after_length);
-    }
-}
-
-static void
-meta_wayland_text_input_focus_commit_text (ClutterInputFocus *focus,
-                                           const gchar       *text)
-{
-  MetaWaylandGtkTextInput *text_input;
-  struct wl_resource *resource;
-
-  text_input = META_WAYLAND_GTK_TEXT_INPUT_FOCUS (focus)->text_input;
-
-  wl_resource_for_each (resource, &text_input->focus_resource_list)
-    {
-      gtk_text_input_send_preedit_string (resource, NULL, 0);
-      gtk_text_input_send_commit_string (resource, text);
-    }
-}
-
-static void
-meta_wayland_text_input_focus_set_preedit_text (ClutterInputFocus *focus,
-                                                const gchar       *text,
-                                                guint              cursor)
-{
-  MetaWaylandGtkTextInput *text_input;
-  struct wl_resource *resource;
-
-  text_input = META_WAYLAND_GTK_TEXT_INPUT_FOCUS (focus)->text_input;
-
-  wl_resource_for_each (resource, &text_input->focus_resource_list)
-    {
-      gtk_text_input_send_preedit_string (resource, text, cursor);
-    }
-}
-
-static void
-meta_wayland_gtk_text_input_focus_class_init (MetaWaylandGtkTextInputFocusClass *klass)
-{
-  ClutterInputFocusClass *focus_class = CLUTTER_INPUT_FOCUS_CLASS (klass);
-
-  focus_class->request_surrounding = meta_wayland_text_input_focus_request_surrounding;
-  focus_class->delete_surrounding = meta_wayland_text_input_focus_delete_surrounding;
-  focus_class->commit_text = meta_wayland_text_input_focus_commit_text;
-  focus_class->set_preedit_text = meta_wayland_text_input_focus_set_preedit_text;
-}
-
-static void
-meta_wayland_gtk_text_input_focus_init (MetaWaylandGtkTextInputFocus *focus)
-{
-}
-
-static ClutterInputFocus *
-meta_wayland_text_input_focus_new (MetaWaylandGtkTextInput *text_input)
-{
-  MetaWaylandGtkTextInputFocus *focus;
-
-  focus = g_object_new (META_TYPE_WAYLAND_GTK_TEXT_INPUT_FOCUS, NULL);
-  focus->text_input = text_input;
-
-  return CLUTTER_INPUT_FOCUS (focus);
-}
-
-static void
-text_input_handle_focus_surface_destroy (struct wl_listener *listener,
-					 void               *data)
-{
-  MetaWaylandGtkTextInput *text_input = wl_container_of (listener, text_input,
-                                                         surface_listener);
-
-  meta_wayland_gtk_text_input_set_focus (text_input, NULL);
-}
-
-static void
-move_resources (struct wl_list *destination, struct wl_list *source)
-{
-  wl_list_insert_list (destination, source);
-  wl_list_init (source);
-}
-
-static void
-move_resources_for_client (struct wl_list *destination,
-			   struct wl_list *source,
-			   struct wl_client *client)
-{
-  struct wl_resource *resource, *tmp;
-  wl_resource_for_each_safe (resource, tmp, source)
-    {
-      if (wl_resource_get_client (resource) == client)
-        {
-          wl_list_remove (wl_resource_get_link (resource));
-          wl_list_insert (destination, wl_resource_get_link (resource));
-        }
-    }
-}
-
-void
-meta_wayland_gtk_text_input_set_focus (MetaWaylandGtkTextInput *text_input,
-                                       MetaWaylandSurface      *surface)
-{
-  if (text_input->surface == surface)
-    return;
-
-  text_input->pending_state = META_WAYLAND_PENDING_STATE_NONE;
-
-  if (text_input->surface)
-    {
-      if (!wl_list_empty (&text_input->focus_resource_list))
-        {
-          ClutterInputFocus *focus = text_input->input_focus;
-          ClutterInputMethod *input_method;
-          struct wl_resource *resource;
-          uint32_t serial;
-
-          if (clutter_input_focus_is_focused (focus))
-            {
-              input_method = clutter_backend_get_input_method (clutter_get_default_backend ());
-              clutter_input_method_focus_out (input_method);
-            }
-
-          serial = wl_display_next_serial (text_input->seat->wl_display);
-
-          wl_resource_for_each (resource, &text_input->focus_resource_list)
-            {
-              gtk_text_input_send_leave (resource, serial,
-                                         text_input->surface->resource);
-            }
-
-          move_resources (&text_input->resource_list,
-                          &text_input->focus_resource_list);
-        }
-
-      wl_list_remove (&text_input->surface_listener.link);
-      text_input->surface = NULL;
-    }
-
-  if (surface)
-    {
-      struct wl_resource *focus_surface_resource;
-
-      text_input->surface = surface;
-      focus_surface_resource = text_input->surface->resource;
-      wl_resource_add_destroy_listener (focus_surface_resource,
-                                        &text_input->surface_listener);
-
-      move_resources_for_client (&text_input->focus_resource_list,
-                                 &text_input->resource_list,
-                                 wl_resource_get_client (focus_surface_resource));
-
-      if (!wl_list_empty (&text_input->focus_resource_list))
-        {
-          struct wl_resource *resource;
-
-          text_input->focus_serial =
-            wl_display_next_serial (text_input->seat->wl_display);
-
-          wl_resource_for_each (resource, &text_input->focus_resource_list)
-            {
-              gtk_text_input_send_enter (resource, text_input->focus_serial,
-                                         surface->resource);
-            }
-        }
-    }
-}
-
-static void
-unbind_resource (struct wl_resource *resource)
-{
-  wl_list_remove (wl_resource_get_link (resource));
-}
-
-static void
-text_input_destroy (struct wl_client   *client,
-                    struct wl_resource *resource)
-{
-  wl_resource_destroy (resource);
-}
-
-static void
-text_input_enable (struct wl_client   *client,
-                   struct wl_resource *resource,
-                   uint32_t            serial,
-                   uint32_t            flags)
-{
-  MetaWaylandGtkTextInput *text_input = wl_resource_get_user_data (resource);
-  ClutterInputFocus *focus = text_input->input_focus;
-  ClutterInputMethod *input_method;
-  gboolean show_preedit;
-
-  if (serial != text_input->focus_serial)
-    return;
-
-  if (!clutter_input_focus_is_focused (focus))
-    {
-      input_method = clutter_backend_get_input_method (clutter_get_default_backend ());
-      if (input_method)
-        clutter_input_method_focus_in (input_method, focus);
-      else
-        return;
-    }
-
-  show_preedit = (flags & GTK_TEXT_INPUT_ENABLE_FLAGS_CAN_SHOW_PREEDIT) != 0;
-  clutter_input_focus_set_can_show_preedit (focus, show_preedit);
-
-  if (flags & GTK_TEXT_INPUT_ENABLE_FLAGS_TOGGLE_INPUT_PANEL)
-    clutter_input_focus_set_input_panel_state (focus, CLUTTER_INPUT_PANEL_STATE_TOGGLE);
-}
-
-static void
-text_input_disable (struct wl_client   *client,
-                    struct wl_resource *resource)
-{
-  MetaWaylandGtkTextInput *text_input = wl_resource_get_user_data (resource);
-  ClutterInputFocus *focus = text_input->input_focus;
-  ClutterInputMethod *input_method;
-
-  if (!clutter_input_focus_is_focused (focus))
-    return;
-
-  clutter_input_focus_reset (text_input->input_focus);
-  text_input->pending_state = META_WAYLAND_PENDING_STATE_NONE;
-
-  input_method = clutter_backend_get_input_method (clutter_get_default_backend ());
-  clutter_input_method_focus_out (input_method);
-}
-
-static void
-text_input_set_surrounding_text (struct wl_client   *client,
-                                 struct wl_resource *resource,
-                                 const char         *text,
-                                 int32_t             cursor,
-                                 int32_t             anchor)
-{
-  MetaWaylandGtkTextInput *text_input = wl_resource_get_user_data (resource);
-
-  g_free (text_input->surrounding.text);
-  text_input->surrounding.text = g_strdup (text);
-  text_input->surrounding.cursor = cursor;
-  text_input->surrounding.anchor = anchor;
-  text_input->pending_state |= META_WAYLAND_PENDING_STATE_SURROUNDING_TEXT;
-}
-
-static ClutterInputContentHintFlags
-translate_hints (uint32_t hints)
-{
-  ClutterInputContentHintFlags clutter_hints = 0;
-
-  if (hints & GTK_TEXT_INPUT_CONTENT_HINT_COMPLETION)
-    clutter_hints |= CLUTTER_INPUT_CONTENT_HINT_COMPLETION;
-  if (hints & GTK_TEXT_INPUT_CONTENT_HINT_SPELLCHECK)
-    clutter_hints |= CLUTTER_INPUT_CONTENT_HINT_SPELLCHECK;
-  if (hints & GTK_TEXT_INPUT_CONTENT_HINT_AUTO_CAPITALIZATION)
-    clutter_hints |= CLUTTER_INPUT_CONTENT_HINT_AUTO_CAPITALIZATION;
-  if (hints & GTK_TEXT_INPUT_CONTENT_HINT_LOWERCASE)
-    clutter_hints |= CLUTTER_INPUT_CONTENT_HINT_LOWERCASE;
-  if (hints & GTK_TEXT_INPUT_CONTENT_HINT_UPPERCASE)
-    clutter_hints |= CLUTTER_INPUT_CONTENT_HINT_UPPERCASE;
-  if (hints & GTK_TEXT_INPUT_CONTENT_HINT_TITLECASE)
-    clutter_hints |= CLUTTER_INPUT_CONTENT_HINT_TITLECASE;
-  if (hints & GTK_TEXT_INPUT_CONTENT_HINT_HIDDEN_TEXT)
-    clutter_hints |= CLUTTER_INPUT_CONTENT_HINT_HIDDEN_TEXT;
-  if (hints & GTK_TEXT_INPUT_CONTENT_HINT_SENSITIVE_DATA)
-    clutter_hints |= CLUTTER_INPUT_CONTENT_HINT_SENSITIVE_DATA;
-  if (hints & GTK_TEXT_INPUT_CONTENT_HINT_LATIN)
-    clutter_hints |= CLUTTER_INPUT_CONTENT_HINT_LATIN;
-  if (hints & GTK_TEXT_INPUT_CONTENT_HINT_MULTILINE)
-    clutter_hints |= CLUTTER_INPUT_CONTENT_HINT_MULTILINE;
-
-  return clutter_hints;
-}
-
-static ClutterInputContentPurpose
-translate_purpose (uint32_t purpose)
-{
-  switch (purpose)
-    {
-    case GTK_TEXT_INPUT_CONTENT_PURPOSE_NORMAL:
-      return CLUTTER_INPUT_CONTENT_PURPOSE_NORMAL;
-    case GTK_TEXT_INPUT_CONTENT_PURPOSE_ALPHA:
-      return CLUTTER_INPUT_CONTENT_PURPOSE_ALPHA;
-    case GTK_TEXT_INPUT_CONTENT_PURPOSE_DIGITS:
-      return CLUTTER_INPUT_CONTENT_PURPOSE_DIGITS;
-    case GTK_TEXT_INPUT_CONTENT_PURPOSE_NUMBER:
-      return CLUTTER_INPUT_CONTENT_PURPOSE_NUMBER;
-    case GTK_TEXT_INPUT_CONTENT_PURPOSE_PHONE:
-      return CLUTTER_INPUT_CONTENT_PURPOSE_PHONE;
-    case GTK_TEXT_INPUT_CONTENT_PURPOSE_URL:
-      return CLUTTER_INPUT_CONTENT_PURPOSE_URL;
-    case GTK_TEXT_INPUT_CONTENT_PURPOSE_EMAIL:
-      return CLUTTER_INPUT_CONTENT_PURPOSE_EMAIL;
-    case GTK_TEXT_INPUT_CONTENT_PURPOSE_NAME:
-      return CLUTTER_INPUT_CONTENT_PURPOSE_NAME;
-    case GTK_TEXT_INPUT_CONTENT_PURPOSE_PASSWORD:
-      return CLUTTER_INPUT_CONTENT_PURPOSE_PASSWORD;
-    case GTK_TEXT_INPUT_CONTENT_PURPOSE_DATE:
-      return CLUTTER_INPUT_CONTENT_PURPOSE_DATE;
-    case GTK_TEXT_INPUT_CONTENT_PURPOSE_TIME:
-      return CLUTTER_INPUT_CONTENT_PURPOSE_TIME;
-    case GTK_TEXT_INPUT_CONTENT_PURPOSE_DATETIME:
-      return CLUTTER_INPUT_CONTENT_PURPOSE_DATETIME;
-    case GTK_TEXT_INPUT_CONTENT_PURPOSE_TERMINAL:
-      return CLUTTER_INPUT_CONTENT_PURPOSE_TERMINAL;
-    }
-
-  g_warn_if_reached ();
-  return CLUTTER_INPUT_CONTENT_PURPOSE_NORMAL;
-}
-
-static void
-text_input_set_content_type (struct wl_client   *client,
-                             struct wl_resource *resource,
-                             uint32_t            hint,
-                             uint32_t            purpose)
-{
-  MetaWaylandGtkTextInput *text_input = wl_resource_get_user_data (resource);
-
-  if (!text_input->surface)
-    return;
-
-  text_input->content_type_hint = hint;
-  text_input->content_type_purpose = purpose;
-  text_input->pending_state |= META_WAYLAND_PENDING_STATE_CONTENT_TYPE;
-}
-
-static void
-text_input_set_cursor_rectangle (struct wl_client   *client,
-                                 struct wl_resource *resource,
-                                 int32_t             x,
-                                 int32_t             y,
-                                 int32_t             width,
-                                 int32_t             height)
-{
-  MetaWaylandGtkTextInput *text_input = wl_resource_get_user_data (resource);
-
-  if (!text_input->surface)
-    return;
-
-  text_input->cursor_rect = (cairo_rectangle_int_t) { x, y, width, height };
-  text_input->pending_state |= META_WAYLAND_PENDING_STATE_INPUT_RECT;
-}
-
-static void
-text_input_commit_state (struct wl_client   *client,
-                         struct wl_resource *resource)
-{
-  MetaWaylandGtkTextInput *text_input = wl_resource_get_user_data (resource);
-  ClutterInputFocus *focus = text_input->input_focus;
-
-  if (!clutter_input_focus_is_focused (focus))
-    return;
-  if (text_input->surface == NULL)
-    return;
-
-  if (text_input->pending_state & META_WAYLAND_PENDING_STATE_CONTENT_TYPE)
-    {
-      clutter_input_focus_set_content_hints (text_input->input_focus,
-                                             translate_hints (text_input->content_type_hint));
-      clutter_input_focus_set_content_purpose (text_input->input_focus,
-                                               translate_purpose (text_input->content_type_purpose));
-    }
-
-  if (text_input->pending_state & META_WAYLAND_PENDING_STATE_SURROUNDING_TEXT)
-    {
-      clutter_input_focus_set_surrounding (text_input->input_focus,
-                                           text_input->surrounding.text,
-                                           text_input->surrounding.cursor,
-                                           text_input->surrounding.anchor);
-    }
-
-  if (text_input->pending_state & META_WAYLAND_PENDING_STATE_INPUT_RECT)
-    {
-      graphene_rect_t cursor_rect;
-      float x1, y1, x2, y2;
-      cairo_rectangle_int_t rect;
-
-      rect = text_input->cursor_rect;
-      meta_wayland_surface_get_absolute_coordinates (text_input->surface,
-                                                     rect.x, rect.y, &x1, &y1);
-      meta_wayland_surface_get_absolute_coordinates (text_input->surface,
-                                                     rect.x + rect.width,
-                                                     rect.y + rect.height,
-                                                     &x2, &y2);
-
-      graphene_rect_init (&cursor_rect, x1, y1, x2 - x1, y2 - y1);
-      clutter_input_focus_set_cursor_location (text_input->input_focus,
-                                               &cursor_rect);
-    }
-
-  text_input->pending_state = META_WAYLAND_PENDING_STATE_NONE;
-}
-
-static struct gtk_text_input_interface meta_text_input_interface = {
-  text_input_destroy,
-  text_input_enable,
-  text_input_disable,
-  text_input_set_surrounding_text,
-  text_input_set_content_type,
-  text_input_set_cursor_rectangle,
-  text_input_commit_state,
-};
-
-MetaWaylandGtkTextInput *
-meta_wayland_gtk_text_input_new (MetaWaylandSeat *seat)
-{
-  MetaWaylandGtkTextInput *text_input;
-
-  text_input = g_new0 (MetaWaylandGtkTextInput, 1);
-  text_input->input_focus = meta_wayland_text_input_focus_new (text_input);
-  text_input->seat = seat;
-
-  wl_list_init (&text_input->resource_list);
-  wl_list_init (&text_input->focus_resource_list);
-  text_input->surface_listener.notify = text_input_handle_focus_surface_destroy;
-
-  return text_input;
-}
-
-void
-meta_wayland_gtk_text_input_destroy (MetaWaylandGtkTextInput *text_input)
-{
-  meta_wayland_gtk_text_input_set_focus (text_input, NULL);
-  g_object_unref (text_input->input_focus);
-  g_free (text_input);
-}
-
-static void
-meta_wayland_text_input_create_new_resource (MetaWaylandGtkTextInput *text_input,
-                                             struct wl_client        *client,
-                                             struct wl_resource      *seat_resource,
-                                             uint32_t                 id)
-{
-  struct wl_resource *text_input_resource;
-
-  text_input_resource = wl_resource_create (client,
-                                            &gtk_text_input_interface,
-                                            META_GTK_TEXT_INPUT_VERSION,
-                                            id);
-
-  wl_resource_set_implementation (text_input_resource,
-                                  &meta_text_input_interface,
-                                  text_input, unbind_resource);
-
-  if (text_input->surface &&
-      wl_resource_get_client (text_input->surface->resource) == client)
-    {
-      wl_list_insert (&text_input->focus_resource_list,
-                      wl_resource_get_link (text_input_resource));
-
-      gtk_text_input_send_enter (text_input_resource,
-                                 text_input->focus_serial,
-                                 text_input->surface->resource);
-    }
-  else
-    {
-      wl_list_insert (&text_input->resource_list,
-                      wl_resource_get_link (text_input_resource));
-    }
-}
-
-static void
-text_input_manager_destroy (struct wl_client   *client,
-                            struct wl_resource *resource)
-{
-  wl_resource_destroy (resource);
-}
-
-static void
-text_input_manager_get_text_input (struct wl_client   *client,
-                                   struct wl_resource *resource,
-                                   uint32_t            id,
-                                   struct wl_resource *seat_resource)
-{
-  MetaWaylandSeat *seat = wl_resource_get_user_data (seat_resource);
-
-  meta_wayland_text_input_create_new_resource (seat->gtk_text_input, client,
-                                               seat_resource, id);
-}
-
-static struct gtk_text_input_manager_interface meta_text_input_manager_interface = {
-  text_input_manager_destroy,
-  text_input_manager_get_text_input,
-};
-
-static void
-bind_text_input (struct wl_client *client,
-		 void             *data,
-		 uint32_t          version,
-		 uint32_t          id)
-{
-  struct wl_resource *resource;
-
-  resource = wl_resource_create (client,
-                                 &gtk_text_input_manager_interface,
-				 META_GTK_TEXT_INPUT_VERSION,
-                                 id);
-  wl_resource_set_implementation (resource,
-                                  &meta_text_input_manager_interface,
-                                  NULL, NULL);
-}
-
-gboolean
-meta_wayland_gtk_text_input_init (MetaWaylandCompositor *compositor)
-{
-  return (wl_global_create (compositor->wayland_display,
-                            &gtk_text_input_manager_interface,
-                            META_GTK_TEXT_INPUT_VERSION,
-                            compositor->seat->gtk_text_input,
-                            bind_text_input) != NULL);
-}
-
-gboolean
-meta_wayland_gtk_text_input_handle_event (MetaWaylandGtkTextInput *text_input,
-                                          const ClutterEvent      *event)
-{
-  if (!text_input->surface ||
-      !clutter_input_focus_is_focused (text_input->input_focus))
-    return FALSE;
-
-  return clutter_input_focus_filter_event (text_input->input_focus, event);
-}
diff --git a/src/wayland/meta-wayland-text-input-legacy.h b/src/wayland/meta-wayland-text-input-legacy.h
deleted file mode 100644
index 55bfed809..000000000
--- a/src/wayland/meta-wayland-text-input-legacy.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (C) 2017 Red Hat
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- *
- * Author: Carlos Garnacho <carlosg@gnome.org>
- */
-
-#ifndef META_WAYLAND_GTK_TEXT_INPUT_H
-#define META_WAYLAND_GTK_TEXT_INPUT_H
-
-#include <wayland-server.h>
-
-#include "meta/window.h"
-#include "wayland/meta-wayland-types.h"
-
-typedef struct _MetaWaylandGtkTextInput MetaWaylandGtkTextInput;
-
-MetaWaylandGtkTextInput * meta_wayland_gtk_text_input_new (MetaWaylandSeat *seat);
-void meta_wayland_gtk_text_input_destroy (MetaWaylandGtkTextInput *text_input);
-
-gboolean meta_wayland_gtk_text_input_init (MetaWaylandCompositor *compositor);
-
-void meta_wayland_gtk_text_input_set_focus (MetaWaylandGtkTextInput *text_input,
-                                            MetaWaylandSurface      *surface);
-
-gboolean meta_wayland_gtk_text_input_handle_event (MetaWaylandGtkTextInput *text_input,
-                                                   const ClutterEvent      *event);
-
-#endif /* META_WAYLAND_GTK_TEXT_INPUT_H */
diff --git a/src/wayland/meta-wayland-touch.c b/src/wayland/meta-wayland-touch.c
index 0280195e8..15f0312eb 100644
--- a/src/wayland/meta-wayland-touch.c
+++ b/src/wayland/meta-wayland-touch.c
@@ -177,11 +177,8 @@ touch_get_info (MetaWaylandTouch     *touch,
 
   touch_info = g_hash_table_lookup (touch->touches, sequence);
 
-  if (create)
+  if (!touch_info && create)
     {
-      if (touch_info != NULL)
-        g_warning ("Stale touch information for sequence slot %p", sequence);
-
       touch_info = g_new0 (MetaWaylandTouchInfo, 1);
       touch_info->slot = clutter_event_sequence_get_slot (sequence);
       g_hash_table_insert (touch->touches, sequence, touch_info);
diff --git a/src/wayland/meta-wayland-types.h b/src/wayland/meta-wayland-types.h
index aeb6f6178..b2c8615a5 100644
--- a/src/wayland/meta-wayland-types.h
+++ b/src/wayland/meta-wayland-types.h
@@ -63,4 +63,6 @@ typedef struct _MetaWaylandPointerClient MetaWaylandPointerClient;
 
 typedef struct _MetaWaylandActivation MetaWaylandActivation;
 
+typedef struct _MetaWaylandDmaBufManager MetaWaylandDmaBufManager;
+
 #endif
diff --git a/src/wayland/meta-wayland-versions.h b/src/wayland/meta-wayland-versions.h
index 0e859b900..598bdd2e5 100644
--- a/src/wayland/meta-wayland-versions.h
+++ b/src/wayland/meta-wayland-versions.h
@@ -39,20 +39,17 @@
 #define META_WL_DATA_DEVICE_MANAGER_VERSION 3
 #define META_XDG_WM_BASE_VERSION            3
 #define META_ZXDG_SHELL_V6_VERSION          1
-#define META_WL_SHELL_VERSION               1
 #define META_WL_SEAT_VERSION                5
 #define META_WL_OUTPUT_VERSION              2
 #define META_XSERVER_VERSION                1
 #define META_GTK_SHELL1_VERSION             5
 #define META_WL_SUBCOMPOSITOR_VERSION       1
-#define META_ZWP_POINTER_GESTURES_V1_VERSION    1
+#define META_ZWP_POINTER_GESTURES_V1_VERSION 3
 #define META_ZXDG_EXPORTER_V1_VERSION       1
 #define META_ZXDG_IMPORTER_V1_VERSION       1
-#define META_ZWP_LINUX_DMABUF_V1_VERSION    3
 #define META_ZWP_KEYBOARD_SHORTCUTS_INHIBIT_V1_VERSION 1
 #define META_ZXDG_OUTPUT_V1_VERSION         3
 #define META_ZWP_XWAYLAND_KEYBOARD_GRAB_V1_VERSION 1
-#define META_GTK_TEXT_INPUT_VERSION         1
 #define META_ZWP_TEXT_INPUT_V3_VERSION      1
 #define META_WP_VIEWPORTER_VERSION          1
 #define META_GTK_PRIMARY_SELECTION_VERSION  1
diff --git a/src/wayland/meta-wayland-window-configuration.c b/src/wayland/meta-wayland-window-configuration.c
index 19f27cb62..8349d2ac3 100644
--- a/src/wayland/meta-wayland-window-configuration.c
+++ b/src/wayland/meta-wayland-window-configuration.c
@@ -30,7 +30,7 @@ is_window_size_fixed (MetaWindow *window)
   if (meta_window_is_fullscreen (window))
     return TRUE;
 
-  if (meta_window_get_maximized (window) |
+  if (meta_window_get_maximized (window) &
       (META_MAXIMIZE_VERTICAL | META_MAXIMIZE_HORIZONTAL))
     return TRUE;
 
diff --git a/src/wayland/meta-wayland-wl-shell.c b/src/wayland/meta-wayland-wl-shell.c
deleted file mode 100644
index 964c185b2..000000000
--- a/src/wayland/meta-wayland-wl-shell.c
+++ /dev/null
@@ -1,777 +0,0 @@
-/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
-
-/*
- * Copyright (C) 2012-2013 Intel Corporation
- * Copyright (C) 2013-2015 Red Hat Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- *
- */
-
-#include "config.h"
-
-#include "wayland/meta-wayland-wl-shell.h"
-
-#include "core/window-private.h"
-#include "wayland/meta-wayland-popup.h"
-#include "wayland/meta-wayland-private.h"
-#include "wayland/meta-wayland-seat.h"
-#include "wayland/meta-wayland-shell-surface.h"
-#include "wayland/meta-wayland-surface.h"
-#include "wayland/meta-wayland-versions.h"
-#include "wayland/meta-wayland-window-configuration.h"
-#include "wayland/meta-wayland.h"
-#include "wayland/meta-window-wayland.h"
-
-typedef enum
-{
-  META_WL_SHELL_SURFACE_STATE_NONE,
-  META_WL_SHELL_SURFACE_STATE_TOPLEVEL,
-  META_WL_SHELL_SURFACE_STATE_POPUP,
-  META_WL_SHELL_SURFACE_STATE_TRANSIENT,
-  META_WL_SHELL_SURFACE_STATE_FULLSCREEN,
-  META_WL_SHELL_SURFACE_STATE_MAXIMIZED,
-} MetaWlShellSurfaceState;
-
-struct _MetaWaylandWlShellSurface
-{
-  MetaWaylandShellSurface parent;
-
-  struct wl_resource *resource;
-
-  MetaWlShellSurfaceState state;
-
-  char *title;
-  char *wm_class;
-
-  MetaWaylandSurface *parent_surface;
-  GList *children;
-
-  MetaWaylandSeat *popup_seat;
-  MetaWaylandPopup *popup;
-  gboolean pending_popup;
-
-  int x;
-  int y;
-
-  uint32_t emulated_ack_configure_serial;
-};
-
-static void
-popup_surface_iface_init (MetaWaylandPopupSurfaceInterface *iface);
-
-G_DEFINE_TYPE_WITH_CODE (MetaWaylandWlShellSurface,
-                         meta_wayland_wl_shell_surface,
-                         META_TYPE_WAYLAND_SHELL_SURFACE,
-                         G_IMPLEMENT_INTERFACE (META_TYPE_WAYLAND_POPUP_SURFACE,
-                                                popup_surface_iface_init));
-
-static MetaWaylandSurface *
-surface_from_wl_shell_surface_resource (struct wl_resource *resource)
-{
-  MetaWaylandWlShellSurface *wl_shell_surface =
-    wl_resource_get_user_data (resource);
-  MetaWaylandSurfaceRole *surface_role =
-    META_WAYLAND_SURFACE_ROLE (wl_shell_surface);
-
-  return meta_wayland_surface_role_get_surface (surface_role);
-}
-
-static void
-sync_wl_shell_parent_relationship (MetaWaylandSurface *surface,
-                                   MetaWaylandSurface *parent);
-
-static void
-wl_shell_surface_destructor (struct wl_resource *resource)
-{
-  MetaWaylandWlShellSurface *wl_shell_surface =
-    META_WAYLAND_WL_SHELL_SURFACE (wl_resource_get_user_data (resource));
-  MetaWaylandSurface *surface =
-    surface_from_wl_shell_surface_resource (resource);
-  GList *l;
-
-  if (wl_shell_surface->popup)
-    meta_wayland_popup_dismiss (wl_shell_surface->popup);
-
-  for (l = wl_shell_surface->children; l; l = l->next)
-    {
-      MetaWaylandSurface *child_surface = l->data;
-      MetaWaylandWlShellSurface *child_wl_shell_surface =
-        META_WAYLAND_WL_SHELL_SURFACE (child_surface->role);
-
-      child_wl_shell_surface->parent_surface = NULL;
-
-      if (child_wl_shell_surface->parent_surface == surface)
-        {
-          meta_wayland_popup_dismiss (child_wl_shell_surface->popup);
-          child_wl_shell_surface->parent_surface = NULL;
-        }
-    }
-
-  if (wl_shell_surface->parent_surface)
-    {
-      MetaWaylandSurface *parent_surface = wl_shell_surface->parent_surface;
-      MetaWaylandWlShellSurface *parent_wl_shell_surface =
-        META_WAYLAND_WL_SHELL_SURFACE (parent_surface->role);
-
-      parent_wl_shell_surface->children =
-        g_list_remove (parent_wl_shell_surface->children, surface);
-    }
-
-  g_free (wl_shell_surface->title);
-  g_free (wl_shell_surface->wm_class);
-
-  if (wl_shell_surface->popup)
-    {
-      wl_shell_surface->parent_surface = NULL;
-
-      meta_wayland_popup_dismiss (wl_shell_surface->popup);
-    }
-
-  wl_shell_surface->resource = NULL;
-}
-
-static void
-wl_shell_surface_pong (struct wl_client   *client,
-                       struct wl_resource *resource,
-                       uint32_t serial)
-{
-  MetaDisplay *display = meta_get_display ();
-
-  meta_display_pong_for_serial (display, serial);
-}
-
-static void
-wl_shell_surface_move (struct wl_client   *client,
-                       struct wl_resource *resource,
-                       struct wl_resource *seat_resource,
-                       uint32_t serial)
-{
-  MetaWaylandSeat *seat = wl_resource_get_user_data (seat_resource);
-  MetaWaylandSurface *surface =
-    surface_from_wl_shell_surface_resource (resource);
-  gfloat x, y;
-
-  if (!meta_wayland_seat_get_grab_info (seat, surface, serial, TRUE, &x, &y))
-    return;
-
-  meta_wayland_surface_begin_grab_op (surface, seat, META_GRAB_OP_MOVING, x, y);
-}
-
-static MetaGrabOp
-grab_op_for_wl_shell_surface_resize_edge (int edge)
-{
-  MetaGrabOp op = META_GRAB_OP_WINDOW_BASE;
-
-  if (edge & WL_SHELL_SURFACE_RESIZE_TOP)
-    op |= META_GRAB_OP_WINDOW_DIR_NORTH;
-  if (edge & WL_SHELL_SURFACE_RESIZE_BOTTOM)
-    op |= META_GRAB_OP_WINDOW_DIR_SOUTH;
-  if (edge & WL_SHELL_SURFACE_RESIZE_LEFT)
-    op |= META_GRAB_OP_WINDOW_DIR_WEST;
-  if (edge & WL_SHELL_SURFACE_RESIZE_RIGHT)
-    op |= META_GRAB_OP_WINDOW_DIR_EAST;
-
-  if (op == META_GRAB_OP_WINDOW_BASE)
-    {
-      g_warning ("invalid edge: %d", edge);
-      return META_GRAB_OP_NONE;
-    }
-
-  return op;
-}
-
-static void
-wl_shell_surface_resize (struct wl_client   *client,
-                         struct wl_resource *resource,
-                         struct wl_resource *seat_resource,
-                         uint32_t            serial,
-                         uint32_t            edges)
-{
-  MetaWaylandSeat *seat = wl_resource_get_user_data (seat_resource);
-  MetaWaylandSurface *surface =
-    surface_from_wl_shell_surface_resource (resource);
-  gfloat x, y;
-  MetaGrabOp grab_op;
-
-  if (!meta_wayland_seat_get_grab_info (seat, surface, serial, TRUE, &x, &y))
-    return;
-
-  grab_op = grab_op_for_wl_shell_surface_resize_edge (edges);
-  meta_wayland_surface_begin_grab_op (surface, seat, grab_op, x, y);
-}
-
-static void
-wl_shell_surface_set_state (MetaWaylandSurface     *surface,
-                            MetaWlShellSurfaceState state)
-{
-  MetaWaylandWlShellSurface *wl_shell_surface =
-    META_WAYLAND_WL_SHELL_SURFACE (surface->role);
-  MetaWlShellSurfaceState old_state = wl_shell_surface->state;
-  MetaWindow *window;
-
-  wl_shell_surface->state = state;
-
-  window = meta_wayland_surface_get_window (surface);
-  if (window && old_state != state)
-    {
-      if (old_state == META_WL_SHELL_SURFACE_STATE_POPUP &&
-          wl_shell_surface->popup)
-        {
-          meta_wayland_popup_dismiss (wl_shell_surface->popup);
-          wl_shell_surface->popup = NULL;
-        }
-
-      if (state == META_WL_SHELL_SURFACE_STATE_FULLSCREEN)
-        meta_window_make_fullscreen (window);
-      else
-        meta_window_unmake_fullscreen (window);
-
-      if (state == META_WL_SHELL_SURFACE_STATE_MAXIMIZED)
-        meta_window_maximize (window, META_MAXIMIZE_BOTH);
-      else
-        meta_window_unmaximize (window, META_MAXIMIZE_BOTH);
-    }
-}
-
-static void
-wl_shell_surface_set_toplevel (struct wl_client *client,
-                               struct wl_resource *resource)
-{
-  MetaWaylandSurface *surface =
-    surface_from_wl_shell_surface_resource (resource);
-
-  wl_shell_surface_set_state (surface,
-                              META_WL_SHELL_SURFACE_STATE_TOPLEVEL);
-}
-
-static void
-set_wl_shell_surface_parent (MetaWaylandSurface *surface,
-                             MetaWaylandSurface *parent)
-{
-  MetaWaylandWlShellSurface *wl_shell_surface =
-    META_WAYLAND_WL_SHELL_SURFACE (surface->role);
-  MetaWaylandWlShellSurface *parent_wl_shell_surface =
-    META_WAYLAND_WL_SHELL_SURFACE (parent->role);
-
-  if (wl_shell_surface->parent_surface)
-    {
-      MetaWaylandWlShellSurface *old_parent =
-        META_WAYLAND_WL_SHELL_SURFACE (wl_shell_surface->parent_surface->role);
-
-      old_parent->children = g_list_remove (old_parent->children, surface);
-    }
-
-  parent_wl_shell_surface->children =
-    g_list_append (parent_wl_shell_surface->children, surface);
-  wl_shell_surface->parent_surface = parent;
-}
-
-static void
-wl_shell_surface_set_transient (struct wl_client   *client,
-                                struct wl_resource *resource,
-                                struct wl_resource *parent_resource,
-                                int32_t             x,
-                                int32_t             y,
-                                uint32_t            flags)
-{
-  MetaWaylandWlShellSurface *wl_shell_surface =
-    META_WAYLAND_WL_SHELL_SURFACE (wl_resource_get_user_data (resource));
-  MetaWaylandSurface *surface =
-    surface_from_wl_shell_surface_resource (resource);
-  MetaWaylandSurface *parent_surf = wl_resource_get_user_data (parent_resource);
-
-  wl_shell_surface_set_state (surface,
-                              META_WL_SHELL_SURFACE_STATE_TRANSIENT);
-
-  set_wl_shell_surface_parent (surface, parent_surf);
-  wl_shell_surface->x = x;
-  wl_shell_surface->y = y;
-
-  if (meta_wayland_surface_get_window (surface) &&
-      meta_wayland_surface_get_window (parent_surf))
-    sync_wl_shell_parent_relationship (surface, parent_surf);
-}
-
-static void
-wl_shell_surface_set_fullscreen (struct wl_client   *client,
-                                 struct wl_resource *resource,
-                                 uint32_t            method,
-                                 uint32_t            framerate,
-                                 struct wl_resource *output)
-{
-  MetaWaylandSurface *surface =
-    surface_from_wl_shell_surface_resource (resource);
-
-  wl_shell_surface_set_state (surface,
-                              META_WL_SHELL_SURFACE_STATE_FULLSCREEN);
-}
-
-static void
-meta_wayland_wl_shell_surface_create_popup (MetaWaylandWlShellSurface *wl_shell_surface)
-{
-  MetaWaylandPopupSurface *popup_surface =
-    META_WAYLAND_POPUP_SURFACE (wl_shell_surface);
-  MetaWaylandSeat *seat = wl_shell_surface->popup_seat;
-  MetaWaylandPopup *popup;
-
-  popup = meta_wayland_pointer_start_popup_grab (seat->pointer, popup_surface);
-  if (!popup)
-    {
-      wl_shell_surface_send_popup_done (wl_shell_surface->resource);
-      return;
-    }
-
-  wl_shell_surface->popup = popup;
-}
-
-static void
-wl_shell_surface_set_popup (struct wl_client   *client,
-                            struct wl_resource *resource,
-                            struct wl_resource *seat_resource,
-                            uint32_t            serial,
-                            struct wl_resource *parent_resource,
-                            int32_t             x,
-                            int32_t             y,
-                            uint32_t            flags)
-{
-  MetaWaylandWlShellSurface *wl_shell_surface =
-    META_WAYLAND_WL_SHELL_SURFACE (wl_resource_get_user_data (resource));
-  MetaWaylandSurface *surface =
-    surface_from_wl_shell_surface_resource (resource);
-  MetaWaylandSurface *parent_surf = wl_resource_get_user_data (parent_resource);
-  MetaWaylandSeat *seat = wl_resource_get_user_data (seat_resource);
-
-  if (wl_shell_surface->popup)
-    {
-      wl_shell_surface->parent_surface = NULL;
-
-      meta_wayland_popup_dismiss (wl_shell_surface->popup);
-    }
-
-  wl_shell_surface_set_state (surface,
-                              META_WL_SHELL_SURFACE_STATE_POPUP);
-
-  if (!meta_wayland_seat_can_popup (seat, serial))
-    {
-      wl_shell_surface_send_popup_done (resource);
-      return;
-    }
-
-  set_wl_shell_surface_parent (surface, parent_surf);
-  wl_shell_surface->popup_seat = seat;
-  wl_shell_surface->x = x;
-  wl_shell_surface->y = y;
-  wl_shell_surface->pending_popup = TRUE;
-
-  if (meta_wayland_surface_get_window (surface) &&
-      meta_wayland_surface_get_window (parent_surf))
-    sync_wl_shell_parent_relationship (surface, parent_surf);
-}
-
-static void
-wl_shell_surface_set_maximized (struct wl_client   *client,
-                                struct wl_resource *resource,
-                                struct wl_resource *output)
-{
-  MetaWaylandSurface *surface =
-    surface_from_wl_shell_surface_resource (resource);
-
-  wl_shell_surface_set_state (surface,
-                              META_WL_SHELL_SURFACE_STATE_MAXIMIZED);
-}
-
-static void
-wl_shell_surface_set_title (struct wl_client   *client,
-                            struct wl_resource *resource,
-                            const char         *title)
-{
-  MetaWaylandWlShellSurface *wl_shell_surface =
-    META_WAYLAND_WL_SHELL_SURFACE (wl_resource_get_user_data (resource));
-  MetaWaylandSurface *surface =
-    surface_from_wl_shell_surface_resource (resource);
-  MetaWindow *window;
-
-  g_clear_pointer (&wl_shell_surface->title, g_free);
-
-  if (!g_utf8_validate (title, -1, NULL))
-    title = "";
-
-  wl_shell_surface->title = g_strdup (title);
-
-  window = meta_wayland_surface_get_window (surface);
-  if (window)
-    meta_window_set_title (window, title);
-}
-
-static void
-wl_shell_surface_set_class (struct wl_client *client,
-                            struct wl_resource *resource,
-                            const char *class_)
-{
-  MetaWaylandWlShellSurface *wl_shell_surface =
-    META_WAYLAND_WL_SHELL_SURFACE (wl_resource_get_user_data (resource));
-  MetaWaylandSurface *surface =
-    surface_from_wl_shell_surface_resource (resource);
-  MetaWindow *window;
-
-  g_clear_pointer (&wl_shell_surface->wm_class, g_free);
-
-  if (!g_utf8_validate (class_, -1, NULL))
-    class_ = "";
-
-  wl_shell_surface->wm_class = g_strdup (class_);
-
-  window = meta_wayland_surface_get_window (surface);
-  if (window)
-    meta_window_set_wm_class (window, class_, class_);
-}
-
-static const struct wl_shell_surface_interface meta_wayland_wl_shell_surface_interface = {
-  wl_shell_surface_pong,
-  wl_shell_surface_move,
-  wl_shell_surface_resize,
-  wl_shell_surface_set_toplevel,
-  wl_shell_surface_set_transient,
-  wl_shell_surface_set_fullscreen,
-  wl_shell_surface_set_popup,
-  wl_shell_surface_set_maximized,
-  wl_shell_surface_set_title,
-  wl_shell_surface_set_class,
-};
-
-static void
-sync_wl_shell_parent_relationship (MetaWaylandSurface *surface,
-                                   MetaWaylandSurface *parent)
-{
-  MetaWaylandWlShellSurface *wl_shell_surface =
-    META_WAYLAND_WL_SHELL_SURFACE (surface->role);
-  MetaWindow *window;
-  MetaWindow *parent_window;
-
-  window = meta_wayland_surface_get_window (surface);
-  parent_window = meta_wayland_surface_get_window (parent);
-  meta_window_set_transient_for (window, parent_window);
-
-  if (wl_shell_surface->state == META_WL_SHELL_SURFACE_STATE_POPUP ||
-      wl_shell_surface->state == META_WL_SHELL_SURFACE_STATE_TRANSIENT)
-    meta_window_wayland_place_relative_to (window,
-                                           parent_window,
-                                           wl_shell_surface->x,
-                                           wl_shell_surface->y);
-
-  if (wl_shell_surface->state == META_WL_SHELL_SURFACE_STATE_POPUP &&
-      wl_shell_surface->pending_popup)
-    {
-      meta_wayland_wl_shell_surface_create_popup (wl_shell_surface);
-      wl_shell_surface->pending_popup = FALSE;
-    }
-}
-
-static void
-create_wl_shell_surface_window (MetaWaylandSurface *surface)
-{
-  MetaWaylandWlShellSurface *wl_shell_surface =
-    META_WAYLAND_WL_SHELL_SURFACE (surface->role);
-  MetaWaylandShellSurface *shell_surface =
-    META_WAYLAND_SHELL_SURFACE (wl_shell_surface);
-  MetaWaylandSurface *parent;
-  MetaWindow *window;
-  GList *l;
-
-  window = meta_window_wayland_new (meta_get_display (), surface);
-  meta_wayland_shell_surface_set_window (shell_surface, window);
-
-  if (wl_shell_surface->title)
-    meta_window_set_title (window, wl_shell_surface->title);
-  if (wl_shell_surface->wm_class)
-    meta_window_set_wm_class (window,
-                              wl_shell_surface->wm_class,
-                              wl_shell_surface->wm_class);
-
-  parent = wl_shell_surface->parent_surface;
-  if (parent && meta_wayland_surface_get_window (parent))
-    sync_wl_shell_parent_relationship (surface, parent);
-
-  for (l = wl_shell_surface->children; l; l = l->next)
-    {
-      MetaWaylandSurface *child = l->data;
-
-      if (meta_wayland_surface_get_window (child))
-        sync_wl_shell_parent_relationship (child, surface);
-    }
-}
-
-static void
-wl_shell_get_shell_surface (struct wl_client   *client,
-                            struct wl_resource *resource,
-                            uint32_t            id,
-                            struct wl_resource *surface_resource)
-{
-  MetaWaylandSurface *surface = wl_resource_get_user_data (surface_resource);
-  MetaWaylandWlShellSurface *wl_shell_surface;
-
-  if (META_IS_WAYLAND_WL_SHELL_SURFACE (surface->role) &&
-      META_WAYLAND_WL_SHELL_SURFACE (surface->role)->resource)
-    {
-      wl_resource_post_error (surface_resource,
-                              WL_DISPLAY_ERROR_INVALID_OBJECT,
-                              "wl_shell::get_shell_surface already requested");
-      return;
-    }
-
-  if (!meta_wayland_surface_assign_role (surface,
-                                         META_TYPE_WAYLAND_WL_SHELL_SURFACE,
-                                         NULL))
-    {
-      wl_resource_post_error (resource, WL_SHELL_ERROR_ROLE,
-                              "wl_surface@%d already has a different role",
-                              wl_resource_get_id (surface->resource));
-      return;
-    }
-
-  wl_shell_surface = META_WAYLAND_WL_SHELL_SURFACE (surface->role);
-  wl_shell_surface->resource =
-    wl_resource_create (client,
-                        &wl_shell_surface_interface,
-                        wl_resource_get_version (resource),
-                        id);
-  wl_resource_set_implementation (wl_shell_surface->resource,
-                                  &meta_wayland_wl_shell_surface_interface,
-                                  wl_shell_surface,
-                                  wl_shell_surface_destructor);
-
-  create_wl_shell_surface_window (surface);
-}
-
-static const struct wl_shell_interface meta_wayland_wl_shell_interface = {
-  wl_shell_get_shell_surface,
-};
-
-static void
-bind_wl_shell (struct wl_client *client,
-               void             *data,
-               uint32_t          version,
-               uint32_t          id)
-{
-  struct wl_resource *resource;
-
-  resource = wl_resource_create (client, &wl_shell_interface, version, id);
-  wl_resource_set_implementation (resource, &meta_wayland_wl_shell_interface, data, NULL);
-}
-
-static void
-wl_shell_surface_role_apply_state (MetaWaylandSurfaceRole  *surface_role,
-                                   MetaWaylandSurfaceState *pending)
-{
-  MetaWaylandWlShellSurface *wl_shell_surface =
-    META_WAYLAND_WL_SHELL_SURFACE (surface_role);
-  MetaWaylandShellSurface *shell_surface =
-    META_WAYLAND_SHELL_SURFACE (wl_shell_surface);
-  MetaWaylandSurfaceRoleClass *surface_role_class;
-  MetaWaylandSurface *surface =
-    meta_wayland_surface_role_get_surface (surface_role);
-  MetaWindow *window = meta_wayland_surface_get_window (surface);
-  cairo_region_t *input_region;
-  MetaRectangle geom = { 0 };
-
-  surface_role_class =
-    META_WAYLAND_SURFACE_ROLE_CLASS (meta_wayland_wl_shell_surface_parent_class);
-  surface_role_class->apply_state (surface_role, pending);
-
-  /* For wl_shell, it's equivalent to an unmap. Semantics
-   * are poorly defined, so we can choose some that are
-   * convenient for us. */
-  if (surface->buffer_ref->buffer && !window)
-    {
-      create_wl_shell_surface_window (surface);
-    }
-  else if (!surface->buffer_ref->buffer && window)
-    {
-      if (wl_shell_surface->popup)
-        meta_wayland_popup_dismiss (wl_shell_surface->popup);
-      else
-        meta_wayland_shell_surface_destroy_window (shell_surface);
-      return;
-    }
-
-  if (!window)
-    return;
-
-  input_region = meta_wayland_surface_calculate_input_region (surface);
-  if (!cairo_region_is_empty (input_region))
-    {
-      cairo_region_get_extents (input_region, &geom);
-      cairo_region_destroy (input_region);
-    }
-  else
-    {
-      meta_wayland_shell_surface_calculate_geometry (shell_surface, &geom);
-    }
-
-  pending->has_acked_configure_serial = TRUE;
-  pending->acked_configure_serial =
-    wl_shell_surface->emulated_ack_configure_serial;
-
-  meta_window_wayland_finish_move_resize (window, geom, pending);
-}
-
-static MetaWaylandSurface *
-wl_shell_surface_role_get_toplevel (MetaWaylandSurfaceRole *surface_role)
-{
-  MetaWaylandWlShellSurface *wl_shell_surface =
-    META_WAYLAND_WL_SHELL_SURFACE (surface_role);
-
-  if (wl_shell_surface->state == META_WL_SHELL_SURFACE_STATE_POPUP &&
-      wl_shell_surface->parent_surface)
-    return meta_wayland_surface_get_toplevel (wl_shell_surface->parent_surface);
-  else
-    return meta_wayland_surface_role_get_surface (surface_role);
-}
-
-static void
-wl_shell_surface_role_configure (MetaWaylandShellSurface        *shell_surface,
-                                 MetaWaylandWindowConfiguration *configuration)
-{
-  MetaWaylandWlShellSurface *wl_shell_surface =
-    META_WAYLAND_WL_SHELL_SURFACE (shell_surface);
-
-  if (!wl_shell_surface->resource)
-    return;
-
-  wl_shell_surface_send_configure (wl_shell_surface->resource,
-                                   0,
-                                   configuration->width / configuration->scale,
-                                   configuration->height / configuration->scale);
-
-  wl_shell_surface->emulated_ack_configure_serial = configuration->serial;
-}
-
-static void
-wl_shell_surface_role_managed (MetaWaylandShellSurface *shell_surface,
-                               MetaWindow              *window)
-{
-  MetaWaylandWlShellSurface *wl_shell_surface =
-    META_WAYLAND_WL_SHELL_SURFACE (shell_surface);
-
-  if (wl_shell_surface->state == META_WL_SHELL_SURFACE_STATE_POPUP)
-    meta_window_set_type (window, META_WINDOW_DROPDOWN_MENU);
-}
-
-static void
-wl_shell_surface_role_ping (MetaWaylandShellSurface *shell_surface,
-                            guint32                  serial)
-{
-  MetaWaylandWlShellSurface *wl_shell_surface =
-    META_WAYLAND_WL_SHELL_SURFACE (shell_surface);
-
-  wl_shell_surface_send_ping (wl_shell_surface->resource, serial);
-}
-
-static void
-wl_shell_surface_role_close (MetaWaylandShellSurface *shell_surface)
-{
-  /* Not supported by wl_shell_surface. */
-}
-
-static void
-meta_wayland_wl_shell_surface_popup_done (MetaWaylandPopupSurface *popup_surface)
-{
-  MetaWaylandWlShellSurface *wl_shell_surface =
-    META_WAYLAND_WL_SHELL_SURFACE (popup_surface);
-
-  wl_shell_surface_send_popup_done (wl_shell_surface->resource);
-}
-
-static void
-meta_wayland_wl_shell_surface_popup_dismiss (MetaWaylandPopupSurface *popup_surface)
-{
-  MetaWaylandWlShellSurface *wl_shell_surface =
-    META_WAYLAND_WL_SHELL_SURFACE (popup_surface);
-  MetaWaylandShellSurface *shell_surface =
-    META_WAYLAND_SHELL_SURFACE (wl_shell_surface);
-
-  wl_shell_surface->popup = NULL;
-
-  meta_wayland_shell_surface_destroy_window (shell_surface);
-}
-
-static MetaWaylandSurface *
-meta_wayland_wl_shell_surface_popup_get_surface (MetaWaylandPopupSurface *popup_surface)
-{
-  MetaWaylandSurfaceRole *surface_role =
-    META_WAYLAND_SURFACE_ROLE (popup_surface);
-
-  return meta_wayland_surface_role_get_surface (surface_role);
-}
-
-static void
-popup_surface_iface_init (MetaWaylandPopupSurfaceInterface *iface)
-{
-  iface->done = meta_wayland_wl_shell_surface_popup_done;
-  iface->dismiss = meta_wayland_wl_shell_surface_popup_dismiss;
-  iface->get_surface = meta_wayland_wl_shell_surface_popup_get_surface;
-}
-
-static void
-wl_shell_surface_role_finalize (GObject *object)
-{
-  MetaWaylandWlShellSurface *wl_shell_surface =
-    META_WAYLAND_WL_SHELL_SURFACE (object);
-  GObjectClass *object_class;
-
-  g_clear_pointer (&wl_shell_surface->resource, wl_resource_destroy);
-
-  object_class =
-    G_OBJECT_CLASS (meta_wayland_wl_shell_surface_parent_class);
-  object_class->finalize (object);
-}
-
-static void
-meta_wayland_wl_shell_surface_init (MetaWaylandWlShellSurface *wl_shell_surface)
-{
-}
-
-static void
-meta_wayland_wl_shell_surface_class_init (MetaWaylandWlShellSurfaceClass *klass)
-{
-  GObjectClass *object_class;
-  MetaWaylandSurfaceRoleClass *surface_role_class;
-  MetaWaylandShellSurfaceClass *shell_surface_class;
-
-  object_class = G_OBJECT_CLASS (klass);
-  object_class->finalize = wl_shell_surface_role_finalize;
-
-  surface_role_class = META_WAYLAND_SURFACE_ROLE_CLASS (klass);
-  surface_role_class->apply_state = wl_shell_surface_role_apply_state;
-  surface_role_class->get_toplevel = wl_shell_surface_role_get_toplevel;
-
-  shell_surface_class = META_WAYLAND_SHELL_SURFACE_CLASS (klass);
-  shell_surface_class->configure = wl_shell_surface_role_configure;
-  shell_surface_class->managed = wl_shell_surface_role_managed;
-  shell_surface_class->ping = wl_shell_surface_role_ping;
-  shell_surface_class->close = wl_shell_surface_role_close;
-}
-
-void
-meta_wayland_wl_shell_init (MetaWaylandCompositor *compositor)
-{
-  if (wl_global_create (compositor->wayland_display,
-                        &wl_shell_interface,
-                        META_WL_SHELL_VERSION,
-                        compositor, bind_wl_shell) == NULL)
-    g_error ("Failed to register a global wl-shell object");
-}
diff --git a/src/wayland/meta-wayland-xdg-shell.c b/src/wayland/meta-wayland-xdg-shell.c
index 3b04ece83..acd0913d1 100644
--- a/src/wayland/meta-wayland-xdg-shell.c
+++ b/src/wayland/meta-wayland-xdg-shell.c
@@ -1037,6 +1037,7 @@ finish_popup_setup (MetaWaylandXdgPopup *xdg_popup)
 
   xdg_popup->setup.parent_surface = NULL;
   xdg_popup->setup.grab_seat = NULL;
+  xdg_popup->dismissed_by_client = FALSE;
 
   if (!meta_wayland_surface_get_window (parent_surface))
     {
diff --git a/src/wayland/meta-wayland.c b/src/wayland/meta-wayland.c
index aeccbfe38..5adc5d988 100644
--- a/src/wayland/meta-wayland.c
+++ b/src/wayland/meta-wayland.c
@@ -400,6 +400,13 @@ set_gnome_env (const char *name,
     }
 }
 
+void
+meta_wayland_compositor_init_display (MetaWaylandCompositor *compositor,
+                                      MetaDisplay           *display)
+{
+  meta_xwayland_init_display (&compositor->xwayland_manager, display);
+}
+
 static void meta_wayland_log_func (const char *, va_list) G_GNUC_PRINTF (1, 0);
 
 static void
@@ -430,10 +437,13 @@ meta_wayland_compositor_finalize (GObject *object)
 {
   MetaWaylandCompositor *compositor = META_WAYLAND_COMPOSITOR (object);
 
+  g_clear_object (&compositor->dma_buf_manager);
+
   g_clear_pointer (&compositor->seat, meta_wayland_seat_free);
 
   g_clear_pointer (&compositor->display_name, g_free);
   g_clear_pointer (&compositor->wayland_display, wl_display_destroy);
+  g_clear_pointer (&compositor->source, g_source_destroy);
 
   G_OBJECT_CLASS (meta_wayland_compositor_parent_class)->finalize (object);
 }
@@ -518,6 +528,29 @@ meta_wayland_init_egl (MetaWaylandCompositor *compositor)
     g_warning ("Failed to bind Wayland display: %s", error->message);
 }
 
+static void
+init_dma_buf_support (MetaWaylandCompositor *compositor)
+{
+  g_autoptr (GError) error = NULL;
+
+  compositor->dma_buf_manager = meta_wayland_dma_buf_manager_new (compositor,
+                                                                  &error);
+  if (!compositor->dma_buf_manager)
+    {
+      if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED))
+        {
+          meta_topic (META_DEBUG_WAYLAND,
+                      "Wayland DMA buffer protocol support not enabled: %s",
+                      error->message);
+        }
+      else
+        {
+          g_warning ("Wayland DMA buffer protocol support not enabled: %s",
+                     error->message);
+        }
+    }
+}
+
 MetaWaylandCompositor *
 meta_wayland_compositor_new (MetaContext *context)
 {
@@ -540,6 +573,8 @@ meta_wayland_compositor_new (MetaContext *context)
    */
   g_source_set_priority (wayland_event_source, GDK_PRIORITY_EVENTS + 1);
   g_source_attach (wayland_event_source, NULL);
+  compositor->source = wayland_event_source;
+  g_source_unref (wayland_event_source);
 
   g_signal_connect (stage, "after-update",
                     G_CALLBACK (on_after_update), compositor);
@@ -547,9 +582,9 @@ meta_wayland_compositor_new (MetaContext *context)
                     G_CALLBACK (on_presented), compositor);
 
   if (!wl_global_create (compositor->wayland_display,
-			 &wl_compositor_interface,
-			 META_WL_COMPOSITOR_VERSION,
-			 compositor, compositor_bind))
+                         &wl_compositor_interface,
+                         META_WL_COMPOSITOR_VERSION,
+                         compositor, compositor_bind))
     g_error ("Failed to register the global wl_compositor");
 
   meta_wayland_init_egl (compositor);
@@ -567,11 +602,10 @@ meta_wayland_compositor_new (MetaContext *context)
   meta_wayland_relative_pointer_init (compositor);
   meta_wayland_pointer_constraints_init (compositor);
   meta_wayland_xdg_foreign_init (compositor);
-  meta_wayland_dma_buf_init (compositor);
+  init_dma_buf_support (compositor);
   meta_wayland_keyboard_shortcuts_inhibit_init (compositor);
   meta_wayland_surface_inhibit_shortcuts_dialog_init ();
   meta_wayland_text_input_init (compositor);
-  meta_wayland_gtk_text_input_init (compositor);
   meta_wayland_init_presentation_time (compositor);
   meta_wayland_activation_init (compositor);
 
@@ -582,24 +616,24 @@ meta_wayland_compositor_new (MetaContext *context)
                                   compositor);
 
 #ifdef HAVE_WAYLAND_EGLSTREAM
-    {
-      gboolean should_enable_eglstream_controller = TRUE;
+  {
+    gboolean should_enable_eglstream_controller = TRUE;
 #if defined(HAVE_EGL_DEVICE) && defined(HAVE_NATIVE_BACKEND)
-      MetaRenderer *renderer = meta_backend_get_renderer (backend);
+    MetaRenderer *renderer = meta_backend_get_renderer (backend);
 
-      if (META_IS_RENDERER_NATIVE (renderer))
-        {
-          MetaRendererNative *renderer_native = META_RENDERER_NATIVE (renderer);
+    if (META_IS_RENDERER_NATIVE (renderer))
+      {
+        MetaRendererNative *renderer_native = META_RENDERER_NATIVE (renderer);
 
-          if (meta_renderer_native_get_mode (renderer_native) ==
-              META_RENDERER_NATIVE_MODE_GBM)
-            should_enable_eglstream_controller = FALSE;
-        }
+        if (meta_renderer_native_get_mode (renderer_native) ==
+            META_RENDERER_NATIVE_MODE_GBM)
+          should_enable_eglstream_controller = FALSE;
+      }
 #endif /* defined(HAVE_EGL_DEVICE) && defined(HAVE_NATIVE_BACKEND) */
 
-      if (should_enable_eglstream_controller)
-        meta_wayland_eglstream_controller_init (compositor);
-    }
+    if (should_enable_eglstream_controller)
+      meta_wayland_eglstream_controller_init (compositor);
+  }
 #endif /* HAVE_WAYLAND_EGLSTREAM */
 
   x11_display_policy =
diff --git a/src/wayland/meta-wayland.h b/src/wayland/meta-wayland.h
index 387e98b52..bee2ef445 100644
--- a/src/wayland/meta-wayland.h
+++ b/src/wayland/meta-wayland.h
@@ -36,6 +36,9 @@ MetaWaylandCompositor * meta_wayland_compositor_new             (MetaContext *co
 
 void                    meta_wayland_compositor_prepare_shutdown (MetaWaylandCompositor *compositor);
 
+void                    meta_wayland_compositor_init_display    (MetaWaylandCompositor *compositor,
+                                                                 MetaDisplay           *display);
+
 META_EXPORT_TEST
 MetaWaylandCompositor  *meta_wayland_compositor_get_default     (void);
 
diff --git a/src/wayland/meta-window-wayland.c b/src/wayland/meta-window-wayland.c
index 12e9567d9..fb7198e8b 100644
--- a/src/wayland/meta-window-wayland.c
+++ b/src/wayland/meta-window-wayland.c
@@ -861,6 +861,22 @@ acquire_acked_configuration (MetaWindowWayland       *wl_window,
   return NULL;
 }
 
+static gboolean
+has_pending_resize (MetaWindowWayland *wl_window)
+{
+  GList *l;
+
+  for (l = wl_window->pending_configurations; l; l = l->next)
+    {
+      MetaWaylandWindowConfiguration *configuration = l->data;
+
+      if (configuration->has_size)
+        return TRUE;
+    }
+
+  return FALSE;
+}
+
 int
 meta_window_wayland_get_geometry_scale (MetaWindow *window)
 {
@@ -944,6 +960,9 @@ meta_window_wayland_finish_move_resize (MetaWindow              *window,
 
   flags = META_MOVE_RESIZE_WAYLAND_FINISH_MOVE_RESIZE;
 
+  if (!has_pending_resize (wl_window))
+    flags |= META_MOVE_RESIZE_WAYLAND_CLIENT_RESIZE;
+
   acked_configuration = acquire_acked_configuration (wl_window, pending);
 
   /* x/y are ignored when we're doing interactive resizing */
diff --git a/src/wayland/meta-xwayland-dnd.c b/src/wayland/meta-xwayland-dnd.c
index e8d38c0be..b3b94914d 100644
--- a/src/wayland/meta-xwayland-dnd.c
+++ b/src/wayland/meta-xwayland-dnd.c
@@ -946,10 +946,11 @@ meta_xwayland_dnd_handle_event (XEvent *xevent)
 }
 
 void
-meta_xwayland_init_dnd (Display *xdisplay)
+meta_xwayland_init_dnd (MetaX11Display *x11_display)
 {
   MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
   MetaXWaylandManager *manager = &compositor->xwayland_manager;
+  Display *xdisplay = meta_x11_display_get_xdisplay (x11_display);
   MetaXWaylandDnd *dnd = manager->dnd;
   XSetWindowAttributes attributes;
   guint32 i, version = XDND_VERSION;
@@ -965,7 +966,7 @@ meta_xwayland_init_dnd (Display *xdisplay)
   attributes.override_redirect = True;
 
   dnd->dnd_window = XCreateWindow (xdisplay,
-                                   gdk_x11_window_get_xid (gdk_get_default_root_window ()),
+                                   meta_x11_display_get_xroot (x11_display),
                                    -1, -1, 1, 1,
                                    0, /* border width */
                                    0, /* depth */
@@ -981,13 +982,13 @@ meta_xwayland_init_dnd (Display *xdisplay)
 
 void
 meta_xwayland_shutdown_dnd (MetaXWaylandManager *manager,
-                            Display             *xdisplay)
+                            MetaX11Display      *x11_display)
 {
   MetaXWaylandDnd *dnd = manager->dnd;
 
   g_assert (dnd != NULL);
 
-  XDestroyWindow (xdisplay, dnd->dnd_window);
+  XDestroyWindow (meta_x11_display_get_xdisplay (x11_display), dnd->dnd_window);
   dnd->dnd_window = None;
 
   g_free (dnd);
diff --git a/src/wayland/meta-xwayland-private.h b/src/wayland/meta-xwayland-private.h
index 51fba035e..90f36497c 100644
--- a/src/wayland/meta-xwayland-private.h
+++ b/src/wayland/meta-xwayland-private.h
@@ -31,8 +31,12 @@ meta_xwayland_init (MetaXWaylandManager    *manager,
                     GError                **error);
 
 void
-meta_xwayland_complete_init (MetaDisplay *display,
-                             Display     *xdisplay);
+meta_xwayland_init_display (MetaXWaylandManager  *manager,
+                            MetaDisplay          *display);
+
+void
+meta_xwayland_setup_xdisplay (MetaXWaylandManager *manager,
+                              Display             *xdisplay);
 
 void
 meta_xwayland_shutdown (MetaXWaylandManager *manager);
@@ -41,9 +45,9 @@ gboolean
 meta_xwayland_handle_xevent (XEvent *event);
 
 /* wl_data_device/X11 selection interoperation */
-void     meta_xwayland_init_dnd         (Display *xdisplay);
+void meta_xwayland_init_dnd (MetaX11Display *x11_display);
 void meta_xwayland_shutdown_dnd (MetaXWaylandManager *manager,
-                                 Display             *xdisplay);
+                                 MetaX11Display      *x11_display);
 gboolean meta_xwayland_dnd_handle_event (XEvent *xevent);
 
 const MetaWaylandDragDestFuncs * meta_xwayland_selection_get_drag_dest_funcs (void);
diff --git a/src/wayland/meta-xwayland.c b/src/wayland/meta-xwayland.c
index 9f1fac333..77fb366ea 100644
--- a/src/wayland/meta-xwayland.c
+++ b/src/wayland/meta-xwayland.c
@@ -49,6 +49,7 @@
 #include "backends/meta-settings-private.h"
 #include "meta/main.h"
 #include "meta/meta-backend.h"
+#include "meta/meta-x11-errors.h"
 #include "wayland/meta-xwayland-surface.h"
 #include "x11/meta-x11-display-private.h"
 
@@ -66,7 +67,7 @@ static int display_number_override = -1;
 static void meta_xwayland_stop_xserver (MetaXWaylandManager *manager);
 
 static void
-meta_xwayland_set_primary_output (Display *xdisplay);
+meta_xwayland_set_primary_output (MetaX11Display *x11_display);
 
 void
 meta_xwayland_associate_window_with_surface (MetaWindow          *window,
@@ -535,14 +536,12 @@ xserver_died (GObject      *source,
               GAsyncResult *result,
               gpointer      user_data)
 {
-  MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
+  MetaWaylandCompositor *compositor;
   GSubprocess *proc = G_SUBPROCESS (source);
   MetaDisplay *display = meta_get_display ();
   g_autoptr (GError) error = NULL;
   MetaX11DisplayPolicy x11_display_policy;
 
-  x11_display_policy =
-    meta_context_get_x11_display_policy (compositor->context);
   if (!g_subprocess_wait_finish (proc, result, &error))
     {
       if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
@@ -550,7 +549,11 @@ xserver_died (GObject      *source,
 
       g_warning ("Failed to finish waiting for Xwayland: %s", error->message);
     }
-  else if (!g_subprocess_get_successful (proc))
+
+  compositor = meta_wayland_compositor_get_default ();
+  x11_display_policy =
+    meta_context_get_x11_display_policy (compositor->context);
+  if (!g_subprocess_get_successful (proc))
     {
       if (x11_display_policy == META_X11_DISPLAY_POLICY_MANDATORY)
         g_warning ("X Wayland crashed; exiting");
@@ -596,7 +599,10 @@ shutdown_xwayland_cb (gpointer data)
 
   if (!meta_settings_is_experimental_feature_enabled (meta_backend_get_settings (backend),
                                                       META_EXPERIMENTAL_FEATURE_AUTOCLOSE_XWAYLAND))
-    return G_SOURCE_REMOVE;
+    {
+      manager->xserver_grace_period_id = 0;
+      return G_SOURCE_REMOVE;
+    }
 
   if (display->x11_display &&
       !can_terminate_xwayland (display->x11_display->xdisplay))
@@ -635,8 +641,7 @@ static void
 x_io_error_exit (Display *display,
                  void    *data)
 {
-  MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
-  MetaXWaylandManager *manager = &compositor->xwayland_manager;
+  MetaXWaylandManager *manager = data;
 
   g_warning ("Xwayland just died, attempting to recover");
   manager->xserver_grace_period_id =
@@ -777,6 +782,7 @@ choose_xdisplay (MetaXWaylandManager     *manager,
             {
               g_prefix_error (&local_error, "Failed to bind X11 socket: ");
               g_propagate_error (error, g_steal_pointer (&local_error));
+              g_free (lock_file);
               return FALSE;
             }
 
@@ -1137,9 +1143,6 @@ meta_xwayland_stop_xserver (MetaXWaylandManager *manager)
 {
   if (manager->proc)
     g_subprocess_send_signal (manager->proc, SIGTERM);
-  g_signal_handlers_disconnect_by_func (meta_get_display (),
-                                        window_created_cb,
-                                        manager);
   g_clear_object (&manager->xserver_died_cancellable);
   g_clear_object (&manager->proc);
 }
@@ -1214,29 +1217,33 @@ monitors_changed_cb (MetaMonitorManager *monitor_manager)
 {
   MetaX11Display *x11_display = meta_get_display ()->x11_display;
 
-  meta_xwayland_set_primary_output (x11_display->xdisplay);
+  meta_xwayland_set_primary_output (x11_display);
 }
 
 static void
 on_x11_display_closing (MetaDisplay         *display,
                         MetaXWaylandManager *manager)
 {
-  Display *xdisplay = meta_x11_display_get_xdisplay (display->x11_display);
+  MetaX11Display *x11_display = meta_display_get_x11_display (display);
 
-  meta_xwayland_shutdown_dnd (manager, xdisplay);
+  meta_xwayland_shutdown_dnd (manager, x11_display);
   g_signal_handlers_disconnect_by_func (meta_monitor_manager_get (),
                                         monitors_changed_cb,
                                         NULL);
   g_signal_handlers_disconnect_by_func (display,
                                         on_x11_display_closing,
                                         manager);
+  g_signal_handlers_disconnect_by_func (display,
+                                        window_created_cb,
+                                        manager);
 }
 
 static void
 meta_xwayland_init_xrandr (MetaXWaylandManager *manager,
-                           Display             *xdisplay)
+                           MetaX11Display      *x11_display)
 {
   MetaMonitorManager *monitor_manager = meta_monitor_manager_get ();
+  Display *xdisplay = meta_x11_display_get_xdisplay (x11_display);
 
   manager->has_xrandr = XRRQueryExtension (xdisplay,
                                            &manager->rr_event_base,
@@ -1251,18 +1258,43 @@ meta_xwayland_init_xrandr (MetaXWaylandManager *manager,
   g_signal_connect (monitor_manager, "monitors-changed",
                     G_CALLBACK (monitors_changed_cb), NULL);
 
-  meta_xwayland_set_primary_output (xdisplay);
+  meta_xwayland_set_primary_output (x11_display);
 }
 
-/* To be called right after connecting */
-void
-meta_xwayland_complete_init (MetaDisplay *display,
-                             Display     *xdisplay)
+static void
+on_x11_display_setup (MetaDisplay         *display,
+                      MetaXWaylandManager *manager)
 {
-  MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
-  MetaXWaylandManager *manager = &compositor->xwayland_manager;
+  MetaContext *context = meta_display_get_context (display);
+  MetaX11Display *x11_display = meta_display_get_x11_display (display);
   MetaX11DisplayPolicy x11_display_policy;
 
+  meta_xwayland_init_dnd (x11_display);
+  meta_xwayland_init_xrandr (manager, x11_display);
+  meta_xwayland_stop_xserver_timeout (manager);
+
+  x11_display_policy = meta_context_get_x11_display_policy (context);
+  if (x11_display_policy == META_X11_DISPLAY_POLICY_ON_DEMAND)
+    {
+      g_signal_connect (display, "window-created",
+                        G_CALLBACK (window_created_cb), manager);
+    }
+}
+
+void
+meta_xwayland_init_display (MetaXWaylandManager *manager,
+                            MetaDisplay         *display)
+{
+  g_signal_connect (display, "x11-display-setup",
+                    G_CALLBACK (on_x11_display_setup), manager);
+  g_signal_connect (display, "x11-display-closing",
+                    G_CALLBACK (on_x11_display_closing), manager);
+}
+
+void
+meta_xwayland_setup_xdisplay (MetaXWaylandManager *manager,
+                              Display             *xdisplay)
+{
   /* We install an X IO error handler in addition to the child watch,
      because after Xlib connects our child watch may not be called soon
      enough, and therefore we won't crash when X exits (and most important
@@ -1270,23 +1302,10 @@ meta_xwayland_complete_init (MetaDisplay *display,
   */
   XSetIOErrorHandler (x_io_error);
 #ifdef HAVE_XSETIOERROREXITHANDLER
-  XSetIOErrorExitHandler (xdisplay, x_io_error_exit, display);
+  XSetIOErrorExitHandler (xdisplay, x_io_error_exit, manager);
 #endif
 
-  g_signal_connect (display, "x11-display-closing",
-                    G_CALLBACK (on_x11_display_closing), manager);
-  meta_xwayland_init_dnd (xdisplay);
   add_local_user_to_xhost (xdisplay);
-  meta_xwayland_init_xrandr (manager, xdisplay);
-
-  x11_display_policy =
-    meta_context_get_x11_display_policy (compositor->context);
-  if (x11_display_policy == META_X11_DISPLAY_POLICY_ON_DEMAND)
-    {
-      meta_xwayland_stop_xserver_timeout (manager);
-      g_signal_connect (meta_get_display (), "window-created",
-                        G_CALLBACK (window_created_cb), manager);
-    }
 }
 
 static void
@@ -1346,8 +1365,9 @@ meta_xwayland_shutdown (MetaXWaylandManager *manager)
 }
 
 static void
-meta_xwayland_set_primary_output (Display *xdisplay)
+meta_xwayland_set_primary_output (MetaX11Display *x11_display)
 {
+  Display *xdisplay = meta_x11_display_get_xdisplay (x11_display);
   XRRScreenResources *resources;
   MetaMonitorManager *monitor_manager;
   MetaLogicalMonitor *primary_monitor;
@@ -1365,6 +1385,7 @@ meta_xwayland_set_primary_output (Display *xdisplay)
   if (!resources)
     return;
 
+  meta_x11_error_trap_push (x11_display);
   for (i = 0; i < resources->noutput; i++)
     {
       RROutput output_id = resources->outputs[i];
@@ -1398,6 +1419,7 @@ meta_xwayland_set_primary_output (Display *xdisplay)
           break;
         }
     }
+  meta_x11_error_trap_pop (x11_display);
 
   XRRFreeScreenResources (resources);
 }
@@ -1414,7 +1436,8 @@ meta_xwayland_handle_xevent (XEvent *event)
   if (manager->has_xrandr && event->type == manager->rr_event_base + RRNotify)
     {
       MetaX11Display *x11_display = meta_get_display ()->x11_display;
-      meta_xwayland_set_primary_output (x11_display->xdisplay);
+
+      meta_xwayland_set_primary_output (x11_display);
       return TRUE;
     }
 
diff --git a/src/wayland/protocol/gtk-text-input.xml b/src/wayland/protocol/gtk-text-input.xml
deleted file mode 100644
index a134a19f6..000000000
--- a/src/wayland/protocol/gtk-text-input.xml
+++ /dev/null
@@ -1,302 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<protocol name="gtk_text_input">
-  <copyright>
-    Copyright © 2012, 2013 Intel Corporation
-    Copyright © 2015, 2016 Jan Arne Petersen
-
-    Permission to use, copy, modify, distribute, and sell this
-    software and its documentation for any purpose is hereby granted
-    without fee, provided that the above copyright notice appear in
-    all copies and that both that copyright notice and this permission
-    notice appear in supporting documentation, and that the name of
-    the copyright holders not be used in advertising or publicity
-    pertaining to distribution of the software without specific,
-    written prior permission.  The copyright holders make no
-    representations about the suitability of this software for any
-    purpose.  It is provided "as is" without express or implied
-    warranty.
-
-    THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
-    SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-    FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
-    SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
-    AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
-    ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
-    THIS SOFTWARE.
-  </copyright>
-
-  <interface name="gtk_text_input" version="1">
-    <description summary="text input">
-      The gtk_text_input interface represents text input and input methods
-      associated with a seat. It provides enter/leave events to follow the
-      text input focus for a seat.
-
-      Requests are used to enable/disable the text-input object and set
-      state information like surrounding and selected text or the content type.
-      The information about the entered text is sent to the text-input object
-      via the pre-edit and commit_string events. Using this interface removes
-      the need for applications to directly process hardware key events and
-      compose text out of them.
-
-      Text is valid UTF-8 encoded, indices and lengths are in bytes. Indices
-      have to always point to the first byte of an UTF-8 encoded code point.
-      Lengths are not allowed to contain just a part of an UTF-8 encoded code
-      point.
-
-      Focus moving throughout surfaces will result in the emission of
-      gtk_text_input.enter and gtk_text_input.leave events. The focused
-      surface must perform gtk_text_input.enable and
-      gtk_text_input.disable requests as the keyboard focus moves across
-      editable and non-editable elements of the UI. Those two requests are not
-      expected to be paired with each other, the compositor must be able to
-      handle consecutive series of the same request.
-
-      State is sent by the state requests (set_surrounding_text,
-      set_content_type and set_cursor_rectangle) and a commit request.
-      After an enter event or disable request all state information is
-      invalidated and needs to be resent by the client.
-
-      This protocol defines requests and events necessary for regular clients
-      to communicate with an input method. The gtk_input_method protocol
-      defines the interfaces necessary to implement standalone input methods.
-      If a compositor implements both interfaces, it will be the arbiter of the
-      communication between both.
-
-      Warning! The protocol described in this file is experimental and
-      backward incompatible changes may be made. Backward compatible changes
-      may be added together with the corresponding interface version bump.
-      Backward incompatible changes are done by bumping the version number in
-      the protocol and interface names and resetting the interface version.
-      Once the protocol is to be declared stable, the 'z' prefix and the
-      version number in the protocol and interface names are removed and the
-      interface version number is reset.
-    </description>
-
-    <request name="destroy" type="destructor">
-      <description summary="Destroy the wp_text_input">
-       Destroy the wp_text_input object. Also disables all surfaces enabled
-       through this wp_text_input object
-      </description>
-    </request>
-
-    <enum name="enable_flags" bitfield="true">
-      <description summary="enable flags">
-       Content hint is a bitmask to allow to modify the behavior of the text
-       input.
-      </description>
-      <entry name="none" value="0x0" summary="no special behaviour"/>
-      <entry name="can_show_preedit" value="0x1" summary="hints that the UI is capable of showing pre-edit text"/>
-      <entry name="toggle_input_panel" value="0x2" summary="requests toggling input panel (eg. on-screen keyboard)"/>
-    </enum>
-
-    <request name="enable">
-      <description summary="Request text input to be enabled">
-	Requests text input on a surface. The serial provided must be the one
-        received on gtk_text_input.enter.
-      </description>
-      <arg name="serial" type="uint" summary="serial of enter event"/>
-      <arg name="show_input_panel" type="uint" summary="details of the enable request"/>
-    </request>
-
-    <request name="disable">
-      <description summary="Disable text input on a surface">
-	Explicitly disable text input in a surface (typically when there is no
-	focus on any text entry inside the surface).
-      </description>
-    </request>
-
-    <request name="set_surrounding_text">
-      <description summary="sets the surrounding text">
-       Sets the plain surrounding text around the input position. Text is
-       UTF-8 encoded. Cursor is the byte offset within the surrounding text.
-       Anchor is the byte offset of the selection anchor within the
-       surrounding text. If there is no selected text, anchor is the same as
-       cursor.
-
-       Make sure to always send some text before and after the cursor
-       except when the cursor is at the beginning or end of text.
-
-       When there was a configure_surrounding_text event take the
-       before_cursor and after_cursor arguments into account for picking how
-       much surrounding text to send.
-
-       There is a maximum length of wayland messages so text can not be
-       longer than 4000 bytes.
-      </description>
-      <arg name="text" type="string"/>
-      <arg name="cursor" type="int"/>
-      <arg name="anchor" type="int"/>
-    </request>
-
-    <enum name="content_hint" bitfield="true">
-      <description summary="content hint">
-       Content hint is a bitmask to allow to modify the behavior of the text
-       input.
-      </description>
-      <entry name="none" value="0x0" summary="no special behaviour"/>
-      <entry name="completion" value="0x1" summary="suggest word completions"/>
-      <entry name="spellcheck" value="0x2" summary="suggest word corrections"/>
-      <entry name="auto_capitalization" value="0x4" summary="switch to uppercase letters at the start of a sentence"/>
-      <entry name="lowercase" value="0x8" summary="prefer lowercase letters"/>
-      <entry name="uppercase" value="0x10" summary="prefer uppercase letters"/>
-      <entry name="titlecase" value="0x20" summary="prefer casing for titles and headings (can be language dependent)"/>
-      <entry name="hidden_text" value="0x40" summary="characters should be hidden"/>
-      <entry name="sensitive_data" value="0x80" summary="typed text should not be stored"/>
-      <entry name="latin" value="0x100" summary="just latin characters should be entered"/>
-      <entry name="multiline" value="0x200" summary="the text input is multiline"/>
-    </enum>
-
-    <enum name="content_purpose">
-      <description summary="content purpose">
-       The content purpose allows to specify the primary purpose of a text
-       input.
-
-       This allows an input method to show special purpose input panels with
-       extra characters or to disallow some characters.
-      </description>
-      <entry name="normal" value="0" summary="default input, allowing all characters"/>
-      <entry name="alpha" value="1" summary="allow only alphabetic characters"/>
-      <entry name="digits" value="2" summary="allow only digits"/>
-      <entry name="number" value="3" summary="input a number (including decimal separator and sign)"/>
-      <entry name="phone" value="4" summary="input a phone number"/>
-      <entry name="url" value="5" summary="input an URL"/>
-      <entry name="email" value="6" summary="input an email address"/>
-      <entry name="name" value="7" summary="input a name of a person"/>
-      <entry name="password" value="8" summary="input a password (combine with password or sensitive_data hint)"/>
-      <entry name="pin" value="9" summary="input is a numeric password (combine with password or sensitive_data hint)"/>
-      <entry name="date" value="10" summary="input a date"/>
-      <entry name="time" value="11" summary="input a time"/>
-      <entry name="datetime" value="12" summary="input a date and time"/>
-      <entry name="terminal" value="13" summary="input for a terminal"/>
-    </enum>
-
-    <request name="set_content_type">
-      <description summary="set content purpose and hint">
-       Sets the content purpose and content hint. While the purpose is the
-       basic purpose of an input field, the hint flags allow to modify some
-       of the behavior.
-
-       When no content type is explicitly set, a normal content purpose with
-       none hint should be assumed.
-      </description>
-      <arg name="hint" type="uint" enum="content_hint"/>
-      <arg name="purpose" type="uint" enum="content_purpose"/>
-    </request>
-
-    <request name="set_cursor_rectangle">
-      <description summary="set cursor position">
-       Sets the cursor outline as a x, y, width, height rectangle in surface
-       local coordinates.
-
-       Allows the compositor to put a window with word suggestions near the
-       cursor.
-      </description>
-      <arg name="x" type="int"/>
-      <arg name="y" type="int"/>
-      <arg name="width" type="int"/>
-      <arg name="height" type="int"/>
-    </request>
-
-    <request name="commit">
-      <description summary="commit state">
-       Allows to atomically send state updates from client. The previous
-       set_surrounding_text, set_content_type and set_cursor_rectangle
-       become effective after this call.
-
-       Serial should be set to the serial from the last wp_text_input.enter
-       event.
-
-       To make sure to not receive outdated input method events after a
-       state update, wl_display_sync() should be called after making this
-       request.
-      </description>
-    </request>
-
-    <event name="enter">
-      <description summary="enter event">
-       Notification that this seat's text-input focus is on a certain surface.
-
-       When the seat has the keyboard capability the text-input focus follows
-       the keyboard focus.
-      </description>
-      <arg name="serial" type="uint" summary="serial"/>
-      <arg name="surface" type="object" interface="wl_surface"/>
-    </event>
-
-    <event name="leave">
-      <description summary="leave event">
-       Notification that this seat's text-input focus is no longer on
-       a certain surface. The client should reset any preedit string previously
-       set.
-
-       The leave notification is sent before the enter notification
-       for the new focus.
-
-       When the seat has the keyboard capability the text-input focus follows
-       the keyboard focus.
-      </description>
-      <arg name="serial" type="uint"/>
-      <arg name="surface" type="object" interface="wl_surface"/>
-    </event>
-
-    <event name="preedit_string">
-      <description summary="pre-edit">
-       Notify when a new composing text (pre-edit) should be set around the
-       current cursor position. Any previously set composing text should
-       be removed.
-      </description>
-      <arg name="text" type="string" allow-null="true"/>
-      <arg name="cursor" type="uint"/>
-    </event>
-
-    <event name="commit_string">
-      <description summary="text commit">
-       Notify when text should be inserted into the editor widget. The text to
-       commit could be either just a single character after a key press or the
-       result of some composing (pre-edit).
-
-       The text argument could be also null if some text is removed (see
-       gtk_text_input.delete_surrounding_text).
-
-       Any previously set composing text should be removed.
-      </description>
-      <arg name="text" type="string" allow-null="true"/>
-    </event>
-
-    <event name="delete_surrounding_text">
-      <description summary="delete surrounding text">
-       Notify when the text around the current cursor position should be
-       deleted. Before_length and after_length is the length (in bytes) of text
-       before and after the current cursor position (excluding the selection)
-       to delete.
-
-       This event should be handled as part of a following commit_string or
-       preedit_string event.
-      </description>
-      <arg name="before_length" type="uint" summary="length of text before current cursor position"/>
-      <arg name="after_length" type="uint" summary="length of text after current cursor position"/>
-    </event>
-  </interface>
-
-  <interface name="gtk_text_input_manager" version="1">
-    <description summary="text input manager">
-      A factory for text-input objects. This object is a global singleton.
-    </description>
-
-    <request name="destroy" type="destructor">
-      <description summary="Destroy the wp_text_input_manager">
-       Destroy the wp_text_input_manager object.
-      </description>
-    </request>
-
-    <request name="get_text_input">
-      <description summary="create a new text input object">
-       Creates a new text-input object for a given seat.
-      </description>
-      <arg name="id" type="new_id" interface="gtk_text_input"/>
-      <arg name="seat" type="object" interface="wl_seat"/>
-    </request>
-  </interface>
-</protocol>
diff --git a/src/x11/meta-x11-display.c b/src/x11/meta-x11-display.c
index 502b1a962..7b89cac24 100644
--- a/src/x11/meta-x11-display.c
+++ b/src/x11/meta-x11-display.c
@@ -1151,7 +1151,13 @@ meta_x11_display_new (MetaDisplay *display, GError **error)
 
 #ifdef HAVE_WAYLAND
   if (meta_is_wayland_compositor ())
-    meta_xwayland_complete_init (display, xdisplay);
+    {
+      MetaContext *context = meta_display_get_context (display);
+      MetaWaylandCompositor *compositor =
+        meta_context_get_wayland_compositor (context);
+
+      meta_xwayland_setup_xdisplay (&compositor->xwayland_manager, xdisplay);
+    }
 #endif
 
   if (meta_is_syncing ())
diff --git a/src/x11/session.c b/src/x11/session.c
index 339a7ae33..5b4879bc0 100644
--- a/src/x11/session.c
+++ b/src/x11/session.c
@@ -1102,6 +1102,9 @@ load_state (const char *previous_save_file)
   gsize length;
   char *session_file;
 
+  parse_data.info = NULL;
+  parse_data.previous_id = NULL;
+
   session_file = g_strconcat (g_get_user_config_dir (),
                               G_DIR_SEPARATOR_S "mutter"
                               G_DIR_SEPARATOR_S "sessions" G_DIR_SEPARATOR_S,
@@ -1114,39 +1117,14 @@ load_state (const char *previous_save_file)
                             &length,
                             &error))
     {
-      char *canonical_session_file = session_file;
-
-      /* Maybe they were doing it the old way, with ~/.mutter */
-      session_file = g_strconcat (g_get_home_dir (),
-                                  G_DIR_SEPARATOR_S ".mutter"
-                                  G_DIR_SEPARATOR_S "sessions"
-                                  G_DIR_SEPARATOR_S,
-                                  previous_save_file,
-                                  NULL);
-
-      if (!g_file_get_contents (session_file,
-                                &text,
-                                &length,
-                                NULL))
-        {
-          /* oh, just give up */
-
-          g_error_free (error);
-          g_free (session_file);
-          g_free (canonical_session_file);
-          return NULL;
-        }
-
-      g_free (canonical_session_file);
+      g_free (session_file);
+      goto error;
     }
 
   meta_topic (META_DEBUG_SM, "Parsing saved session file %s", session_file);
   g_free (session_file);
   session_file = NULL;
 
-  parse_data.info = NULL;
-  parse_data.previous_id = NULL;
-
   context = g_markup_parse_context_new (&mutter_session_parser,
                                         0, &parse_data, NULL);
 
diff --git a/tools/uncrustify.cfg b/tools/uncrustify.cfg
index 9976620e2..f32b94186 100644
--- a/tools/uncrustify.cfg
+++ b/tools/uncrustify.cfg
@@ -120,6 +120,10 @@ nl_func_call_empty = remove
 # Add stars at the beginning of each line in multiline comments
 cmt_star_cont = true
 
+# Remove space between glib/gettext i18n function shortcuts and (
+set func_call_user _ C_ I_ N_ NC_ P_ Q_
+sp_func_call_user_paren = remove
+
 #################################################################################
 # IGNORES
 #
